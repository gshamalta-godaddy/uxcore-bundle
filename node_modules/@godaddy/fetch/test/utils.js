const assume = require('assume');
const http = require('http');

const PORT = 9090;
const API = {
  POST: `http://localhost:${ PORT }`,
  GET: 'https://img1.wsimg.com/poly/v3/polyfill.js?features=fetch'
};

/**
 * Assert fetch API compliant classes.
 *
 * @param {Request} Request constructor for Request class.
 * @param {Headers} Headers constructor for Headers class.
 * @param {Response} Response constructor for Response class.
 * @returns {Function} runnable test descriptor.
 * @public
 */
function assertExportedClasses(Request, Headers, Response) {
  return function assert() {
    [Request, Headers, Response].forEach(className => assume(className).to.be.a('function'));

    const req = new Request(API.GET, { method: 'GET' });
    const res = new Response();
    const headers = new Headers([
      ['Content-Type', 'text/xml']
    ]);

    assume(req).be.instanceof(Request);

    assume(res).be.instanceof(Response);
    assume(res.ok).to.equal(true);
    assume(res.status).to.equal(200);

    assume(headers).be.instanceof(Headers);
    assume(headers.get('Content-Type')).to.equal('text/xml');
  };
}

/**
 * Assert fetch API executing GET request.
 *
 * @param {Function} fetch implementation of fetch.
 * @returns {AsyncFunction} runnable test descriptor.
 * @public
 */
function assertFetchPolyfillIO(fetch) {
  return async function assert() {
    const res = await fetch(API.GET);
    const body = await res.text();
    const headers = res.headers;

    assume(res.ok).to.be.true();
    assume(res.status).to.equal(200);
    assume(headers.get('content-type')).to.equal('text/javascript; charset=utf-8');
    assume(headers.get('cache-control')).to.equal('public, max-age=172800, s-maxage=31536000');

    [
      'Polyfill service v',
      'For detailed credits and licence information see'
    ].forEach(snippet => assume(body).contains(snippet));
  };
}

/**
 * Assert fetch API executing POST request.
 *
 * @param {Function} fetch implementation of fetch.
 * @returns {AsyncFunction} runnable test descriptor.
 * @public
 */
function assertFetchGoDaddyPost(fetch) {
  return async function assert() {
    //
    // Setup a really simple POST echoing http server and close it after
    // succesfully requesting against it.
    //
    const server = http.createServer(function (req, res) {
      const chunks = [];

      req.on('data', chunk => chunks.push(chunk));
      req.on('end', function () {
        res.writeHead(200, {
          'content-type': 'application/json',
          'cache-control': 'max-age=0, no-cache, no-store',
          'access-control-allow-origin': '*'
        });

        res.end(JSON.stringify({
          echo: JSON.parse(chunks.join())
        }));
      });
    }).listen(PORT, async function listening() {
      try {
        const domain = 'testing-fetch.com';
        const res = await fetch(API.POST, {
          method: 'POST',
          body: JSON.stringify([domain])
        });

        const body = await res.json();
        const headers = res.headers;

        assume(res.ok).to.be.true();
        assume(res.status).to.equal(200);

        assume(headers.get('content-type')).to.equal('application/json');
        assume(headers.get('cache-control')).to.equal('max-age=0, no-cache, no-store');

        assume(body).to.deep.equal({
          echo: [domain]
        });

        server.close();
      } catch (error) {
        console.error(error); // eslint-disable-line no-console
      } finally {
        server.close();
      }
    });
  };
}

/**
 * Assert AbortController aborting fetch requests.
 *
 * @param {Function} fetch implementation of fetch.
 * @param {AbortController} AbortController constructor for aborting fetch request.
 * @returns {AsyncFunction} runnable test descriptor.
 * @public
 */
function assertAbortableFetch(fetch, AbortController) {
  return async function assert() {
    const controller = new AbortController();
    const timeout = setTimeout(controller.abort.bind(controller), 20);
    let res;

    try {
      res = await fetch(API.GET, { signal: controller.signal });
    } catch (error) {

      assume(error).to.be.instanceof(Error);
      assume(error.name).to.equal('AbortError');
    } finally {
      assume(res).to.be.falsy();

      clearTimeout(timeout);
    }
  };
}

function assertReadFetch(fetch) {
  return async function assert() {
    const original = window.fetch;
    window.fetch = () => 'replaced window.fetch';
    assume(fetch()).equals('replaced window.fetch');
    window.fetch = original;
  };
}

module.exports = {
  assertFetchPolyfillIO,
  assertFetchGoDaddyPost,
  assertExportedClasses,
  assertAbortableFetch,
  assertReadFetch
};
