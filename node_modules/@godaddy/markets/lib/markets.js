"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getCurrencies", {
  enumerable: true,
  get: function () {
    return _currencies.default;
  }
});
exports.default = exports.RTLMarkets = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _request = _interopRequireDefault(require("@godaddy/request"));

var _cache = _interopRequireDefault(require("./cache"));

var _currencies = _interopRequireDefault(require("./currencies"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const vatInclusion = ['ALL', 'NONE', 'TAXES', 'ICANN'];
const languageAliases = {
  sg: {
    alias: 'zh:s'
  },
  cn: {
    alias: 'zh:s'
  },
  hk: {
    alias: 'zh:t',
    overridePrimary: true
  },
  tw: {
    alias: 'zh:t',
    overridePrimary: true
  }
};
const countryLanguageOverrides = {
  zh: languageName => ({
    'zh:s': languageName,
    'zh:t': languageName
  })
};
const RTLMarkets = ['ar'];
/**
 * Fallback markets for cases where only a language code is known
 * @private
 */

exports.RTLMarkets = RTLMarkets;
const fallbackMarketsForLanguage = {
  ar: 'ar-AE',
  da: 'da-DK',
  de: 'de-DE',
  el: 'el-GR',
  en: 'en-US',
  es: 'es-MX',
  fi: 'fi-FI',
  fr: 'fr-FR',
  hi: 'hi-IN',
  id: 'id-ID',
  it: 'it-IT',
  ja: 'ja-JP',
  ko: 'ko-KR',
  mr: 'mr-IN',
  nb: 'nb-NO',
  nl: 'nl-NL',
  pl: 'pl-PL',
  pt: 'pt-BR',
  ru: 'ru-RU',
  sv: 'sv-SE',
  ta: 'ta-IN',
  th: 'th-TH',
  tr: 'tr-TR',
  uk: 'uk-UA',
  vi: 'vi-VN',
  zh: 'zh-SG'
};
const prefixedDescription = /^(QA|Test)\s*(.*)$/;
const env = process.env.NODE_ENV || 'development'; // eslint-disable-line no-process-env

const envPrefixes = {
  local: 'dev-',
  development: 'dev-',
  test: 'test-',
  staging: '',
  ote: '',
  production: ''
};
const defaults = {
  envPrefix: envPrefixes[env],
  https: false
};
/**
 * This is a temporary mapping of market ID to display code.
 * It is used in the compact display of the market selector.
 * Eventually, the Markets API will return this data, but for now, we'll handle it here.
 * @private
 */

const TempMarketDisplayCodeMap = {
  'da-DK': 'DK',
  'hi-IN': 'हिंदी',
  'ja-JP': '日本語',
  'ko-KR': '한국어',
  'mr-IN': 'मरा',
  'nb-NO': 'NO',
  'pt-BR': 'BR',
  'ru-RU': 'РУ',
  'ta-IN': 'தமி',
  'th-TH': 'ไทย',
  'uk-UA': 'Укр.',
  'zh-HK': '繁體中文',
  'zh-SG': '简体中文',
  'zh-TW': '繁體中文'
};
/**
 * Utility class to get market information
 *
 * @export
 * @class Markets
 */

class Markets {
  constructor(config) {
    this.config = _objectSpread(_objectSpread({}, defaults), config);
    this.cache = new _cache.default();
  }
  /**
   * Parse country code out from market/locale string. If no country code is
   * found, defaults to `us`. E.g., `en-US` returns `us`
   *
   * @readonly
   * @static
   * @param {String} market Market name
   * @returns {String} Lowercase country code
   * @memberOf Markets
   * @api private
   */


  static countryFromMarket(market) {
    // Return the second component of the market as the country
    return (typeof market === 'string' && market.split('-')[1] || 'us').toLowerCase();
  }
  /**
   * Parse language out from market / locale string. E.g., `en-US` returns `en`.
   *
   * @readonly
   * @static
   * @param {String} market Market name
   * @returns {String} Lowercase language
   * @memberOf Markets
   * @api private
   */


  static languageFromMarket(market) {
    // Return the first component of the market as the language
    return (typeof market === 'string' ? market.split('-')[0] : 'en').toLowerCase();
  }
  /**
   * Get the full ll-CC market code to use when only a language is known
   *
   * @param {string} language A two-letter language code like `en` or `de`
   * @returns {string} A ll-CC market code to use when country is not known
   * @public
   * @static
   */


  static fallbackMarketForLanguage(language) {
    return fallbackMarketsForLanguage[language] || 'en-US';
  }
  /**
   * Callback type for getCountries
   *
   * @callback getCountriesCallback
   * @param {Object} err Error object
   * @param {Object} countries All countries, keyed by two-letter country code
   */

  /**
   * Get all countries.
   *
   * @param {Number} privateLabelId Private Label ID for which to get countries
   * @param {getCountriesCallback} callback Callback to run after countries are retrieved
   *
   * @readonly
   * @memberOf Markets
   * @api public
   */


  getCountries(privateLabelId, callback) {
    this.getMarkets(privateLabelId, (error, markets) => {
      if (error) {
        return callback(error);
      }

      const countries = this.getCountriesFromData(markets);
      callback(null, countries);
    });
  }
  /**
   * Get all countries given pre-loaded markets data
   *
   * @param {Object} markets Market data loaded with `getMarkets`
   * @returns {Object} Data pivoted to describe countries
   * @memberof Markets
   * @public
   */


  getCountriesFromData(markets) {
    // Group markets by country code with rollup of `languages`. Assumes all
    // languages for country have same `currency` and `countrySite` and that
    // at most one language is flagged as `primaryLanguageForCountry`.
    const countries = {};
    Object.keys(markets).forEach(marketId => {
      const market = markets[marketId];
      const languageAlias = languageAliases[market.countryCode];
      const country = countries[market.countryCode] = countries[market.countryCode] || {
        currency: market.currency,
        languages: {},
        countrySite: market.countrySite,
        primaryLanguage: languageAlias && languageAlias.overridePrimary && languageAlias.alias
      };

      if (languageAlias) {
        country.languageAlias = languageAlias.alias;
      }

      if (!country.primaryLanguage && market.primaryLanguageForCountry) {
        country.primaryLanguage = market.languageCode;
      }

      const countryLanguageOverride = countryLanguageOverrides[market.languageCode];
      country.languages[market.languageCode] = countryLanguageOverride ? countryLanguageOverride(market.languageName) : market.languageName;
    }); // For any countries that have `languages` but no `primaryLanguage`, use
    // their first language. (The only non-QA country that this is currently
    // the case for is IL, which has a single language: en.)

    Object.keys(countries).forEach(countryCode => {
      const country = countries[countryCode];
      const languageKeys = Object.keys(country.languages);

      if (!country.primaryLanguage && languageKeys.length) {
        country.primaryLanguage = languageKeys[0];
      }
    });
    return countries;
  }
  /**
   * Callback type for getCountry
   *
   * @callback getCountryCallback
   * @param {Object} err Error object
   * @param {Object} country Country
   */

  /**
   * Get a single country.
   *
   * @param {Number} privateLabelId Private Label ID for which to get country
   * @param {String} countryCode Two-letter country code; e.g., `us`
   * @param {getCountryCallback} callback Callback to run after country is retrieved
   *
   * @readonly
   * @memberOf Markets
   * @api public
   */


  getCountry(privateLabelId, countryCode, callback) {
    this.getCountries(privateLabelId, (error, countries) => {
      if (error) {
        return callback(error);
      }

      const country = countries[countryCode];

      if (!country) {
        return callback(new Error(`no such country: ${countryCode}`));
      }

      callback(null, country);
    });
  }
  /**
   * Callback type for getMarketNames
   *
   * @callback getMarketNamesCallback
   * @param {Object} err Error object
   * @param {Array} marketNames A list of market names
   */

  /**
   * Get all market names.
   *
   * @param {Number} privateLabelId Private Label ID for which to get market names
   * @param {getMarketNamesCallback} callback Callback to run after market names are retrieved
   *
   * @readonly
   * @memberOf Markets
   * @api public
   */


  getMarketNames(privateLabelId, callback) {
    this.getMarkets(privateLabelId, (error, markets) => {
      if (error) {
        return callback(error);
      }

      callback(null, Object.keys(markets));
    });
  }
  /**
   * Callback type for getMarkets
   *
   * @callback getMarketsCallback
   * @param {Object} err Error object
   * @param {Object} markets All markets, keyed by market ID
   */

  /**
   * Get all markets.
   *
   * @param {Number} privateLabelId Private Label ID for which to get markets
   * @param {getMarketsCallback} callback Callback to run after markets are retrieved
   *
   * @readonly
   * @memberOf Markets
   * @api public
   */


  getMarkets(privateLabelId, callback) {
    this.cache.wrap(privateLabelId, cacheCallback => {
      const {
        https,
        envPrefix,
        requestOptions = {}
      } = this.config;
      const protocol = https ? 'https' : 'http';
      const url = `${protocol}://merch.${envPrefix}godaddy.com/v1/markets/?plid=${privateLabelId}`;

      _request.default.get(url, requestOptions, (error, markets) => {
        if (error) {
          return cacheCallback(error);
        }

        const result = markets.reduce((_result, market) => {
          const {
            marketId,
            description
          } = market;
          const countryCode = Markets.countryFromMarket(marketId);
          const languageCode = Markets.languageFromMarket(marketId);
          let [countryName, languageName] = description.split('-').map(s => s.trim()); // Fallback for unhyphenated `description`s.

          if (!languageName) {
            const match = prefixedDescription.exec(description);

            if (match) {
              countryName = match[1];
              languageName = match[2];
            } else {
              languageName = countryName;
              countryName = countryCode.toUpperCase();
            }
          }

          const _market = {
            market: marketId,
            internal: market.internal,
            isRTL: RTLMarkets.includes(languageCode),
            countryCode,
            languageCode,
            description,
            countryName,
            languageName,
            currency: market.defaultCurrency,
            countrySite: market.seoSubDomain,
            primaryLanguageForCountry: market.seoIsPrimaryForSubdomain,
            displayTaxesAndFees: market.displayTaxesAndFees,
            vatIncluded: vatInclusion.indexOf(market.displayTaxesAndFees) > -1
          };
          const languageAlias = languageAliases[_market.countryCode];

          if (languageAlias && languageAlias.alias.indexOf(_market.languageCode) === 0) {
            _market.languageAlias = languageAlias.alias;
          }

          const displayCode = market.displayCode || TempMarketDisplayCodeMap[marketId];

          if (displayCode) {
            _market.displayCode = displayCode;
          }

          _result[marketId] = _market;
          return _result;
        }, {});
        cacheCallback(null, result);
      });
    }, callback);
  }
  /**
   * Callback type for getMarket
   *
   * @callback getMarketCallback
   * @param {Object} err Error object
   * @param {Object} market Market
   */

  /**
   * Get a single market.
   *
   * @param {Number} privateLabelId Private Label ID for which to get market
   * @param {String} marketId ID of market to get
   * @param {getMarketCallback} callback Callback to run after market is retrieved
   *
   * @readonly
   * @memberOf Markets
   * @api public
   */


  getMarket(privateLabelId, marketId, callback) {
    this.getMarkets(privateLabelId, (error, markets) => {
      if (error) {
        return callback(error);
      }

      const market = markets[marketId];

      if (!market) {
        return callback(new Error(`no such market: ${marketId}`));
      }

      callback(null, market);
    });
  }
  /**
   * Callback type for isVATIncluded
   *
   * @callback isVATIncludedCallback
   * @param {Object} err Error object
   * @param {Boolean} vatIncluded Whether VAT is included in prices for the specified market
   */

  /**
   * Get whether VAT is included in prices for the specified market.
   *
   * @param {Number} privateLabelId Private Label ID
   * @param {String} marketId Market ID
   * @param {isVATIncludedCallback} callback Callback to run after VAT-inclusion is retrieved
   *
   * @readonly
   * @memberOf Markets
   * @api public
   */


  isVATIncluded(privateLabelId, marketId, callback) {
    this.getMarket(privateLabelId, marketId, (error, market) => {
      if (error) {
        return callback(error);
      }

      return callback(null, market.vatIncluded);
    });
  }
  /**
   * Callback type for getCurrencies
   *
   * @callback getCurrenciesCallback
   * @param {Object} err Error object
   * @param {Array} currencies An array of currencies
   */

  /**
   * Gets a list of currencies asynchronously
   *
   * @param {String} guiUrl URL to the Presentation Central GUI endpoint
   * @param {String} [marketId='en-US'] The currently selected market
   * @param {Number} [privateLabelId=1] Private Label ID
   * @param {getCurrenciesCallback} done Callback to run after currencies are retrieved
   *
   * @readonly
   * @memberOf Markets
   * @api public
   * @deprecated Consider using directly by importing `{ getCurrencies } from '@godaddy/markets'`
   */


  getCurrencies(guiUrl, marketId, privateLabelId, done) {
    (0, _currencies.default)(guiUrl, marketId, privateLabelId, done);
  }

}

exports.default = Markets;