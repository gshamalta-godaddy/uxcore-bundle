import assume from 'assume';
import sinon from 'sinon';
import request from '@godaddy/request';
import Markets, { RTLMarkets, getCurrencies } from '../src/markets';
import Cache from '../src/cache';
import apiMarkets from './fixtures/apiMarkets.json';
import expectedMarkets from './fixtures/expectedMarkets.json';
import expectedCountries from './fixtures/expectedCountries.json';

describe('Markets', function () {
  const privateLabelId = 1592; // Domains Priced Right

  let markets;

  beforeEach(function () {
    markets = new Markets({ envPrefix: 'test-' });

    sinon.stub(Cache.prototype, 'wrap').callsFake((key, provider, callback) => {
      callback(null, expectedMarkets);
    });
  });

  afterEach(function () {
    sinon.restore();
  });

  describe('Constants', function () {

    it('should have array of RTL markets', function () {
      assume(RTLMarkets instanceof Array).to.be.true();
    });

  });

  describe('Exports', function () {
    it('exports getCurrencies', function () {
      assume(getCurrencies).is.a('function');
    });
  });

  describe('constructor', function () {
    beforeEach(function () {
      Cache.prototype.wrap.restore();

      sinon.stub(request, 'get').callsFake((url, options, callback) => {
        callback(null, apiMarkets);
      });
    });

    it('should allow config override', function (done) {
      const envPrefix = 'blah-';

      new Markets({ envPrefix }).getMarkets(privateLabelId, () => {
        assume(request.get.firstCall.args[0].startsWith(`http://market.api.int.${envPrefix}godaddy.com`));

        done();
      });
    });

    it('can make the request over https', function (done) {
      new Markets({ https: true }).getMarkets(privateLabelId, () => {
        assume(request.get.firstCall.args[0].startsWith(`https://`));

        done();
      });
    });
  });

  describe('countryFromMarket', function () {
    it('properly parses ll-cc codes', function () {
      const country = Markets.countryFromMarket('wx-yz');

      assume(country).equals('yz');
    });

    it('falls back to US when non-string input is passed', function () {
      const country = Markets.countryFromMarket(null);

      assume(country).equals('us');
    });

    it('always returns lower-case country codes', function () {
      const country = Markets.countryFromMarket('WX-YZ');

      assume(country).equals('yz');
    });
  });

  describe('languageFromMarket', function () {
    it('properly parses ll-cc codes', function () {
      const language = Markets.languageFromMarket('wx-yz');

      assume(language).equals('wx');
    });

    it('falls back to English when non-string input is passed', function () {
      const language = Markets.languageFromMarket(null);

      assume(language).equals('en');
    });

    it('always returns lower-case language', function () {
      const language = Markets.languageFromMarket('EN-US');

      assume(language).equals('en');
    });
  });

  describe('fallbackMarketFromLanguage', function () {
    it('returns a fallback market for a known language', function () {
      const fallbackMarket = Markets.fallbackMarketForLanguage('de');
      assume(fallbackMarket).equals('de-DE');
    });

    it('returns en-US for unknown languages', function () {
      const fallbackMarket = Markets.fallbackMarketForLanguage('zz');
      assume(fallbackMarket).equals('en-US');
    });
  });

  describe('getMarkets', function () {
    beforeEach(() => {
      Cache.prototype.wrap.restore();
    });

    it('should return error on API failure', done => {
      const expected = 'api error';

      sinon.stub(request, 'get').yields(expected);

      markets.getMarkets(privateLabelId, error => {
        assume(error).equals(expected);

        done();
      });
    });

    it('should return object', done => {
      sinon.stub(request, 'get').yields(null, apiMarkets);

      markets.getMarkets(privateLabelId, (error, response) => {
        assume(error).does.not.exist();
        assume(response).eqls(expectedMarkets);

        done();
      });
    });

    it('should use countryCode for countryName if no prefix match', done => {
      const countryCode = 'YY';
      const marketId = `xx-${countryCode}`;

      sinon.stub(request, 'get').yields(null, [{
        marketId,
        description: 'does not match'
      }]);

      markets.getMarkets(privateLabelId, (error, response) => {
        assume(error).does.not.exist();
        assume(response[marketId].countryName).equals(countryCode);

        done();
      });
    });

    it('should handle QA prefix', done => {
      const marketId = `QAnat`;

      sinon.stub(request, 'get').yields(null, [{
        marketId,
        description: marketId
      }]);

      markets.getMarkets(privateLabelId, (error, response) => {
        assume(error).does.not.exist();
        assume(response[marketId].countryName).equals('QA');
        assume(response[marketId].languageName).equals('nat');

        done();
      });
    });
  });

  describe('getMarket', function () {
    it('should return error on getMarkets failure', done => {
      const expected = 'getMarkets error';

      sinon.stub(markets, 'getMarkets').yields(expected);

      markets.getMarket(privateLabelId, 'en-US', error => {
        assume(error).equals(expected);

        done();
      });
    });

    it('should return error on invalid market', done => {
      const marketId = 'foo-bar';
      const expected = `no such market: ${marketId}`;

      markets.getMarket(privateLabelId, 'foo-bar', error => {
        assume(error.message).equals(expected);

        done();
      });
    });

    it('should return object', done => {
      markets.getMarket(privateLabelId, 'en-US', (error, market) => {
        assume(error).does.not.exist();
        assume(market).eqls(expectedMarkets['en-US']);

        done();
      });
    });

    it('includes displayCode when returned from API', done => {
      markets.getMarket(privateLabelId, 'da-DK', (error, market) => {
        assume(error).does.not.exist();
        assume(market.displayCode).equals('DK');

        done();
      });
    });

    it('includes displayCode when explicitly defined in the temporary mapping', done => {
      markets.getMarket(privateLabelId, 'nb-NO', (error, market) => {
        assume(error).does.not.exist();
        assume(market.displayCode).equals('NO');

        done();
      });
    });

    it('does not include displayCode when not defined', done => {
      markets.getMarket(privateLabelId, 'en-US', (error, market) => {
        assume(error).does.not.exist();
        assume(market).does.not.own('displayCode');

        done();
      });
    });

    it('should not be RTL market', function (done) {
      markets.getMarket(privateLabelId, 'en-US', (error, market) => {
        assume(error).does.not.exist();
        assume(market.isRTL).to.be.false();

        done();
      });
    });

    it('should be RTL market', function (done) {
      markets.getMarket(privateLabelId, 'ar-AE', (error, market) => {
        assume(error).does.not.exist();
        assume(market.isRTL).to.be.true();

        done();
      });
    });
  });

  describe('getMarketNames', function () {
    it('should return error on getMarkets failure', done => {
      const expected = 'getMarkets error';

      sinon.stub(markets, 'getMarkets').yields(expected);

      markets.getMarketNames(privateLabelId, error => {
        assume(error).equals(expected);

        done();
      });
    });

    it('should return array of market names', done => {
      markets.getMarketNames(privateLabelId, (error, marketNames) => {
        assume(error).does.not.exist();
        assume(marketNames).eqls(Object.keys(expectedMarkets));

        done();
      });
    });
  });

  describe('getCountries', function () {
    it('should return error on getMarkets failure', done => {
      const expected = 'getMarkets error';

      sinon.stub(markets, 'getMarkets').yields(expected);

      markets.getCountries(privateLabelId, error => {
        assume(error).equals(expected);

        done();
      });
    });

    it('should return expected countries', done => {
      markets.getCountries(privateLabelId, (error, countries) => {
        assume(error).does.not.exist();
        assume(countries).eqls(expectedCountries);

        done();
      });
    });
  });

  describe('getCountry', function () {
    it('should return error on getCountries failure', done => {
      const expected = 'getCountries error';

      sinon.stub(markets, 'getCountries').yields(expected);

      markets.getCountry(privateLabelId, 'us', error => {
        assume(error).equals(expected);

        done();
      });
    });

    it('should return error on bad country code', done => {
      const countryCode = 'xyz';
      const expected = `no such country: ${countryCode}`;

      markets.getCountry(privateLabelId, countryCode, error => {
        assume(error.message).equals(expected);

        done();
      });
    });

    it('should return expected country', done => {
      const countryCode = 'us';

      markets.getCountry(privateLabelId, countryCode, (error, country) => {
        assume(error).does.not.exist();
        assume(country).eqls(expectedCountries[countryCode]);

        done();
      });
    });
  });

  describe('isVATIncluded', function () {
    it('should return error on getMarkets failure', done => {
      const expected = 'getMarkets error';

      sinon.stub(markets, 'getMarkets').yields(expected);

      markets.isVATIncluded(privateLabelId, 'en-US', error => {
        assume(error).equals(expected);

        done();
      });
    });

    it('should return vatIncluded', done => {
      markets.isVATIncluded(privateLabelId, 'da-DK', (error, vatIncluded) => {
        assume(error).does.not.exist();
        assume(vatIncluded).is.true();

        done();
      });
    });
  });

  describe('getCurrencies', function () {
    it('is a function', function () {
      assume(markets.getCurrencies).is.a('function');
    });
  });
});
