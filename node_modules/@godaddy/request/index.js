import fetch, { AbortController, Request } from '@godaddy/fetch';
import diagnostics from 'diagnostics';
import qs from 'querystringify';
import jsonp from 'jsonp';
import rip from 'rip-out';

const log = diagnostics('request');

/**
 * Safely stringify an object into JSON and log on error
 *
 * @param {Object} obj An object to stringify into JSON.
 * @returns {String} A JSON string representing obj.
 * @private
 */
function jsonstringify(obj) {
  try {
    return JSON.stringify(obj);
  } catch (error) {
    log(error.message);
  }
}

/**
 * @callback RequestCallback
 * @param {Error} [err] Error, if any
 * @param {any} [data] Data returned
 */
/**
 * Send the request and process response.
 *
 * @param {String} url URI to request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {Request} Request instance.
 * @private
 */
function send(url, options, done) { // eslint-disable-line max-statements, complexity
  if (typeof options === 'function') {
    done = options;
    options = {};
  }

  let controller = options.controller;

  // Cautiously enhance functionality to abort fetch
  if (!controller && typeof AbortController !== 'undefined') {
    controller = new AbortController();
  }

  // Provide backwards compatibility for internal configuration of requests,
  // see https://github.com/unshiftio/requests/blob/master/index.js#L102.
  options.mode = options.mode || 'cors';
  options.credentials = options.credentials || 'include';
  options.timeout = options.timeout || 30000;
  url = url + qs.stringify(options.query || {}, true);

  if (options.jsonp) {
    return jsonp(url, options, done);
  }

  if (options.body && typeof options.body !== 'string') {
    options.body = jsonstringify(options.body);
  }

  if (typeof options.timeout === 'number' && controller) {
    setTimeout(controller.abort.bind(controller), options.timeout);
    options.signal = controller.signal;
  }

  //
  // Delete properties that should not be passed to the `window.Request` constructor.
  //
  options = rip(options, 'timeout', 'query', 'controller');

  const request = new Request(url, options);
  fetch(request)
    .then(handleResponse)
    .then(content => {
      done(null, content);
    })
    .catch(done);

  return {
    controller,
    request
  };
}

/**
 * Extract the method that should be used for reading content from the content-type.
 *
 * @param {string} type Content type
 * @returns {string} method
 * @private
 */
function getMethod(type) {
  if (type && ~type.indexOf('application/json')) return 'json';
  if (type && ~type.indexOf('text/')) return 'text';

  return 'blob';
}

/**
 * Handles the response of the fetch request
 *
 * @param {Response} response Response from the request
 * @returns {Promise} Content or Error from the response
 * @private
 */
function handleResponse(response) {
  const method = getMethod(response.headers.get('content-type'));

  if (response.status >= 400) {
    const error = new Error(response.statusText);
    error.status = response.status;

    return Promise.reject(error);
  }

  return response[method]();
}

/**
 * Execute DELETE request
 *
 * @param {String} url URI to request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */
export function del(url, options, done) {
  return send(url, {
    ...options,
    method: 'DELETE'
  }, done);
}

/**
 * Execute GET request
 *
 * @param {String} url URI to request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */
export function get(url, options, done) {
  return send(url, options, done);
}

/**
 * Execute PATCH request
 *
 * @param {String} url URI to request.
 * @param {Object} data Data to send with request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */
export function patch(url, data, options, done) {
  if (typeof options === 'function') {
    done = options;
    options = {};
  }

  return send(url, {
    ...options,
    method: 'PATCH',
    body: data
  }, done);
}

/**
 * Execute POST request
 *
 * @param {String} url URI to request.
 * @param {Object} data Data to send with request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */
export function post(url, data, options, done) {
  if (typeof options === 'function') {
    done = options;
    options = {};
  }

  return send(url, {
    ...options,
    method: 'POST',
    body: data
  }, done);
}

/**
 * Execute PUT request
 *
 * @param {String} url URI to request.
 * @param {Object} data Data to send with request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */
export function put(url, data, options, done) {
  if (typeof options === 'function') {
    done = options;
    options = {};
  }

  return send(url, {
    ...options,
    method: 'PUT',
    body: data
  }, done);
}

export default {
  del,
  get,
  patch,
  post,
  put
};
