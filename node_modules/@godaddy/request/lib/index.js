"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.del = del;
exports.get = get;
exports.patch = patch;
exports.post = post;
exports.put = put;
exports.default = void 0;

var _fetch = _interopRequireWildcard(require("@godaddy/fetch"));

var _diagnostics = _interopRequireDefault(require("diagnostics"));

var _querystringify = _interopRequireDefault(require("querystringify"));

var _jsonp = _interopRequireDefault(require("jsonp"));

var _ripOut = _interopRequireDefault(require("rip-out"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const log = (0, _diagnostics.default)('request');
/**
 * Safely stringify an object into JSON and log on error
 *
 * @param {Object} obj An object to stringify into JSON.
 * @returns {String} A JSON string representing obj.
 * @private
 */

function jsonstringify(obj) {
  try {
    return JSON.stringify(obj);
  } catch (error) {
    log(error.message);
  }
}
/**
 * @callback RequestCallback
 * @param {Error} [err] Error, if any
 * @param {any} [data] Data returned
 */

/**
 * Send the request and process response.
 *
 * @param {String} url URI to request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {Request} Request instance.
 * @private
 */


function send(url, options, done) {
  // eslint-disable-line max-statements, complexity
  if (typeof options === 'function') {
    done = options;
    options = {};
  }

  let controller = options.controller; // Cautiously enhance functionality to abort fetch

  if (!controller && typeof _fetch.AbortController !== 'undefined') {
    controller = new _fetch.AbortController();
  } // Provide backwards compatibility for internal configuration of requests,
  // see https://github.com/unshiftio/requests/blob/master/index.js#L102.


  options.mode = options.mode || 'cors';
  options.credentials = options.credentials || 'include';
  options.timeout = options.timeout || 30000;
  url = url + _querystringify.default.stringify(options.query || {}, true);

  if (options.jsonp) {
    return (0, _jsonp.default)(url, options, done);
  }

  if (options.body && typeof options.body !== 'string') {
    options.body = jsonstringify(options.body);
  }

  if (typeof options.timeout === 'number' && controller) {
    setTimeout(controller.abort.bind(controller), options.timeout);
    options.signal = controller.signal;
  } //
  // Delete properties that should not be passed to the `window.Request` constructor.
  //


  options = (0, _ripOut.default)(options, 'timeout', 'query', 'controller');
  const request = new _fetch.Request(url, options);
  (0, _fetch.default)(request).then(handleResponse).then(content => {
    done(null, content);
  }).catch(done);
  return {
    controller,
    request
  };
}
/**
 * Extract the method that should be used for reading content from the content-type.
 *
 * @param {string} type Content type
 * @returns {string} method
 * @private
 */


function getMethod(type) {
  if (type && ~type.indexOf('application/json')) return 'json';
  if (type && ~type.indexOf('text/')) return 'text';
  return 'blob';
}
/**
 * Handles the response of the fetch request
 *
 * @param {Response} response Response from the request
 * @returns {Promise} Content or Error from the response
 * @private
 */


function handleResponse(response) {
  const method = getMethod(response.headers.get('content-type'));

  if (response.status >= 400) {
    const error = new Error(response.statusText);
    error.status = response.status;
    return Promise.reject(error);
  }

  return response[method]();
}
/**
 * Execute DELETE request
 *
 * @param {String} url URI to request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */


function del(url, options, done) {
  return send(url, _objectSpread({}, options, {
    method: 'DELETE'
  }), done);
}
/**
 * Execute GET request
 *
 * @param {String} url URI to request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */


function get(url, options, done) {
  return send(url, options, done);
}
/**
 * Execute PATCH request
 *
 * @param {String} url URI to request.
 * @param {Object} data Data to send with request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */


function patch(url, data, options, done) {
  if (typeof options === 'function') {
    done = options;
    options = {};
  }

  return send(url, _objectSpread({}, options, {
    method: 'PATCH',
    body: data
  }), done);
}
/**
 * Execute POST request
 *
 * @param {String} url URI to request.
 * @param {Object} data Data to send with request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */


function post(url, data, options, done) {
  if (typeof options === 'function') {
    done = options;
    options = {};
  }

  return send(url, _objectSpread({}, options, {
    method: 'POST',
    body: data
  }), done);
}
/**
 * Execute PUT request
 *
 * @param {String} url URI to request.
 * @param {Object} data Data to send with request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */


function put(url, data, options, done) {
  if (typeof options === 'function') {
    done = options;
    options = {};
  }

  return send(url, _objectSpread({}, options, {
    method: 'PUT',
    body: data
  }), done);
}

var _default = {
  del,
  get,
  patch,
  post,
  put
};
exports.default = _default;