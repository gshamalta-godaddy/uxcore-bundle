# `@ux/component-utilities`

This library is intended to help mirgate away from `@ux/component`. Most methods are available and others
are built as hooks for functional composition

## Table of Contents

* [Installation](#installation)
* [Usage](#usage)
  * [Available Hooks](#available-hooks)
    * [useBreakpoints](#useBreakpoints)
    * [useOnClickOutside](#useOnClickOutside)
    * [useEventListener](#useEventListener)
  * [Available Methods](#available-methods)
    * [id](#id)
    * [isBrowser](#isbrowser)
    * [isMobile](#ismobile)
    * [classNames](#classnames)
    * [offset](#offset)
    * [scrollIntoViewIfNeeded](#scrollIntoViewIfNeeded)
* [Testing](#testing)

## Installation

```bash
npm install @ux/component-utilities
```

## Usage

To use a method/hook from the package you have to import it like so:

```js
import { useBreakpoints } from '@ux/component-utilities'
```

## Available Hooks

### `useBreakpoints`

The hook is passed breakpoint string names as separate parameters.
The breakpoints put in are the breakpoints to re-render the component at when there's a change.
It gives the component the closest breakpoint it could be and handles the associated state.
You can also get the current break point and the viewport as it is returned from the hook

```js
import { useBreakpoints } from '@ux/component-utilities';
function MyComponent(props) {
  const { breakpoint, viewport } = useBreakpoints('mobile', 'tablet', 'desktop');
}
```

### `useOnClickOutside`

This hook allows use to add listeners to the document to listen for an outside click. Such as in clicking a dropdown and clicking outside the dropdown to trigger a side effect

```js
import { useOnClickOutside } from '@ux/component-utilities'
import { useRef } from 'React';

function MyComponent(props) {
  const ref = useRef();
  useOnClickOutside(ref, () => {
    // Perform action here
  });
  
  return (
    <div id="my-component" ref={ref}>
      {/* ...component content here... */}
    </div>
  );
}
```

### `useEventListener`

This hook allows you to add a memoized listener to the parent or any node that is passed though along with additional options to handle captuure, passive, and once.

```js
import { useEventListener } from '@ux/component-utilities'

function MyComponent(props) {
  useEventListener('mousemove', () => {
    /* some action here */
  }, { once: true } )
  
  return (
    <div id="my-component">
      {/* ...component content here... */}
    </div>
  );
}


```

## Available Methods

### `id`

> **PLEASE DO NOT USE** this method is no longer recomended for use and is marked for being deprecated in a future release

Generate a valid HTML id attribute to be used for elements. This method will
generate an `id` from the following three values in order:

* `id` property from `props`
* provided key parameter from `props`

```js
import { id } from '@ux/component-utilities'

function Button() {
  return (
    <button id={ id('some-id') }>
      Hello world
    </button>
  );
}
```

### `classNames`

> **NOTE** this method is being deprecated, also this method is not the same as the opensource [`classNames`](https://npmjs.com/package/classnames) which has its own README for details

The className method allows you to easily manage multiple and conditional
classNames to your React Component. It returns an array that can still be
manipulated afterwards if needed. Some of manipulations we do automatically are:

* Duplicate classNames are ignored.
* Undefined values are automatically removed.
* When an object is supplied only keys with the truthy value are added.

For example if you want to conditionally add classNames you can easily supply it
with an object:

```js
var classNames = classNames({
  'active': this.props.active,
  'form-inline': this.props.inline
});
```

In the example above, only the `active` class would only be added if props.active
is set to true. This is because when an object is supplied only keys with the
truthy value are added to the returned set. It can also merge multiple
classNames in to a single className string. If an className occurs multiple
times, it will be ignored so only a single occurrence is returned.

In the example below we pass in four values to the this.classNames method:

1. A falsy value `this.props.className`
2. A literal string, `'btn'`
3. An object with a single key `active` that has a truthy value
4. An Array of strings which includes `'btn'` a previously added value.

```js
import { classNames } from '@ux/component-utilities'

class Button extends Component {
  render() {
    var classNames = classNames(this.props.className, 'btn', {
      active: this.props.active
    }, ['foo', 'bar', 'btn']);

    return (
      <div className={classNames}>example</div>
    );
  }
}
```

Those four values are reduced into just four class names: btn active foo bar.
The resulting HTML will be:

```html
<div class="btn active foo bar">example</div>
```

In addition to adding classNames with an object it can also be used to remove
previously defined classNames. Please note that the order matters here:

```js
let x = classNames('foo bar baz', {
  bar: false
});

// x = 'foo baz'
```

### `isBrowser`

Check if we are running in a TRUE browser environment (i.e. **NOT** Node.js) .
This will only return true in REAL browser environments (i.e. not `jsdom`). The
navigator object will toString as `[object Navigator]` instead of
`[object Object]` if it was a leaked Node.js global.

``` js
if (isBrowser()) {
  // browser specific code
}
```

> **NOTE:** This will return true in PhantomJS environments and other headless
browsers since those are, in fact, REAL browsers in the strict sense.

### `isMobile`

Check if current breakpoint is mobile or phablet.
(Ideally should be used in conjuction with [`useBreakpoints`](#useBreakpoints) and [`breakpoints`](#breakpoints))

```js
if (isMobile(breakpoint)) {
  // mobile specific code
}
```

### `offset`

Return the offset of the component relative to the window origin.

```js
class Button extends Component {
  open (event) {
    const { left, top } offset(ref); // returns hash with left and top offset.
    // other code...
  }

  render() {
    return <div onClick={this.open.bind(this)}></div>;
  }
}
```

### `scrollIntoViewIfNeeded`

Scrolls the page to the specified reference if necessary.

```js
class Items extends Component {
  constructor(...args) {
    super(...args);

    this.itemRefs = [];
    this.state = {
      selected: 0,
      items: [0, 1, 2, 3, 4]
    };
  }

  componentDidMount() {
    const { selected } = this.state;
    scrollIntoViewIfNeeded(this.itemRefs[selected])
  }

  render() {
    const { items } = this.state;
    return <Fragment>
      { items.map((item, i) => {
          return <div
            onClick={ () => this.setState({ selected: i }) }
            key={ `item-${i}`}
            ref={ c => this.itemRefs[i] = c }>
              item {i}
            </div>
        }) }
    </Fragment>;
  }
}
```

### `breakpoints`

Breakpoints are the most important part of a mobile first experience.
Layouts often change on different breakpoints. Things need to be
added, removed or even re-organized.

To cater this need we added a `breakpoint` method to the component
which allows you to listen to breakpoint changes. When ever one of our
pre-defined breakpoints are triggered, it will update the state of the
component with:

```js
{
  viewport: {
    width: Number,
    height: Number
  },
  breakpoint: 'breakpoint name here'
}
```

This will allow you to easily do conditional layouts in your component by just
checking the `breakpoint` property in the state. Currently we support the
following breakpoints as defined by the design team:

* mobile
* phablet
* tablet
* desktop
* large

## Testing

```bash
npm test
```
