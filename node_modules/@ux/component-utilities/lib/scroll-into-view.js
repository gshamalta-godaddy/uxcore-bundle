"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = scrollIntoViewIfNeeded;

var _outOfViewport = _interopRequireDefault(require("./out-of-viewport"));

function isRef(obj) {
  return obj != null && typeof obj === 'object' && Object.prototype.hasOwnProperty.call(obj, 'current');
}
/**
  * Scroll the current element into the visible area of the browser window if not there.
  * If the element is already within the visible area of the browser window, then do not scroll.
  *
  * @param {Node|ReactElement} ref Reference to a DOM Node or React Element.
  * @throws Will throw an error if ref is not valid
  * @public
  */


function scrollIntoViewIfNeeded(ref) {
  if (!isRef(ref)) return;
  const {
    current
  } = ref;
  const outOf = (0, _outOfViewport.default)(current);
  if (!outOf) return; // WebKit & Blink have this native method.

  if (current.scrollIntoViewIfNeeded) {
    current.scrollIntoViewIfNeeded(false);
    return;
  } //
  // TODO (crobbins, jkeslin): do we still need this in this implementation?
  //
  // // If the menu itself is statically positioned, we need to take that into account
  // if (ref.offsetParent !== ref.parentNode) {
  //   top -= activeItem.parentNode.offsetTop;
  // }
  //
  // Remark (crobbins): MDN suggests checking if `typeof body.scrollTop === 'number'`
  // but based on empirical evidence that documentation is simply wrong. Other sources
  // around the Internetz suggest that when the value is 0 `document.body` should be used.
  // (see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)
  //


  let body = document.documentElement || document.body.parentNode;

  if (body.scrollTop === 0) {
    body = document.body;
  }

  body.scrollTop = body.scrollTop + outOf;
}