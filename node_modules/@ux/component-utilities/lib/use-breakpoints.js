"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useBreakpoints;

var _breakpoints = _interopRequireDefault(require("./breakpoints"));

var _diagnostics = _interopRequireDefault(require("diagnostics"));

var _react = require("react");

const currentWindow = typeof window === 'undefined' ? null : window;

if (currentWindow) {
  currentWindow.addEventListener('resize', () => {
    if (!_breakpoints.default.changed()) return;
    currentWindow.dispatchEvent(new CustomEvent('breakpoint:hook:changed', {
      detail: {
        breakpoint: _breakpoints.default.breakpoint
      }
    }));
  });
}
/**
 * @typedef {Object} Breakpoint
 * @prop {string} name The name of the breakpoint
 * @prop {number} width The minimum width of the breakpoint in pixels
 */

/**
 * @typedef {Object} Viewport
 * @prop {number} width The width of the viewport in pixels
 * @prop {number} height The height of the viewport in pixels
 */

/**
 * @typedef {Object} useBreakpointsState
 * @prop {Breakpoint} breakpoint The current breakpoint
 * @prop {Viewport} viewport The current viewport size
 */

/**
 * React hook to setup breakpoint handling with breakdancer
 *
 * @param  {...string} points List of breakpoint names to subscribe to
 * @returns {useBreakpointsState} State variables for current breakpoint and viewport
 */


function useBreakpoints() {
  for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
    points[_key] = arguments[_key];
  }

  const debug = (0, _diagnostics.default)('ux:use-breakpoints');
  const [breakpoint, setBreakpoint] = (0, _react.useState)(() => {
    /** @type {Breakpoint} */
    const currentBreakpoint = _breakpoints.default.breakpoint;
    return currentBreakpoint;
  });
  const [viewport, setViewport] = (0, _react.useState)(() => {
    /** @type {Viewport} */
    const currentViewport = _breakpoints.default.viewport();

    return currentViewport;
  });
  (0, _react.useEffect)(() => {
    const _resize = _ref => {
      let {
        detail: newBreakpoint
      } = _ref;
      if (!points || !points.length) return; //
      // Find the nearest registered point by minimal distance from the actual width.
      //

      if (!points.includes(newBreakpoint)) {
        const distances = points.map(point => Math.abs(_breakpoints.default.compare(point, 'width')));
        newBreakpoint = points[distances.indexOf(Math.min(...distances))];
      } //
      // Check if the breakpoint is actually different Breakpoint might have changed based on nearest algorithm.
      //


      if (breakpoint === newBreakpoint) return;
      debug('updating state as breakpoint changed to %s', newBreakpoint);
      setViewport(_breakpoints.default.viewport());
      setBreakpoint(newBreakpoint);
    };

    _resize({
      detail: _breakpoints.default.currently()
    }); // @ts-ignore


    if (currentWindow) currentWindow.addEventListener('breakpoint:hook:changed', _resize);
    return () => {
      // @ts-ignore
      if (currentWindow) currentWindow.removeEventListener('breakpoint:hook:changed', _resize);
    };
  }, [breakpoint, debug, points]);
  return {
    breakpoint,
    viewport
  };
}