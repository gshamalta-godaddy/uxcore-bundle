/**
  * Helper function to create and manage an array of classNames.
  *
  * @returns {String|Undefined} Concatenated result of classNames.
  * @public
  */
export default function classNames(...names) {
  const result = names
    .filter(Boolean)
    .reduce((memo, className) => {
      if (typeof className === 'string' && ~className.indexOf(' ')) {
        className = className.split(' ');
      }

      if (Array.isArray(className)) {
        Array.prototype.push.apply(memo, classNames(...className).split(' '));
      } else if (typeof className === 'object') {
        Object.keys(className).forEach(function each(key) {
        //
        // In object mode we want to optionally enable or disable classNames
        // based on boolean values for the keys. We're not going to be too
        // strict on true and false as we want things like `undefined` and
        // `null` to also trigger removal.
        //
          if (className[key]) {
            memo.push(key);
          } else if (~memo.indexOf(key)) {
            memo.splice(memo.indexOf(key), 1);
          }
        });
      } else {
        memo.push(className);
      }

      return memo;
    }, [])
    .filter(function filter(item, i, all) {
      return Boolean(item) && all.indexOf(item) === i;
    })
    .join(' ');

  //
  // If we return an empty string and directly pass it in to the className
  // property of a React component we will add an empty attribute to the
  // element. Returning `undefined` ensures that no empty property is added.
  //
  // The undefined value is also still accepted as value for the `classNames`
  // method so the resulting className can still be manipulated afterwards.
  //

  // eslint-disable-next-line no-undefined
  return result ? result : undefined;
}
