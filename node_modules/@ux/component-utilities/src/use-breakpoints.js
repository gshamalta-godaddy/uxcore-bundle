import breakpoints from './breakpoints';
import diagnostics from 'diagnostics';
import { useEffect, useState } from 'react';

const currentWindow = typeof window === 'undefined' ? null : window;
if (currentWindow) {
  currentWindow.addEventListener('resize', () => {
    if (!breakpoints.changed()) return;
    currentWindow.dispatchEvent(new CustomEvent('breakpoint:hook:changed', { detail: {
      breakpoint: breakpoints.breakpoint } }));
  });
}
/**
 * @typedef {Object} Breakpoint
 * @prop {string} name The name of the breakpoint
 * @prop {number} width The minimum width of the breakpoint in pixels
 */
/**
 * @typedef {Object} Viewport
 * @prop {number} width The width of the viewport in pixels
 * @prop {number} height The height of the viewport in pixels
 */
/**
 * @typedef {Object} useBreakpointsState
 * @prop {Breakpoint} breakpoint The current breakpoint
 * @prop {Viewport} viewport The current viewport size
 */

/**
 * React hook to setup breakpoint handling with breakdancer
 *
 * @param  {...string} points List of breakpoint names to subscribe to
 * @returns {useBreakpointsState} State variables for current breakpoint and viewport
 */
export default function useBreakpoints(...points) {
  const debug = diagnostics('ux:use-breakpoints');
  const [breakpoint, setBreakpoint] = useState(() => {
    /** @type {Breakpoint} */
    const currentBreakpoint = breakpoints.breakpoint;
    return currentBreakpoint;
  });
  const [viewport, setViewport] = useState(() => {
    /** @type {Viewport} */
    const currentViewport = breakpoints.viewport();
    return currentViewport;
  });

  useEffect(() => {
    const _resize = ({ detail: newBreakpoint }) => {
      if (!points || !points.length) return;
      //
      // Find the nearest registered point by minimal distance from the actual width.
      //
      if (!points.includes(newBreakpoint)) {
        const distances = points.map(point => Math.abs(breakpoints.compare(point, 'width')));
        newBreakpoint = points[distances.indexOf(Math.min(...distances))];
      }

      //
      // Check if the breakpoint is actually different Breakpoint might have changed based on nearest algorithm.
      //
      if (breakpoint === newBreakpoint) return;

      debug('updating state as breakpoint changed to %s', newBreakpoint);
      setViewport(breakpoints.viewport());
      setBreakpoint(newBreakpoint);
    };

    _resize({ detail: breakpoints.currently() });
    // @ts-ignore
    if (currentWindow) currentWindow.addEventListener('breakpoint:hook:changed', _resize);

    return () => {
      // @ts-ignore
      if (currentWindow) currentWindow.removeEventListener('breakpoint:hook:changed', _resize);
    };
  }, [breakpoint, debug, points]);

  return {
    breakpoint,
    viewport
  };
}
