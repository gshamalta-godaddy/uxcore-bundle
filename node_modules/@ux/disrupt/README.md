# @ux/disrupt

This component disrupts the user from the normal application flow and is expected to shift focus to a new task.

## Installation

```sh
npm i @ux/disrupt
```

## Usage

```js
import Disrupt from '@ux/disrupt';

export default function (props) {
  const [show, setShow] = React.useState(true);

  return <section>
    { show && <Disrupt onClose={ (ev) => setShow(false) }>
      Here is a very important message
    </Disrupt> }
  </section>
}
```

The `<Disrupt/>` component will attach itself to the parent (eg. `<section/>`) and add an attribute `data-inert` to help with some required styles.

## Props
| Prop | Type | Description |
| ---- | ---- | ----------- |
| `children` | `Node` | Adds children to the content container. |
| `onClose` | `Function` | Fires when the user is attempting to escape from the disruption. The argument passed is the event that was triggered. |
| `onEventBehind` | `Function` | Fires when an event occurs _behind_ the disruption. Read more on the [responsibilities](#responsibilities). |
| `portalElem`| `DOM element` | The element to attach the component. This is not required unless you are creating a true "modal" experience where this should be set to `document.body`. |
| `strategy | `absolute` or `fixed` | Determines how to attach the backdrop to the `portalElem` |
| `stretch` | `Boolean` | Stretches the width of the container. |

## Responsibilities
While the component provides an overlay to the parent container it is not impossible for events to occur behind it. We set the parent container to `pointer-events: none` and the component to reset as `pointer-events: initial` which should stop all pointer events behind. However, there is no similar method to stop focus events. There are a few approaches you can execute to help stop events from firing behind the component.

### Conditional `tabIndex`

You can set the `tabIndex` to all interactive elements while the component is active to `-1` so they are removed from the tab order.

```jsx
export default function() {
  const [show, setShow] = React.useState(false);

  return (
    <>
      <section>
        <p>Mustache fingerstache stumptown, <a href="#" tabIndex={ !show ? 0 : -1 }>listicle messenger bag schlitz</a> chillwave.</p>
        { show && <Disrupt/> }
      </section>
      <button onClick={ () => setShow(!show) }>Toggle</button>
    </>
  )
}
```

### `<fieldset disabled/>`

Enclosing form elements within a `<fieldset/>` and then setting `disabled` on that element will cause all form descendants to become non-interactive

```jsx
export default function Form() {
  const [show, setShow] = React.useState(false);

  return (
   <fieldset disabled={ show }>
      <label>Username</label>
      <input type='text'/>
      <label>Password</label>
      <input type='password'/>
      <br/>
      <button onClick={ () => setShow(true) }>Submit</button>
      { show && <Disrupt/> }
    </fieldset>
  )
}
```

### Handing events

You can use the `onEventBehind` callback to either debug or handle events that occur behind the component. Be careful not to trap the user's focus when using this. Remember they can tab backwards and forwards.

