"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactFocusLock = _interopRequireDefault(require("react-focus-lock"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions */
// The keyboard listener is added to the document and while this is presentational, the contents are not.
const UX_DISRUPT_CLASSNAME = 'ux-disrupt';
const UX_DISRUPT_FOCUSLOCK_DEFAULTS = {
  autoFocus: true,
  disabled: false,
  returnFocus: true
};
const UX_DISRUPT_SHADOWROOT_MSG = 'Warning: <Disrupt portalElem={ ShadowRoot }/> is not supported; use a DOM Element instead.';
/**
 * Toggles the data-inert attribute, for managing multiple possible disruptions
 *
 * @param {Element} parent - The parent of the component
 * @param {Boolean} inert - Determines if the inert attribute should be added or removed
 */

function manageInert(parent, inert) {
  const amount = Number(inert) * 2 - 1;
  const value = Number(parent.getAttribute('data-inert')) + amount;

  if (value) {
    parent.setAttribute('data-inert', value);
  } else {
    parent.removeAttribute('data-inert');
  }
}
/**
 * Create a <Disrupt/> component
 *
 * @param {Object} props - Properties to inform the component
 * @param {Elements} [props.children] - Given children for the content container
 * @param {Boolean|Object} [props.focusLock] - Can either toggle focus lock or configure it
 * @param {Function} [props.onClose] - Callback which fires when the user attempts to leave
 * @param {Function} [prop.onEventBehind] - Callback which fires when an event occurs behind the component
 * @param {Element} [prop.portalElem] - The element to attach the component
 * @param {String} [prop.strategy] - The method that the backdrop is attached
 * @param {Boolean} [props.stretch] - Occupy the full width of the container
 * @returns {Component} - The Disrupt component
 */


function Disrupt(props) {
  const {
    children,
    focusLock = false,
    onClose,
    onEventBehind,
    portalElem,
    strategy,
    stretch
  } = props;
  const style = {
    position: strategy || 'absolute'
  };
  const componentRef = (0, _react.useRef)(null);
  let focusLockProps = {
    disabled: true
  };

  if (focusLock) {
    focusLockProps = typeof focusLock === 'boolean' ? UX_DISRUPT_FOCUSLOCK_DEFAULTS : focusLock;
  }

  (0, _react.useEffect)(function effect() {
    // Determine the element where the component is attached
    const parent = portalElem || componentRef.current.parentElement; // Cannot add functionality when mounted to shadow root

    if (parent instanceof window.ShadowRoot) {
      process.env.NODE_ENV !== 'production' && console.warn(UX_DISRUPT_SHADOWROOT_MSG);
      return;
    } // Function for catching events that occur behind the disruption


    function eventBehind(ev) {
      const insideParent = parent.contains(ev.target);
      const insideComponent = componentRef.current.contains(ev.target);
      if (insideParent && !insideComponent) onEventBehind(ev);
    } // Set a data-attribute on the parent that _shouldn't_ be clobbered by re-renders


    manageInert(parent, true); // Listen to all the things

    typeof onEventBehind === 'function' && parent.addEventListener('click', eventBehind);
    typeof onEventBehind === 'function' && parent.addEventListener('focusin', eventBehind);
    return function teardown() {
      if (parent instanceof window.ShadowRoot) return; // Teardown

      manageInert(parent, false);
      parent.removeEventListener('click', eventBehind);
      parent.removeEventListener('focusin', eventBehind);
    };
  }, [portalElem, onEventBehind, onClose]);
  const classNames = [`${UX_DISRUPT_CLASSNAME}-content`];

  if (stretch) {
    classNames.push(`${UX_DISRUPT_CLASSNAME}--stretch`);
  }
  /**
   * handleOutsideEvent - only fires the onClose event when the click occurs on backdrop
   * @param {React.SyntheticEvent} ev - onMouseDown event
   */


  const handleOutsideEvent = (0, _react.useCallback)(function handleOutsideEvent(ev) {
    // Selecting text will incorrectly fire cause this to fire, check if user is selecting text
    const selection = typeof window.getSelection === 'function' && window.getSelection().toString();

    if (ev.target === ev.currentTarget && ev.target === componentRef.current && !selection) {
      typeof onClose === 'function' && onClose(ev);
    }
  }, [onClose]);
  /**
   * handleKeyDown - only fires the onClose event when escape key is pressed on backdrop
   * @param {React.SyntheticEvent} ev - onKeyDown event
   */

  const handleKeyDown = (0, _react.useCallback)(function onKeyDown(ev) {
    if (ev.key !== 'Escape') return;
    ev.stopPropagation();
    typeof onClose === 'function' && onClose(ev);
  }, [onClose]);

  const component = /*#__PURE__*/_react.default.createElement("div", {
    className: `${UX_DISRUPT_CLASSNAME}-backdrop`,
    ref: componentRef,
    onClickCapture: handleOutsideEvent,
    onKeyDown: handleKeyDown,
    style: style
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: classNames.join(' ')
  }, /*#__PURE__*/_react.default.createElement(_reactFocusLock.default, focusLockProps, /*#__PURE__*/_react.default.createElement("div", {
    tabIndex: -1
  }, children))));

  return portalElem ? /*#__PURE__*/_reactDom.default.createPortal(component, portalElem) : component;
}

Disrupt.propTypes = {
  /** Children to render within */
  children: _propTypes.default.node,

  /** Defaults to false. If `true`, enables focus lock with default options. If object, passes props directly to react-focus-lock */
  focusLock: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.object]),

  /** Callback that fires when the user attempts to leave the component */
  onClose: _propTypes.default.func,

  /** Callback that fires when an event occurs behind the component */
  onEventBehind: _propTypes.default.func,

  /** Element to attach the component to, use document.body for "modal" behavior */
  portalElem: _propTypes.default.object,

  /** Method to attach the backdrop */
  strategy: _propTypes.default.oneOf(['absolute', 'fixed']),

  /** Stretches the width of the container */
  stretch: _propTypes.default.bool
};
var _default = Disrupt;
exports.default = _default;