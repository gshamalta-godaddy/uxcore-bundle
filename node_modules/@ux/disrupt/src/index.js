/* eslint-disable jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions */
// The keyboard listener is added to the document and while this is presentational, the contents are not.
import React, { useRef, useEffect, useCallback } from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';
import FocusLock from 'react-focus-lock';

const UX_DISRUPT_CLASSNAME = 'ux-disrupt';
const UX_DISRUPT_FOCUSLOCK_DEFAULTS = {
  autoFocus: true,
  disabled: false,
  returnFocus: true
};
const UX_DISRUPT_SHADOWROOT_MSG = 'Warning: <Disrupt portalElem={ ShadowRoot }/> is not supported; use a DOM Element instead.';

/**
 * Toggles the data-inert attribute, for managing multiple possible disruptions
 *
 * @param {Element} parent - The parent of the component
 * @param {Boolean} inert - Determines if the inert attribute should be added or removed
 */
function manageInert(parent, inert) {
  const amount = (Number(inert) * 2) - 1;
  const value = Number(parent.getAttribute('data-inert')) + amount;
  if (value) {
    parent.setAttribute('data-inert', value);
  } else {
    parent.removeAttribute('data-inert');
  }
}

/**
 * Create a <Disrupt/> component
 *
 * @param {Object} props - Properties to inform the component
 * @param {Elements} [props.children] - Given children for the content container
 * @param {Boolean|Object} [props.focusLock] - Can either toggle focus lock or configure it
 * @param {Function} [props.onClose] - Callback which fires when the user attempts to leave
 * @param {Function} [prop.onEventBehind] - Callback which fires when an event occurs behind the component
 * @param {Element} [prop.portalElem] - The element to attach the component
 * @param {String} [prop.strategy] - The method that the backdrop is attached
 * @param {Boolean} [props.stretch] - Occupy the full width of the container
 * @returns {Component} - The Disrupt component
 */
function Disrupt(props) {
  const {
    children,
    focusLock = false,
    onClose,
    onEventBehind,
    portalElem,
    strategy,
    stretch
  } = props;

  const style = { position: strategy || 'absolute' };
  const componentRef = useRef(null);

  let focusLockProps = { disabled: true };
  if (focusLock) {
    focusLockProps = typeof focusLock === 'boolean'
      ? UX_DISRUPT_FOCUSLOCK_DEFAULTS
      : focusLock;
  }

  useEffect(function effect() {
    // Determine the element where the component is attached
    const parent = portalElem || componentRef.current.parentElement;

    // Cannot add functionality when mounted to shadow root
    if (parent instanceof window.ShadowRoot) {
      process.env.NODE_ENV !== 'production' && console.warn(UX_DISRUPT_SHADOWROOT_MSG);
      return;
    }

    // Function for catching events that occur behind the disruption
    function eventBehind(ev) {
      const insideParent = parent.contains(ev.target);
      const insideComponent = componentRef.current.contains(ev.target);
      if (insideParent && !insideComponent) onEventBehind(ev);
    }

    // Set a data-attribute on the parent that _shouldn't_ be clobbered by re-renders
    manageInert(parent, true);

    // Listen to all the things
    typeof onEventBehind === 'function' && parent.addEventListener('click', eventBehind);
    typeof onEventBehind === 'function' && parent.addEventListener('focusin', eventBehind);
    return function teardown() {
      if (parent instanceof window.ShadowRoot) return;

      // Teardown
      manageInert(parent, false);
      parent.removeEventListener('click', eventBehind);
      parent.removeEventListener('focusin', eventBehind);
    };
  }, [portalElem, onEventBehind, onClose]);

  const classNames = [`${UX_DISRUPT_CLASSNAME}-content`];

  if (stretch) {
    classNames.push(`${UX_DISRUPT_CLASSNAME}--stretch`);
  }

  /**
   * handleOutsideEvent - only fires the onClose event when the click occurs on backdrop
   * @param {React.SyntheticEvent} ev - onMouseDown event
   */
  const handleOutsideEvent = useCallback(function handleOutsideEvent(ev) {
    // Selecting text will incorrectly fire cause this to fire, check if user is selecting text
    const selection = typeof window.getSelection === 'function' && window.getSelection().toString();
    if (ev.target === ev.currentTarget && ev.target === componentRef.current && !selection) {
      typeof onClose === 'function' && onClose(ev);
    }
  }, [onClose]);

  /**
   * handleKeyDown - only fires the onClose event when escape key is pressed on backdrop
   * @param {React.SyntheticEvent} ev - onKeyDown event
   */
  const handleKeyDown = useCallback(function onKeyDown(ev) {
    if (ev.key !== 'Escape') return;
    ev.stopPropagation();
    typeof onClose === 'function' && onClose(ev);
  }, [onClose]);

  const component = (
    <div
      className={ `${UX_DISRUPT_CLASSNAME}-backdrop` }
      ref={ componentRef }
      onClickCapture={ handleOutsideEvent }
      onKeyDown={ handleKeyDown }
      style={ style }>
      <div className={ classNames.join(' ') }>
        <FocusLock { ...focusLockProps }>
          <div tabIndex={ -1 }>
            { children }
          </div>
        </FocusLock>
      </div>
    </div>
  );

  return portalElem ? ReactDOM.createPortal(component, portalElem) : component;
}

Disrupt.propTypes = {
  /** Children to render within */
  children: PropTypes.node,
  /** Defaults to false. If `true`, enables focus lock with default options. If object, passes props directly to react-focus-lock */
  focusLock: PropTypes.oneOfType([
    PropTypes.bool,
    PropTypes.object
  ]),
  /** Callback that fires when the user attempts to leave the component */
  onClose: PropTypes.func,
  /** Callback that fires when an event occurs behind the component */
  onEventBehind: PropTypes.func,
  /** Element to attach the component to, use document.body for "modal" behavior */
  portalElem: PropTypes.object,
  /** Method to attach the backdrop */
  strategy: PropTypes.oneOf(['absolute', 'fixed']),
  /** Stretches the width of the container */
  stretch: PropTypes.bool
};

export default Disrupt;
