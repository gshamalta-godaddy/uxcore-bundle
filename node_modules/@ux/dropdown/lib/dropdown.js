"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.types = exports.default = exports.BasePropTypes = exports.BaseDefaultProps = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _toggler = require("toggler");

var _button = _interopRequireDefault(require("@ux/button"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

//
// Allowed dropdown types.
//
const types = Object.values(_button.default.designs).concat('button', 'select', 'multiselect', 'tripledot', 'custom');
/**
 * Display a Dropdown that works standalone button, as select or multiselect.
 *
 * @class Dropdown
 * @public
 */

exports.types = types;

class Base extends _react.Component {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    super(props, ...args);
    this.toggle = (0, _toggler.toggle)(this, 'open', () => {
      const isOpen = this.state.open;

      if (typeof this.props.onToggle === 'function') {
        this.props.onToggle(isOpen);
      }

      if (typeof this.toggleBackground === 'function') {
        this.toggleBackground(isOpen);
      }
    });
    const selectedItems = Array.isArray(props.selected) || typeof props.selected === 'number' ? props.selected : props.defaultSelected;
    this.state = _objectSpread(_objectSpread({}, this.state), {}, {
      error: false,
      open: this.props.open || false,
      selected: [].concat(selectedItems),
      keyboardSelectionIndex: -1
    });
    this.calledWarn = false;

    this._warn();
  }
  /**
   *  console warning about missing id for accessibility purposes
   */


  _warn() {
    // eslint-disable-next-line no-process-env
    if (process.env.NODE_ENV === 'production') return;

    if (!this.props.id && !this.calledWarn) {
      this.calledWarn = true;
      console.warn('Warning: <Dropdown> requires an id prop to be fully accessible.');
      /* eslint-disable-line */
    }
  }
  /**
   * Returns all children that are not of a specific type. This will be
   * overridden by the separate web and native specitic implementations of
   * the dropdown.
   *
   * @param {React.Element[]} children - React elements.
   * @throws {Error} error if this method is not overridden
   * @private
   */


  items(children) {
    throw new Error('Must be implemented by derived class.');
  }
  /**
   * Returns true if the current dropdown is a multiselect dropdown
   *
   * @returns {Boolean} true if dropdown is multiselect
   * @public
   */


  isMultiSelect() {
    return this.props.type === 'multiselect';
  }
  /**
   * Sets the document location if the given item has a valid href
   *
   * @param {Object} itemProps Fully formed props from the selected item
   * @private
   */


  redirectToHrefIfAvailable(itemProps) {
    const {
      href
    } = itemProps;

    if (href && typeof href === 'string' && href !== '#') {
      document.location = href;
    }
  }
  /**
   * Select the item for a given index and trigger onChange from props if provided.
   * In the case of multiselect, it will also unselect.
   *
   * @param {Number} itemIndex Zero-based index of the item (among DropdownItems only).
   * @param {Event} event Event passed in from the source of the select
   * @param {function} callback Callback to fire after state has been updated
   * @public
   */


  selectIndex(itemIndex, event) {
    const items = this.items(_react.default.Children.toArray(this.props.children));
    const item = items[itemIndex];

    if (!item) {
      return;
    }

    const listener = item.props.type === 'multiselect' ? 'onChange' : 'onClick';
    this.selectItem(_objectSpread(_objectSpread({}, item.props), {}, {
      itemIndex
    }), event, item.props[listener]);
  }
  /**
   * Select the item with the given `itemProps.itemIndex` and trigger onChange
   * from props if provided. Finally also trigger the **item's** onChange or
   * onClick handler (represented by `callback`). In the case of multiselect,
   * it will also unselect.
   *
   * @param {Object} itemProps Fully formed props from the selected item
   * @param {Event} event Event passed in from the source of the select
   * @param {function} callback Callback to fire after state has been updated
   * @public
   */


  selectItem(itemProps, event, callback) {
    this.redirectToHrefIfAvailable(itemProps);
    let {
      selected
    } = this.state;
    const {
      itemIndex
    } = itemProps;

    if (this.isMultiSelect()) {
      const index = selected.indexOf(itemIndex);

      if (index > -1) {
        selected.splice(index, 1);
      } else {
        selected.push(itemIndex);
      }
    } else {
      selected = [itemIndex];
    }

    const nextState = {
      selected,
      keyboardSelectionIndex: itemIndex
    };
    let nextSelected = selected;

    if (!this.isMultiSelect()) {
      this.hide();
      nextSelected = nextSelected[0];
    }

    this.setState(nextState, () => {
      this.broadcast(_objectSpread(_objectSpread({}, itemProps), {}, {
        selected: nextSelected
      }), event, callback);
    });
  }
  /**
   * broadcast item selection to the dropdown onChange prop as well as
   * either the onClick or onChange callback of dropdown items if defined
   *
   * @param {Object} options selected item properties
   * @param {event} event the react proxy event that originates at the doprdown item
   * @param {function} callback callback function to invoke in addition to dropdown onChange
   * @private
   */


  broadcast(options, event, callback) {
    if (!event) {
      return;
    }

    if (this.props.onChange) {
      this.props.onChange(options, event);
    }

    callback && callback(options, event);
  }
  /**
   * On change of incoming `open` prop update internal state using `toggler`
   *
   * @param {Object} prevProps - Object of Previous Props
   * @private
   */


  componentDidUpdate(prevProps) {
    if (typeof this.props.open !== 'undefined' && prevProps.open !== this.props.open) {
      this.toggle();
    }

    if (this.props.selected !== prevProps.selected) {
      this.setState({
        selected: [].concat(this.props.selected),
        keyboardSelectionIndex: -1
      });
    }
  }
  /**
   * Event handler to show and hide the dropdown.
   *
   * @returns {Function} Event handler
   * @public
   */


  get show() {
    return this.props.show || (event => {
      this.toggle(event);
    });
  }
  /**
   * Event handler to hide the dropdown after clicking on another dropdown,
   * the state check is done to prevent state
   * changes when the dropdown is already hidden. This method is used by the
   * document click listeners.
   *
   * @returns {Function} Event handler
   * @public
   */


  get hide() {
    return this.props.hide || (event => {
      if (!this.state.open) {
        return;
      }

      this.toggle(event);
    });
  }
  /**
   * Return selected indexes of dropdown items.
   *
   * @returns {Array} Selected item indexes.
   * @private
   */


  get selected() {
    return this.state.selected;
  }
  /**
   * When space or enter is pressed select the DropdownItem. Incase of multiselect select the Dropdown item on space.
   * When escape is pressed close the dropdown.
   * When a Arrowup or Arrowdown is pressed move the pointer accordingly.
   * Incase of Button, on enter or space it opens the link.
   * @param {object} e Event object sent from the browser
   * @private
   */


  keyDown(e) {
    const key = e.key;

    switch (key) {
      case 'Escape':
        this.hide();
        break;

      case 'ArrowUp':
      case 'ArrowDown':
        this.onArrowUpDown(e);
        break;

      case 'Space': // Space bar

      case 'Enter':
        {
          // Enter
          if (this.state.open) {
            const {
              keyboardSelectionIndex
            } = this.state;
            this.selectIndex(keyboardSelectionIndex, e);
          }

          break;
        }

      default:
        break;
    }
  }
  /**
   * On ArrowUp or ArrowDown sets the index of the dropdown item.
   * @param {KeyboardEvent} e Event object sent from the browser
   * @private
   */


  onArrowUpDown(e) {
    if (e.key === 'ArrowDown' && !this.state.open) {
      this.show();
    }

    let {
      keyboardSelectionIndex
    } = this.state;
    const delta = e.key === 'ArrowDown' ? 1 : -1;

    if (keyboardSelectionIndex === -1 && e.key === 'ArrowUp') {
      keyboardSelectionIndex = 0;
    }

    const items = this.items(_react.default.Children.toArray(this.props.children));
    const dataLength = items.length;

    if (items.filter(item => !item.props.disabled).length > 0) {
      // Using bounds just outside the acceptable range. This is for logic safety only.
      for (let i = keyboardSelectionIndex + delta; i < dataLength + 1 && i > -2; i += delta) {
        // Reset the index if it's beyond the bounds of the list, allowing looping.
        i = (i + dataLength) % dataLength;

        if (!items[i].props.disabled) {
          this.setState({
            keyboardSelectionIndex: i
          });
          break;
        }
      }
    }

    e.preventDefault();
  }
  /**
   * Extract the children (text) of the selected DropdownItem.
   *
   * @param {Array} childs Current children of this instance.
   * @returns {Array} Join of selected items.
   * @private
   */


  getSelectedItem(childs) {
    let items = this.items(childs) || [];
    items = items.filter((item, i) => this.selected.includes(i));

    if (!items.length) {
      return null;
    }

    return items.reduce((memo, item, i) => {
      if (i) memo.push(', ');
      memo.push(item.props.children);
      return memo;
    }, []);
  }

}
/**
 * Default to button dropdown.
 *
 * @enum {Object} defaultProps
 * @public
 */


exports.default = Base;
const BaseDefaultProps = Base.defaultProps = {
  defaultSelected: [],
  disabled: false,
  onChange: () => {},
  onToggle: () => {}
};
/**
 * Define properties and validate the type of children that are passed
 * to the Dropdown.
 *
 * @enum {Object} propTypes
 * @public
 */

exports.BaseDefaultProps = BaseDefaultProps;
const BasePropTypes = Base.propTypes = {
  name: _propTypes.default.string,
  children: _propTypes.default.node,
  open: _propTypes.default.bool,
  show: _propTypes.default.func,
  hide: _propTypes.default.func,
  required: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.bool]),
  onChange: _propTypes.default.func,
  onToggle: _propTypes.default.func,
  type: _propTypes.default.oneOf(types),
  content: _propTypes.default.oneOfType([_propTypes.default.element, _propTypes.default.string]),
  disabled: _propTypes.default.bool,
  placeholder: _propTypes.default.node,
  label: _propTypes.default.node,
  toggleIcon: _propTypes.default.oneOf(['clock', 'dropdown']),
  selected: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.array]),
  defaultSelected: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.array]),
  id: _propTypes.default.string,
  contextmenu: _propTypes.default.bool
};
exports.BasePropTypes = BasePropTypes;