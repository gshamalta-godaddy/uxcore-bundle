"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DropdownControl", {
  enumerable: true,
  get: function () {
    return _dropdownControl.default;
  }
});
Object.defineProperty(exports, "DropdownDivider", {
  enumerable: true,
  get: function () {
    return _dropdownDivider.default;
  }
});
Object.defineProperty(exports, "DropdownHeader", {
  enumerable: true,
  get: function () {
    return _dropdownHeader.default;
  }
});
Object.defineProperty(exports, "DropdownItem", {
  enumerable: true,
  get: function () {
    return _dropdownItem.default;
  }
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _reactComponentValidator = _interopRequireDefault(require("react-component-validator"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _dropdown = _interopRequireWildcard(require("./dropdown"));

var _classNames = _interopRequireDefault(require("@ux/component-utilities/lib/classNames"));

var _useClickOutsideHoc = _interopRequireDefault(require("@ux/component-utilities/lib/use-click-outside-hoc"));

var _scrollIntoView = _interopRequireDefault(require("@ux/component-utilities/lib/scroll-into-view"));

var _dropdownControl = _interopRequireDefault(require("./dropdown-control"));

var _dropdownDivider = _interopRequireDefault(require("./dropdown-divider"));

var _dropdownHeader = _interopRequireDefault(require("./dropdown-header"));

var _dropdownMenu = _interopRequireWildcard(require("./dropdown-menu"));

var _dropdownItem = _interopRequireDefault(require("./dropdown-item"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * Track of the current selected value with a hidden input element. Allowing
 * simple POST requests of forms.
 *
 * @class DropdownValue
 * @private
 */
class DropdownValue extends _react.Component {
  render() {
    const allowedTypes = ['select', 'tripledot', 'custom'];

    if (!allowedTypes.includes(this.props.type)) {
      return null;
    }

    return /*#__PURE__*/_react.default.createElement("input", (0, _extends2.default)({}, this.props, {
      type: "hidden",
      readOnly: true
    }));
  }

}
/**
 * PropType validation
 *
 * @enum {Object} propTypes
 * @public
 */


DropdownValue.propTypes = {
  /** Type of dropdown */
  type: _propTypes.default.oneOf(_dropdown.types)
};
/**
 * Display a Dropdown that works standalone button, as select or multiselect.
 *
 * @displayName Dropdown (Web)
 * @class Dropdown
 * @extends React.Component
 * @public
 */

class DropdownComponent extends _dropdown.default {
  constructor() {
    super(...arguments);
    this.hideHandle = null;
    this.selectItem = this.selectItem.bind(this);
    this.toggleBackground = this.toggleBackground.bind(this);
    this.element = /*#__PURE__*/_react.default.createRef();
    this.dropdownRef = /*#__PURE__*/_react.default.createRef();
    this.ariaLabels = _objectSpread(_objectSpread({}, DropdownComponent.defaultProps.ariaLabels), this.props.ariaLabels);
    this.focusDropdown = this.focusDropdown.bind(this);
  }
  /**
   * Added this to force focus to the dropdown when the label is clicked.
   *
   * @private
   */


  focusDropdown() {
    // Explicitly focus the text input using the raw DOM API
    // Note: we're accessing "current" to get the DOM node
    this.dropdownRef.current.focus();
  }
  /**
   * Remove the attached click event listener.
   *
   * @private
   */


  componentWillUnmount() {
    document.removeEventListener('click', this.hideHandle || this.hide);
    this.hideHandle = null;
  }
  /**
   * Scroll to the active item.
   *
   * @param {object} prevProps - Previous props before update
   * @param {object} prevState - Previous state before update
   * @private
   */


  componentDidUpdate(prevProps, prevState) {
    super.componentDidUpdate(prevProps);
    const activeItem = this.element.current && this.element.current.querySelector('.active');
    const {
      open
    } = this.state;

    if (open && open !== prevState.open) {
      const _this$getElementBound = this.getElementBounds(),
            bounds = (0, _extends2.default)({}, _this$getElementBound);

      let newState = this.getHorizontalRender(bounds);
      newState = _objectSpread(_objectSpread({}, newState), this.getVerticalRender(bounds));

      if (Object.keys(newState).length > 0) {
        this.setState(newState);
      }
    }

    if (open && activeItem) {
      (0, _scrollIntoView.default)(activeItem);
    }
  }
  /**
   * Fetches all element bounds to necessary calculations of display
   * @private
   * @returns {object} element bounds
   */


  getElementBounds() {
    // Viewport Bounds
    const viewportBounds = {
      x: window.pageXOffset,
      y: window.pageYOffset,
      width: window.innerWidth,
      height: window.innerHeight
    }; // Main Dropdown Element

    const elementBounds = this.element.current && this.element.current.getBoundingClientRect(); // Dropdown Menu Element

    const menuBounds = this.menuElement && this.menuElement.wrapper && this.menuElement.wrapper.getBoundingClientRect(); // Label Element (if one exists)

    const labelBounds = this.componentLabel && this.componentLabel.getBoundingClientRect(); // Menu Item Element

    const menuItemRef = this.menuElement && this.menuElement.dropdownItem && this.menuElement.dropdownItem.getRef && this.menuElement.dropdownItem.getRef();
    const menuItemBounds = menuItemRef && menuItemRef.getBoundingClientRect(); // Get Dropdown Item height

    const itemHeight = menuItemBounds && menuItemBounds.height || 45;
    return {
      viewportBounds,
      elementBounds,
      menuBounds,
      labelBounds,
      itemHeight
    };
  }
  /**
   * Compute vertical spacing for menu and determine whether to show above or below the dropdown control.
   *
   * @param {object} bounds - Object containing element bounds calculated in getElementBounds()
   * @returns {obbject} Temporary updated state object
   * @private
   */


  getVerticalRender(bounds) {
    // Temporary object to prevent multiple state updates
    const newState = {};
    const {
      viewportBounds,
      elementBounds,
      menuBounds,
      labelBounds,
      itemHeight
    } = bounds;
    const hasLabel = labelBounds && labelBounds.height > 0;

    if (this.state.hasLabel !== hasLabel) {
      newState.hasLabel = hasLabel;
    }

    if (elementBounds) {
      // Determine to show the menu above or below
      const menuBottomBound = elementBounds.top + elementBounds.height + menuBounds.height - itemHeight / 2;
      const overflowBelow = viewportBounds.height < menuBottomBound;
      const spaceAbove = elementBounds.top - menuBounds.height > 0;
      const showUp = overflowBelow && spaceAbove;

      if (this.state.showUp !== showUp) {
        newState.showUp = showUp;
      }
    }

    return newState;
  }
  /**
   * Compute horizontal spacing for menu and determine whether to show aligned left or right to the dropdown control.
   *
   * @param {object} bounds - Object containing menu bounds calculated in getElementBounds()
   * @returns {object} Temporary updated state object
   * @private
   */


  getHorizontalRender(bounds) {
    const newState = {};

    if (_dropdownMenu.autoAlignments[this.props.menuAlignment] || !this.props.menuAlignment) {
      const {
        elementBounds,
        menuBounds,
        viewportBounds
      } = bounds;

      if (elementBounds && menuBounds) {
        const left = elementBounds.right + viewportBounds.x - window.document.documentElement.clientLeft - menuBounds.width;
        const right = elementBounds.left + viewportBounds.x - window.document.documentElement.clientLeft + menuBounds.width;
        let alignmentOverride; // The element needs to be right aligned if it's too close or outside the bounds of the viewport
        // and it it small enough to fit inside a viewport, if it's too big we'll leave the default

        if (viewportBounds.width - right < 10 && menuBounds.width < viewportBounds.width) {
          alignmentOverride = _dropdownMenu.alignmentTypes.right;
        } else if (left < 10) {
          // Only force different than the default if the leftmost bounds is outside or too close to the left side of the viewport
          alignmentOverride = _dropdownMenu.alignmentTypes.left;
        } // Compare with current state


        if (this.state.alignmentOverride !== alignmentOverride) {
          newState.alignmentOverride = alignmentOverride;
        }
      }
    }

    return newState;
  }

  toggleBackground(isOpen) {
    if (this.props.enableFullscreen) {
      if (isOpen) {
        document.body.classList.add('dropdown-open');
      } else {
        document.body.classList.remove('dropdown-open');
      }
    }

    const {
      open,
      selected
    } = this.state;
    const {
      required
    } = this.props;

    if (!open && selected.length === 0 && required) {
      this.setState({
        error: true
      });
    } else if (selected.length > 0 && required) {
      this.setState({
        error: false
      });
    }
  }
  /**
   * Extract DropdownControl from all children.
   *
   * @param {React.Element[]} children - React elements.
   * @returns {React.Element} DropdownControl with children.
   * @private
   */


  control(children) {
    const {
      placeholder,
      type,
      disabled,
      toggleIcon,
      content,
      size,
      merch,
      id,
      tabIndex
    } = this.props;
    const dropdownRef = this.dropdownRef;

    const dropdownControl = children.filter(child => child.type === _dropdownControl.default)[0] || /*#__PURE__*/_react.default.createElement(_dropdownControl.default, {
      id: id ? `${id}-control` : undefined
    });

    return /*#__PURE__*/_react.default.cloneElement(dropdownControl, {
      ['aria-labelledby']: this.props.label && `${id}-label`,
      ['ariaLabels']: this.ariaLabels,
      ['aria-controls']: id ? `${id}-menu` : undefined,
      children: dropdownControl.props.children || this.getSelectedItem(children) || placeholder,
      hasPlaceholder: !!(!dropdownControl.props.children && !this.getSelectedItem(children) && placeholder),
      ref: dropdownRef,
      key: 'control',
      id: id ? `${id}-control` : undefined,
      toggle: this.show,
      open: this.state.open,
      type,
      onKeyDown: this.keyDown.bind(this),
      disabled,
      toggleIcon,
      content,
      size,
      merch,
      tabIndex
    });
  }
  /**
   * Returns all children that are not of type DropdownControl.
   *
   * @param {React.Element[]} children - React elements.
   * @returns {React.Element[]} React elements.
   * @private
   */


  items(children) {
    return children.filter(child => {
      return child.type !== _dropdownControl.default && child.type !== _dropdownHeader.default && child.type !== _dropdownDivider.default;
    });
  }
  /**
   * Render Dropdown component.
   *
   * @returns {React.Element} div element with Dropdown.
   * @private
   */


  render() {
    const {
      keyboardSelectionIndex,
      open,
      showUp,
      hasLabel,
      error
    } = this.state;

    const props = _objectSpread(_objectSpread({}, this.props), {}, {
      keyboardSelectionIndex,
      onChange: this.selectItem,
      onToggle: this.toggle
    });

    const select = props.type.includes('select');
    const tripledot = props.type === 'tripledot'; // Use the alignment if set, otherwise tripledot prefersRight by default,
    // Everything else should left align

    props.menuAlignment = props.menuAlignment || (tripledot ? _dropdownMenu.alignmentTypes.preferRight : _dropdownMenu.alignmentTypes.left);

    const children = _react.default.Children.toArray(props.children);

    const disabled = props.disabled;

    const title = (props.label || props.required) && /*#__PURE__*/_react.default.createElement(_react.Fragment, null, props.label &&
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    _react.default.createElement("label", {
      id: `${props.id}-label`,
      key: "label",
      onClick: this.focusDropdown,
      onKeyPress: this.focusDropdown,
      ref: r => {
        this.componentLabel = r;
      }
    }, props.label), props.required && /*#__PURE__*/_react.default.createElement("span", {
      className: "text-danger"
    }, "*"));

    const className = (0, _classNames.default)(props.className, {
      'ux-select-dropdown': select
    }, 'dropdown', {
      'triple-dot-dropdown btn btn-link': tripledot,
      'dropdown-disabled disabled': disabled,
      open,
      'menu-up': showUp,
      'has-label': hasLabel,
      'full-screen': this.props.enableFullscreen,
      error
    });
    const ElementType = props.elementType;
    return /*#__PURE__*/_react.default.createElement(_useClickOutsideHoc.default, {
      targetRef: this.element,
      onClick: this.hide
    }, /*#__PURE__*/_react.default.createElement(ElementType, {
      ref: this.element,
      id: props.id,
      className: className,
      "aria-expanded": open,
      role: "combobox",
      "aria-label": this.ariaLabels.label
    }, title, this.control(children), /*#__PURE__*/_react.default.createElement(DropdownValue, {
      key: "value",
      type: props.type,
      value: props.value,
      name: props.name
    }), /*#__PURE__*/_react.default.createElement(_dropdownMenu.default, (0, _extends2.default)({
      key: "menu"
    }, props, {
      ref: r => {
        this.menuElement = r;
      },
      toggle: this.toggle,
      ariaLabels: {
        close: this.ariaLabels.close,
        menu: this.ariaLabels.menu
      },
      selected: this.selected,
      alignmentOverride: this.state.alignmentOverride,
      keyboardSelectionIndex: this.state.keyboardSelectionIndex
    }), children.filter(child => child.type !== _dropdownControl.default)), error && props.required && /*#__PURE__*/_react.default.createElement("span", {
      className: "form-error",
      role: "alert"
    }, props.required)));
  }

}
/**
 * Default to button dropdown.
 *
 * @enum {Object} defaultProps
 * @public
 */


DropdownComponent.defaultProps = _objectSpread(_objectSpread({}, _dropdown.BaseDefaultProps), {}, {
  type: 'button',
  elementType: 'div',
  enableFullscreen: true,
  ariaLabels: {
    close: 'Close',
    menu: 'Menu Options',
    label: 'Menu'
  }
});
/**
 * Define properties and validate the type of children that are passed
 * to the Dropdown.
 *
 * @enum {Object} propTypes
 * @public
 */

DropdownComponent.propTypes = _objectSpread(_objectSpread({}, _dropdown.BasePropTypes), {}, {
  /** Developer indicates tabIndex */
  tabIndex: _propTypes.default.oneOf([-1, 0]),

  /** ID attribute for the dropdown container */
  id: _propTypes.default.string,

  /** Type of the dropdown */
  type: _propTypes.default.oneOf(_dropdown.types),

  /** Wrapper element type for the dropdown */
  elementType: _propTypes.default.string,

  /** Alignment of the dropdown menu */
  alignment: _dropdownMenu.menuAlignmentPropType,

  /** Boolean whether the dropdown menu is fullscreen (mobile only) */
  enableFullscreen: _propTypes.default.bool,

  /** Screenreader labels for sub-elements */
  ariaLabels: _propTypes.default.shape({
    /** Label for mobile-view menu close button */
    close: _propTypes.default.string,

    /** Label for dropdown-menu that contains the selectable items */
    menu: _propTypes.default.string,

    /** Label for .ux-dropdown-menu which is the outer container of dropdown */
    label: _propTypes.default.string
  }),

  /** Children components of a dropdown. Can be a DropdownControl,
   *  DropdownDivider, DropdownHeader, or DropdownItem */
  children: (0, _reactComponentValidator.default)([_dropdownControl.default, _dropdownItem.default, _dropdownDivider.default, _dropdownHeader.default]),

  /** Error message to show if the dropdown is required */
  required: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.bool])
}); //
// Attach childs to the main Component for availability without ES6 imports.
//

DropdownComponent.DropdownControl = _dropdownControl.default;
DropdownComponent.DropdownDivider = _dropdownDivider.default;
DropdownComponent.DropdownHeader = _dropdownHeader.default;
DropdownComponent.DropdownItem = _dropdownItem.default; //
// Export the Class and related children.
//

const Dropdown = DropdownComponent;
exports.default = Dropdown;