"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneItem;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _dropdownItem = _interopRequireDefault(require("./dropdown-item"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * Utility method to extract props from Dropdown Menu object
 *
 * @param {React.ReactElement} wrapper Dropdown Menu component
 * @returns {Object} props from Dropdown Menu component
 * @private
 */
function extractWrapperProps(wrapper) {
  const listener = wrapper.props.type === 'multiselect' ? 'onChange' : 'onClick';
  const selected = wrapper.props.selected || [];
  return {
    listener,
    selected
  };
}
/**
 * Utility method to extract item state information.
 *
 * @param {React.ReactElement} wrapper Dropdown Menu component
 * @param {React.ReactElement} item Dropdown Item component
 * @param {Array} selected Array of selected items
 * @param {int} index Index of Dropdown Item
 * @returns {Object} active and isSelected states
 * @private
 */


function getItemState(wrapper, item, selected, index) {
  let active;
  let isSelected;

  if (wrapper.props.type === 'multiselect' || wrapper.props.keyboardSelectionIndex !== -1) {
    isSelected = selected.includes(index);

    if (index === wrapper.props.keyboardSelectionIndex && !item.props.disabled) {
      active = true;
    }
  } else {
    active = selected.includes(index);
  }

  active = !wrapper.props.contextmenu && (item.props.active || active);
  return {
    active,
    isSelected
  };
}
/**
 * Returns a React clone of the specified `item` attaching selection behavior
 * using closure scope of onChange or onClick handler(s) passed through to the item.
 *
 * @param  {Object} wrapper Full references to parent DropdownMenu.
 * @param  {React.Element} item React element representing the {Dropdown,Checkbox}Item child.
 * @param  {Number} index Zero-based index in the normalized set of {Dropdown,Checkbox}Items.
 * @returns {React.Element} Cloned item with selection behavior
 * @public
 */


function cloneItem(wrapper, item, index) {
  if (! /*#__PURE__*/_react.default.isValidElement(item)) {
    return item;
  } //
  // Enhance the DropdownItem to work as a selectable item. Active will
  // change the item's appearance to selected. The href is required to display
  // correct mouse pointers when each item is hovered. Multiselect requires onChange
  // which will be triggered from a click on the label. Thus both clicks on the label
  // and checkbox result in an onChange. Thus properly toggling the input checkbox.
  //


  const itemProps = item.props;
  const {
    listener,
    selected
  } = extractWrapperProps(wrapper); //
  // This is our opportunity to determine selected and active state
  // before we clone the element. It is easiest to track this state at the
  // menu instead of the individual DropdownItem instances.
  //

  const {
    active,
    isSelected
  } = getItemState(wrapper, item, selected, index); // If wrapper is dropdown column, get the menu reference to set the dropdownItem reference

  const menuRef = wrapper.props.menuRef || wrapper; //
  // For type='base', type='primary', etc. Pass-thru "active" set on the individual
  // item props, if it exists. Otherwise default to the internal selection logic.
  //

  if (!wrapper.props.type.includes('select') && !wrapper.props.type.includes('inline') && !wrapper.props.type.includes('primary') && wrapper.props.type !== 'tripledot' && wrapper.props.type !== 'custom' || item.type !== _dropdownItem.default) {
    return /*#__PURE__*/_react.default.cloneElement(item, {
      active,
      ref: r => {
        menuRef.dropdownItem = r;
      }
    });
  }

  return /*#__PURE__*/_react.default.cloneElement(item, {
    isSelected,
    active,
    name: wrapper.props.name,
    ref: r => {
      menuRef.dropdownItem = r;
    },
    type: wrapper.props.type,
    href: itemProps.href || '#',
    [listener]: event => {
      if (itemProps.disabled || itemProps.href === '#' || listener === 'onClick') event.preventDefault();
      if (itemProps.disabled) return;
      wrapper.props.onChange(_objectSpread({
        itemIndex: index,
        active: !active
      }, itemProps), event, itemProps[listener]);
    }
  });
}