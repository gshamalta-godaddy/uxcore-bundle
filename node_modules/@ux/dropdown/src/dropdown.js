/* eslint no-unused-vars: 0 */
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { toggle } from 'toggler';
import Button from '@ux/button';

//
// Allowed dropdown types.
//
const types = Object.values(Button.designs).concat('button', 'select', 'multiselect', 'tripledot', 'custom');

/**
 * Display a Dropdown that works standalone button, as select or multiselect.
 *
 * @class Dropdown
 * @public
 */
class Base extends Component {
  constructor(props = {}, ...args) {
    super(props, ...args);
    this.toggle = toggle(this, 'open', () => {
      const isOpen = this.state.open;
      if (typeof this.props.onToggle === 'function') {
        this.props.onToggle(isOpen);
      }
      if (typeof this.toggleBackground === 'function') {
        this.toggleBackground(isOpen);
      }
    });

    const selectedItems =
      (Array.isArray(props.selected) || typeof props.selected === 'number')
        ? props.selected
        : props.defaultSelected;

    this.state = {
      ...this.state,
      error: false,
      open: this.props.open || false,
      selected: [].concat(selectedItems),
      keyboardSelectionIndex: -1
    };

    this.calledWarn = false;
    this._warn();
  }

  /**
   *  console warning about missing id for accessibility purposes
   */
  _warn() {
    // eslint-disable-next-line no-process-env
    if (process.env.NODE_ENV === 'production') return;

    if (!this.props.id && !this.calledWarn) {
      this.calledWarn = true;
      console.warn('Warning: <Dropdown> requires an id prop to be fully accessible.'); /* eslint-disable-line */
    }
  }

  /**
   * Returns all children that are not of a specific type. This will be
   * overridden by the separate web and native specitic implementations of
   * the dropdown.
   *
   * @param {React.Element[]} children - React elements.
   * @throws {Error} error if this method is not overridden
   * @private
   */
  items(children) {
    throw new Error('Must be implemented by derived class.');
  }

  /**
   * Returns true if the current dropdown is a multiselect dropdown
   *
   * @returns {Boolean} true if dropdown is multiselect
   * @public
   */
  isMultiSelect() {
    return this.props.type === 'multiselect';
  }

  /**
   * Sets the document location if the given item has a valid href
   *
   * @param {Object} itemProps Fully formed props from the selected item
   * @private
   */
  redirectToHrefIfAvailable(itemProps) {
    const { href } = itemProps;
    if (href && typeof href === 'string' && href !== '#') {
      document.location = href;
    }
  }

  /**
   * Select the item for a given index and trigger onChange from props if provided.
   * In the case of multiselect, it will also unselect.
   *
   * @param {Number} itemIndex Zero-based index of the item (among DropdownItems only).
   * @param {Event} event Event passed in from the source of the select
   * @param {function} callback Callback to fire after state has been updated
   * @public
   */
  selectIndex(itemIndex, event) {
    const items = this.items(React.Children.toArray(this.props.children));
    const item = items[itemIndex];
    if (!item) {
      return;
    }

    const listener = item.props.type === 'multiselect' ? 'onChange' : 'onClick';
    this.selectItem({ ...item.props, itemIndex }, event, item.props[listener]);
  }

  /**
   * Select the item with the given `itemProps.itemIndex` and trigger onChange
   * from props if provided. Finally also trigger the **item's** onChange or
   * onClick handler (represented by `callback`). In the case of multiselect,
   * it will also unselect.
   *
   * @param {Object} itemProps Fully formed props from the selected item
   * @param {Event} event Event passed in from the source of the select
   * @param {function} callback Callback to fire after state has been updated
   * @public
   */
  selectItem(itemProps, event, callback) {
    this.redirectToHrefIfAvailable(itemProps);

    let { selected } = this.state;
    const { itemIndex } = itemProps;

    if (this.isMultiSelect()) {
      const index = selected.indexOf(itemIndex);
      if (index > -1) {
        selected.splice(index, 1);
      } else {
        selected.push(itemIndex);
      }
    } else {
      selected = [itemIndex];
    }

    const nextState = { selected, keyboardSelectionIndex: itemIndex };
    let nextSelected = selected;
    if (!this.isMultiSelect()) {
      this.hide();
      nextSelected = nextSelected[0];
    }

    this.setState(nextState, () => {
      this.broadcast({
        ...itemProps,
        selected: nextSelected
      }, event, callback);
    });
  }

  /**
   * broadcast item selection to the dropdown onChange prop as well as
   * either the onClick or onChange callback of dropdown items if defined
   *
   * @param {Object} options selected item properties
   * @param {event} event the react proxy event that originates at the doprdown item
   * @param {function} callback callback function to invoke in addition to dropdown onChange
   * @private
   */
  broadcast(options, event, callback) {
    if (!event) {
      return;
    }

    if (this.props.onChange) {
      this.props.onChange(options, event);
    }

    callback && callback(options, event);
  }

  /**
   * On change of incoming `open` prop update internal state using `toggler`
   *
   * @param {Object} prevProps - Object of Previous Props
   * @private
   */
  componentDidUpdate(prevProps) {
    if (typeof this.props.open !== 'undefined' && prevProps.open !== this.props.open) {
      this.toggle();
    }

    if (this.props.selected !== prevProps.selected) {
      this.setState({
        selected: [].concat(this.props.selected),
        keyboardSelectionIndex: -1
      });
    }
  }

  /**
   * Event handler to show and hide the dropdown.
   *
   * @returns {Function} Event handler
   * @public
   */
  get show() {
    return this.props.show || (event => {
      this.toggle(event);
    });
  }

  /**
   * Event handler to hide the dropdown after clicking on another dropdown,
   * the state check is done to prevent state
   * changes when the dropdown is already hidden. This method is used by the
   * document click listeners.
   *
   * @returns {Function} Event handler
   * @public
   */
  get hide() {
    return this.props.hide || (event => {
      if (!this.state.open) {
        return;
      }
      this.toggle(event);
    });
  }

  /**
   * Return selected indexes of dropdown items.
   *
   * @returns {Array} Selected item indexes.
   * @private
   */
  get selected() {
    return this.state.selected;
  }

  /**
   * When space or enter is pressed select the DropdownItem. Incase of multiselect select the Dropdown item on space.
   * When escape is pressed close the dropdown.
   * When a Arrowup or Arrowdown is pressed move the pointer accordingly.
   * Incase of Button, on enter or space it opens the link.
   * @param {object} e Event object sent from the browser
   * @private
   */
  keyDown(e) {
    const key = e.key;
    switch (key) {
      case 'Escape':
        this.hide();
        break;
      case 'ArrowUp':
      case 'ArrowDown':
        this.onArrowUpDown(e);
        break;
      case 'Space':  // Space bar
      case 'Enter': {  // Enter
        if (this.state.open) {
          const { keyboardSelectionIndex } = this.state;
          this.selectIndex(keyboardSelectionIndex, e);
        }
        break;
      }
      default:
        break;
    }
  }

  /**
   * On ArrowUp or ArrowDown sets the index of the dropdown item.
   * @param {KeyboardEvent} e Event object sent from the browser
   * @private
   */
  onArrowUpDown(e) {
    if (e.key === 'ArrowDown' && !this.state.open) {
      this.show();
    }

    let { keyboardSelectionIndex } = this.state;
    const delta = e.key === 'ArrowDown' ? 1 : -1;

    if (keyboardSelectionIndex === -1 && e.key === 'ArrowUp') {
      keyboardSelectionIndex = 0;
    }

    const items = this.items(React.Children.toArray(this.props.children));
    const dataLength = items.length;
    if (items.filter(item => !item.props.disabled).length > 0) {
      // Using bounds just outside the acceptable range. This is for logic safety only.
      for (let i = keyboardSelectionIndex + delta; i < dataLength + 1 && i > -2; i += delta) {
        // Reset the index if it's beyond the bounds of the list, allowing looping.
        i = (i + dataLength) % dataLength;
        if (!items[i].props.disabled) {
          this.setState({ keyboardSelectionIndex: i });
          break;
        }
      }
    }
    e.preventDefault();
  }

  /**
   * Extract the children (text) of the selected DropdownItem.
   *
   * @param {Array} childs Current children of this instance.
   * @returns {Array} Join of selected items.
   * @private
   */
  getSelectedItem(childs) {
    let items = this.items(childs) || [];
    items = items.filter((item, i) => this.selected.includes(i));

    if (!items.length) {
      return null;
    }

    return items.reduce((memo, item, i) => {
      if (i) memo.push(', ');
      memo.push(item.props.children);
      return memo;
    }, []);
  }
}

/**
 * Default to button dropdown.
 *
 * @enum {Object} defaultProps
 * @public
 */
const BaseDefaultProps = Base.defaultProps = {
  defaultSelected: [],
  disabled: false,
  onChange: () => {},
  onToggle: () => {}
};

/**
 * Define properties and validate the type of children that are passed
 * to the Dropdown.
 *
 * @enum {Object} propTypes
 * @public
 */
const BasePropTypes = Base.propTypes = {
  name: PropTypes.string,
  children: PropTypes.node,
  open: PropTypes.bool,
  show: PropTypes.func,
  hide: PropTypes.func,
  required: PropTypes.oneOfType([PropTypes.node, PropTypes.bool]),
  onChange: PropTypes.func,
  onToggle: PropTypes.func,
  type: PropTypes.oneOf(types),
  content: PropTypes.oneOfType([PropTypes.element, PropTypes.string]),
  disabled: PropTypes.bool,
  placeholder: PropTypes.node,
  label: PropTypes.node,
  toggleIcon: PropTypes.oneOf(['clock', 'dropdown']),
  selected: PropTypes.oneOfType([
    PropTypes.number,
    PropTypes.array
  ]),
  defaultSelected: PropTypes.oneOfType([
    PropTypes.number,
    PropTypes.array
  ]),
  id: PropTypes.string,
  contextmenu: PropTypes.bool
};

export {
  Base as default,
  types,
  BasePropTypes,
  BaseDefaultProps
};
