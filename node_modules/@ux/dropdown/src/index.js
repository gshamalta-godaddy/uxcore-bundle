/* eslint-disable no-undefined */
import validateComponents from 'react-component-validator';
import React, { Component, Fragment } from 'react';
import PropTypes from 'prop-types';
import Base, { types, BasePropTypes, BaseDefaultProps } from './dropdown';
import classNames from '@ux/component-utilities/lib/classNames';
import ClickOutside from '@ux/component-utilities/lib/use-click-outside-hoc';
import scrollIntoViewIfNeeded from '@ux/component-utilities/lib/scroll-into-view';

//
// Import all child components.
//
import DropdownControl from './dropdown-control';
import DropdownDivider from './dropdown-divider';
import DropdownHeader from './dropdown-header';
import DropdownMenu, {
  alignmentTypes,
  autoAlignments,
  menuAlignmentPropType
} from './dropdown-menu';
import DropdownItem from './dropdown-item';

/**
 * Track of the current selected value with a hidden input element. Allowing
 * simple POST requests of forms.
 *
 * @class DropdownValue
 * @private
 */
class DropdownValue extends Component {
  render() {
    const allowedTypes = ['select', 'tripledot', 'custom'];
    if (!allowedTypes.includes(this.props.type)) {
      return null;
    }

    return <input { ...this.props } type='hidden' readOnly />;
  }
}

/**
 * PropType validation
 *
 * @enum {Object} propTypes
 * @public
 */
DropdownValue.propTypes = {
  /** Type of dropdown */
  type: PropTypes.oneOf(types)
};

/**
 * Display a Dropdown that works standalone button, as select or multiselect.
 *
 * @displayName Dropdown (Web)
 * @class Dropdown
 * @extends React.Component
 * @public
 */
class DropdownComponent extends Base {
  constructor() {
    super(...arguments);
    this.hideHandle = null;
    this.selectItem = this.selectItem.bind(this);
    this.toggleBackground = this.toggleBackground.bind(this);
    this.element = React.createRef();
    this.dropdownRef = React.createRef();
    this.ariaLabels = {
      ...DropdownComponent.defaultProps.ariaLabels,
      ...this.props.ariaLabels
    };
    this.focusDropdown = this.focusDropdown.bind(this);
  }

  /**
   * Added this to force focus to the dropdown when the label is clicked.
   *
   * @private
   */
  focusDropdown() {
    // Explicitly focus the text input using the raw DOM API
    // Note: we're accessing "current" to get the DOM node
    this.dropdownRef.current.focus();
  }

  /**
   * Remove the attached click event listener.
   *
   * @private
   */
  componentWillUnmount() {
    document.removeEventListener('click', this.hideHandle || this.hide);
    this.hideHandle = null;
  }

  /**
   * Scroll to the active item.
   *
   * @param {object} prevProps - Previous props before update
   * @param {object} prevState - Previous state before update
   * @private
   */
  componentDidUpdate(prevProps, prevState) {
    super.componentDidUpdate(prevProps);
    const activeItem =
      this.element.current && this.element.current.querySelector('.active');
    const { open } = this.state;

    if (open && open !== prevState.open) {
      const { ...bounds } = this.getElementBounds();
      let newState = this.getHorizontalRender(bounds);
      newState = {
        ...newState,
        ...this.getVerticalRender(bounds)
      };

      if (Object.keys(newState).length > 0) {
        this.setState(newState);
      }
    }

    if (open && activeItem) {
      scrollIntoViewIfNeeded(activeItem);
    }
  }

  /**
   * Fetches all element bounds to necessary calculations of display
   * @private
   * @returns {object} element bounds
   */
  getElementBounds() {
    // Viewport Bounds
    const viewportBounds = {
      x: window.pageXOffset,
      y: window.pageYOffset,
      width: window.innerWidth,
      height: window.innerHeight
    };

    // Main Dropdown Element
    const elementBounds =
      this.element.current && this.element.current.getBoundingClientRect();

    // Dropdown Menu Element
    const menuBounds =
      this.menuElement &&
      this.menuElement.wrapper &&
      this.menuElement.wrapper.getBoundingClientRect();

    // Label Element (if one exists)
    const labelBounds =
      this.componentLabel && this.componentLabel.getBoundingClientRect();

    // Menu Item Element
    const menuItemRef =
      this.menuElement &&
      this.menuElement.dropdownItem &&
      this.menuElement.dropdownItem.getRef &&
      this.menuElement.dropdownItem.getRef();

    const menuItemBounds = menuItemRef && menuItemRef.getBoundingClientRect();

    // Get Dropdown Item height
    const itemHeight = (menuItemBounds && menuItemBounds.height) || 45;

    return {
      viewportBounds,
      elementBounds,
      menuBounds,
      labelBounds,
      itemHeight
    };
  }

  /**
   * Compute vertical spacing for menu and determine whether to show above or below the dropdown control.
   *
   * @param {object} bounds - Object containing element bounds calculated in getElementBounds()
   * @returns {obbject} Temporary updated state object
   * @private
   */
  getVerticalRender(bounds) {
    // Temporary object to prevent multiple state updates
    const newState = {};
    const {
      viewportBounds,
      elementBounds,
      menuBounds,
      labelBounds,
      itemHeight
    } = bounds;

    const hasLabel = labelBounds && labelBounds.height > 0;
    if (this.state.hasLabel !== hasLabel) {
      newState.hasLabel = hasLabel;
    }

    if (elementBounds) {
      // Determine to show the menu above or below
      const menuBottomBound =
        elementBounds.top +
        elementBounds.height +
        menuBounds.height -
        itemHeight / 2;
      const overflowBelow = viewportBounds.height < menuBottomBound;
      const spaceAbove = elementBounds.top - menuBounds.height > 0;
      const showUp = overflowBelow && spaceAbove;

      if (this.state.showUp !== showUp) {
        newState.showUp = showUp;
      }
    }

    return newState;
  }

  /**
   * Compute horizontal spacing for menu and determine whether to show aligned left or right to the dropdown control.
   *
   * @param {object} bounds - Object containing menu bounds calculated in getElementBounds()
   * @returns {object} Temporary updated state object
   * @private
   */
  getHorizontalRender(bounds) {
    const newState = {};
    if (autoAlignments[this.props.menuAlignment] || !this.props.menuAlignment) {
      const { elementBounds, menuBounds, viewportBounds } = bounds;
      if (elementBounds && menuBounds) {
        const left =
          elementBounds.right +
          viewportBounds.x -
          window.document.documentElement.clientLeft -
          menuBounds.width;
        const right =
          elementBounds.left +
          viewportBounds.x -
          window.document.documentElement.clientLeft +
          menuBounds.width;

        let alignmentOverride;
        // The element needs to be right aligned if it's too close or outside the bounds of the viewport
        // and it it small enough to fit inside a viewport, if it's too big we'll leave the default
        if (
          viewportBounds.width - right < 10 &&
          menuBounds.width < viewportBounds.width
        ) {
          alignmentOverride = alignmentTypes.right;
        } else if (left < 10) {
          // Only force different than the default if the leftmost bounds is outside or too close to the left side of the viewport
          alignmentOverride = alignmentTypes.left;
        }

        // Compare with current state
        if (this.state.alignmentOverride !== alignmentOverride) {
          newState.alignmentOverride = alignmentOverride;
        }
      }
    }
    return newState;
  }

  toggleBackground(isOpen) {
    if (this.props.enableFullscreen) {
      if (isOpen) {
        document.body.classList.add('dropdown-open');
      } else {
        document.body.classList.remove('dropdown-open');
      }
    }

    const { open, selected } = this.state;
    const { required } = this.props;
    if (!open && selected.length === 0 && required) {
      this.setState({
        error: true
      });
    } else if (selected.length > 0 && required) {
      this.setState({
        error: false
      });
    }
  }

  /**
   * Extract DropdownControl from all children.
   *
   * @param {React.Element[]} children - React elements.
   * @returns {React.Element} DropdownControl with children.
   * @private
   */
  control(children) {
    const {
      placeholder,
      type,
      disabled,
      toggleIcon,
      content,
      size,
      merch,
      id,
      tabIndex
    } = this.props;

    const dropdownRef = this.dropdownRef;

    const dropdownControl = children.filter(
      (child) => child.type === DropdownControl
    )[0] || <DropdownControl id={ id ? `${id}-control` : undefined } />;
    return React.cloneElement(dropdownControl, {
      ['aria-labelledby']: this.props.label && `${id}-label`,
      ['ariaLabels']: this.ariaLabels,
      ['aria-controls']: id ? `${id}-menu` : undefined,
      children:
        dropdownControl.props.children ||
        this.getSelectedItem(children) ||
        placeholder,
      hasPlaceholder: !!(
        !dropdownControl.props.children &&
        !this.getSelectedItem(children) &&
        placeholder
      ),
      ref: dropdownRef,
      key: 'control',
      id: id ? `${id}-control` : undefined,
      toggle: this.show,
      open: this.state.open,
      type,
      onKeyDown: this.keyDown.bind(this),
      disabled,
      toggleIcon,
      content,
      size,
      merch,
      tabIndex
    });
  }

  /**
   * Returns all children that are not of type DropdownControl.
   *
   * @param {React.Element[]} children - React elements.
   * @returns {React.Element[]} React elements.
   * @private
   */
  items(children) {
    return children.filter((child) => {
      return (
        child.type !== DropdownControl &&
        child.type !== DropdownHeader &&
        child.type !== DropdownDivider
      );
    });
  }

  /**
   * Render Dropdown component.
   *
   * @returns {React.Element} div element with Dropdown.
   * @private
   */
  render() {
    const {
      keyboardSelectionIndex,
      open,
      showUp,
      hasLabel,
      error
    } = this.state;
    const props = {
      ...this.props,
      keyboardSelectionIndex,
      onChange: this.selectItem,
      onToggle: this.toggle
    };
    const select = props.type.includes('select');
    const tripledot = props.type === 'tripledot';
    // Use the alignment if set, otherwise tripledot prefersRight by default,
    // Everything else should left align
    props.menuAlignment =
      props.menuAlignment ||
      (tripledot ? alignmentTypes.preferRight : alignmentTypes.left);
    const children = React.Children.toArray(props.children);
    const disabled = props.disabled;
    const title = (props.label || props.required) && (
      <Fragment>
        {props.label && (
          // eslint-disable-next-line jsx-a11y/no-static-element-interactions
          <label
            id={ `${props.id}-label` }
            key='label'
            onClick={ this.focusDropdown }
            onKeyPress={ this.focusDropdown }
            ref={ (r) => {
              this.componentLabel = r;
            } }
          >
            {props.label}
          </label>
        )}
        {props.required && <span className='text-danger'>*</span>}
      </Fragment>
    );
    const className = classNames(
      props.className,
      {
        'ux-select-dropdown': select
      },
      'dropdown',
      {
        'triple-dot-dropdown btn btn-link': tripledot,
        'dropdown-disabled disabled': disabled,
        open,
        'menu-up': showUp,
        'has-label': hasLabel,
        'full-screen': this.props.enableFullscreen,
        error
      }
    );

    const ElementType = props.elementType;

    return (
      <ClickOutside targetRef={ this.element } onClick={ this.hide }>
        <ElementType
          ref={ this.element }
          id={ props.id }
          className={ className }
          aria-expanded={ open }
          role='combobox'
          aria-label={ this.ariaLabels.label }
        >
          {title}
          {this.control(children)}
          <DropdownValue
            key='value'
            type={ props.type }
            value={ props.value }
            name={ props.name }
          />
          <DropdownMenu
            key='menu'
            { ...props }
            ref={ (r) => {
              this.menuElement = r;
            } }
            toggle={ this.toggle }
            ariaLabels={{
              close: this.ariaLabels.close,
              menu: this.ariaLabels.menu
            }}
            selected={ this.selected }
            alignmentOverride={ this.state.alignmentOverride }
            keyboardSelectionIndex={ this.state.keyboardSelectionIndex }
          >
            {children.filter((child) => child.type !== DropdownControl)}
          </DropdownMenu>
          {error && props.required && (
            <span className='form-error' role='alert'>
              {props.required}
            </span>
          )}
        </ElementType>
      </ClickOutside>
    );
  }
}

/**
 * Default to button dropdown.
 *
 * @enum {Object} defaultProps
 * @public
 */
DropdownComponent.defaultProps = {
  ...BaseDefaultProps,
  type: 'button',
  elementType: 'div',
  enableFullscreen: true,
  ariaLabels: {
    close: 'Close',
    menu: 'Menu Options',
    label: 'Menu'
  }
};

/**
 * Define properties and validate the type of children that are passed
 * to the Dropdown.
 *
 * @enum {Object} propTypes
 * @public
 */
DropdownComponent.propTypes = {
  /** Common dropdown props */
  ...BasePropTypes,
  /** Developer indicates tabIndex */
  tabIndex: PropTypes.oneOf([-1, 0]),
  /** ID attribute for the dropdown container */
  id: PropTypes.string,
  /** Type of the dropdown */
  type: PropTypes.oneOf(types),
  /** Wrapper element type for the dropdown */
  elementType: PropTypes.string,
  /** Alignment of the dropdown menu */
  alignment: menuAlignmentPropType,
  /** Boolean whether the dropdown menu is fullscreen (mobile only) */
  enableFullscreen: PropTypes.bool,
  /** Screenreader labels for sub-elements */
  ariaLabels: PropTypes.shape({
    /** Label for mobile-view menu close button */
    close: PropTypes.string,
    /** Label for dropdown-menu that contains the selectable items */
    menu: PropTypes.string,
    /** Label for .ux-dropdown-menu which is the outer container of dropdown */
    label: PropTypes.string
  }),
  /** Children components of a dropdown. Can be a DropdownControl,
   *  DropdownDivider, DropdownHeader, or DropdownItem */
  children: validateComponents([
    DropdownControl,
    DropdownItem,
    DropdownDivider,
    DropdownHeader
  ]),
  /** Error message to show if the dropdown is required */
  required: PropTypes.oneOfType([PropTypes.node, PropTypes.bool])
};

//
// Attach childs to the main Component for availability without ES6 imports.
//
DropdownComponent.DropdownControl = DropdownControl;
DropdownComponent.DropdownDivider = DropdownDivider;
DropdownComponent.DropdownHeader = DropdownHeader;
DropdownComponent.DropdownItem = DropdownItem;

//
// Export the Class and related children.
//
const Dropdown = DropdownComponent;

export {
  Dropdown as default,
  DropdownControl,
  DropdownDivider,
  DropdownHeader,
  DropdownItem
};
