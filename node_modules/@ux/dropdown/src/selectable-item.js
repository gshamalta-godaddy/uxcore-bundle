import React from 'react';
import DropdownItem from './dropdown-item';

/**
 * Utility method to extract props from Dropdown Menu object
 *
 * @param {React.ReactElement} wrapper Dropdown Menu component
 * @returns {Object} props from Dropdown Menu component
 * @private
 */
function extractWrapperProps(wrapper) {
  const listener =
    wrapper.props.type === 'multiselect' ? 'onChange' : 'onClick';
  const selected = wrapper.props.selected || [];

  return { listener, selected };
}

/**
 * Utility method to extract item state information.
 *
 * @param {React.ReactElement} wrapper Dropdown Menu component
 * @param {React.ReactElement} item Dropdown Item component
 * @param {Array} selected Array of selected items
 * @param {int} index Index of Dropdown Item
 * @returns {Object} active and isSelected states
 * @private
 */
function getItemState(wrapper, item, selected, index) {
  let active;
  let isSelected;
  if (
    wrapper.props.type === 'multiselect' ||
    wrapper.props.keyboardSelectionIndex !== -1
  ) {
    isSelected = selected.includes(index);
    if (
      index === wrapper.props.keyboardSelectionIndex &&
      !item.props.disabled
    ) {
      active = true;
    }
  } else {
    active = selected.includes(index);
  }

  active = !wrapper.props.contextmenu && (item.props.active || active);

  return { active, isSelected };
}

/**
 * Returns a React clone of the specified `item` attaching selection behavior
 * using closure scope of onChange or onClick handler(s) passed through to the item.
 *
 * @param  {Object} wrapper Full references to parent DropdownMenu.
 * @param  {React.Element} item React element representing the {Dropdown,Checkbox}Item child.
 * @param  {Number} index Zero-based index in the normalized set of {Dropdown,Checkbox}Items.
 * @returns {React.Element} Cloned item with selection behavior
 * @public
 */
export default function cloneItem(wrapper, item, index) {
  if (!React.isValidElement(item)) {
    return item;
  }

  //
  // Enhance the DropdownItem to work as a selectable item. Active will
  // change the item's appearance to selected. The href is required to display
  // correct mouse pointers when each item is hovered. Multiselect requires onChange
  // which will be triggered from a click on the label. Thus both clicks on the label
  // and checkbox result in an onChange. Thus properly toggling the input checkbox.
  //
  const itemProps = item.props;
  const { listener, selected } = extractWrapperProps(wrapper);
  //
  // This is our opportunity to determine selected and active state
  // before we clone the element. It is easiest to track this state at the
  // menu instead of the individual DropdownItem instances.
  //
  const { active, isSelected } = getItemState(wrapper, item, selected, index);
  // If wrapper is dropdown column, get the menu reference to set the dropdownItem reference
  const menuRef = wrapper.props.menuRef || wrapper;

  //
  // For type='base', type='primary', etc. Pass-thru "active" set on the individual
  // item props, if it exists. Otherwise default to the internal selection logic.
  //
  if (
    (!wrapper.props.type.includes('select') &&
      !wrapper.props.type.includes('inline') &&
      !wrapper.props.type.includes('primary') &&
      wrapper.props.type !== 'tripledot' &&
      wrapper.props.type !== 'custom') ||
    item.type !== DropdownItem
  ) {
    return React.cloneElement(item, {
      active,
      ref: (r) => {
        menuRef.dropdownItem = r;
      }
    });
  }

  return React.cloneElement(item, {
    isSelected,
    active,
    name: wrapper.props.name,
    ref: (r) => {
      menuRef.dropdownItem = r;
    },
    type: wrapper.props.type,
    href: itemProps.href || '#',
    [listener]: (event) => {
      if (
        itemProps.disabled ||
        itemProps.href === '#' ||
        listener === 'onClick'
      )
        event.preventDefault();
      if (itemProps.disabled) return;
      wrapper.props.onChange(
        { itemIndex: index, active: !active, ...itemProps },
        event,
        itemProps[listener]
      );
    }
  });
}
