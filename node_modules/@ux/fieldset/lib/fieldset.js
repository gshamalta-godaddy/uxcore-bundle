"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Platform independant Fieldset base class.
 *
 * @Constructor
 * @public
 */
class Base extends _react.Component {
  /**
   * Check if the child input elements contain a given property.
   *
   * @param {Array} children Child elements.
   * @param {String} prop Name of the property that should be present.
   * @returns {Boolean} Results
   * @private
   */
  includes(children, prop) {
    return _react.default.Children.toArray(children).some(child => {
      if (!child.type || !child.props) return false;

      if (child.type === 'input' || child.type.toString() === 'TextInput') {
        return prop in child.props;
      }

      return this.includes(child.props.children, prop);
    });
  }
  /**
   * Check if our given input is invalid.
   *
   * @param {Array} children Child elements.
   * @returns {Boolean} Results
   * @public
   */


  invalid(children) {
    return this.includes(children || this.props.children, 'data-invalid');
  }
  /**
   * Check if our given input is valid.
   *
   * @param {Array} children Child elements.
   * @returns {Boolean} Results
   * @public
   */


  valid(children) {
    return this.includes(children || this.props.children, 'data-valid');
  }
  /**
   * Default proxy value.
   *
   * TODO (crobbins): Should be combined with index.js since it only has
   * one concrete implementation.
   *
   * @public
   */


  get proxy() {
    throw new Error('Proxy implementation required');
  }
  /**
   * Default view value.
   *
   * TODO (crobbins): Should be combined with index.js since it only has
   * one concrete implementation.
   *
   * @public
   */


  get view() {
    throw new Error('View implementation required');
  }
  /**
   * Render the view of the class unless the `proxy` property is true.
   *
   * @returns {ReactElement} View from extended class.
   * @private
   */


  render() {
    const {
      proxy,
      children
    } = this.props;

    if (proxy) {
      return _react.Children.count(children) === 1 ? children : this.proxy;
    }

    return this.view;
  }

}
/**
 * PropType validation
 *
 * @type {Object}
 * @private
 */


exports.default = Base;
Base.propTypes = {
  /** Determines if the children are wrapped in a proxy component */
  proxy: _propTypes.default.bool,

  /** Child components in the fieldset */
  children: _propTypes.default.node
};