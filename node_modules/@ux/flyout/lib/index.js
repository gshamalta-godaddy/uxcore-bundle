"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.UX_FLYOUT_PLACEMENTS = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _reactDom2 = require("@floating-ui/react-dom");

var _utils = require("./utils");

const _excluded = ["middlewareData", "reference", "floating", "refs"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

const UX_FLYOUT_CLASSNAME = 'ux-flyout';
const UX_FLYOUT_PLACEMENTS = ['bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top'];
/**
 * Distance away from the edges that the arrow can travel.
 * This _should_ be the border-radius of the flyout however,
 * that value is themable so we assume the value wont be too big.
 */

exports.UX_FLYOUT_PLACEMENTS = UX_FLYOUT_PLACEMENTS;
const ARROW_EDGE_OFFSET_INT = 4;
/**
 * Prepares the middleware for the flyout
 *
 * @param {Object} config - Configuration object
 * @param {Element} config.arrowRef - The reference to the arrow element
 * @returns {Array} - Collection of middleware
 */

function getMiddleware(_ref) {
  let {
    arrowRef: element
  } = _ref;
  return [(0, _reactDom2.shift)(), (0, _reactDom2.flip)(), (0, _reactDom2.hide)(), (0, _reactDom2.arrow)({
    element,
    padding: ARROW_EDGE_OFFSET_INT
  })];
}
/**
 * Creates an arrow for the flyout
 *
 * @param {Object} props - Props for the component
 * @param {Object} props.arrow - Configuration for placing the arrow
 * @param {Object} ref - The reference to the component element
 * @returns {Component} - Arrow component
 */


const Arrow = /*#__PURE__*/_react.default.forwardRef((props, ref) => {
  const {
    x: left,
    y: top
  } = props.arrow || {};
  return /*#__PURE__*/_react.default.createElement("div", {
    className: `${UX_FLYOUT_CLASSNAME}-arrow`,
    ref: ref,
    style: {
      top,
      left
    }
  });
});

Arrow.propTypes = {
  /** Provides placement for the arrow */
  arrow: _propTypes.default.shape({
    x: _propTypes.default.number,
    y: _propTypes.default.number
  })
};
/**
 * Creates a Flyout component
 *
 * @param {Object} props - Properties for the Flyout element
 * @param {Element} props.anchorRef - Reference to a DOM element where the flyout should be visually attached.
 * @param {Boolean} props.arrow - Boolean which determines if an arrow should be included on the flyout
 * @param {Node|Array<Node>} props.chilren - Children to render inside the flyout
 * @param {String} props.className - Optional classname for positioning
 * @param {String} props.id - Id to set on the flyout for accessibilty
 * @param {String} props.placement - Configuration for setting the placement of the flyout relative to the anchor.anchorRef
 * @param {String} props.strategy - Sets the strategy for @floating-ui (absolute/fixed)
 * @param {Element} props.portalElm - Optional releact element to create a react portal from
 * @param {String} props.role - Role to set on the flyout for accessibility
 * @param {Function} props.onClose - Fires when the user attempts to escape the flyout
 * @param {Function} props.onPlacement - Fires when the placement of the flyout changes
 * @param {Boolean} props.stretch - Stretches the flyout to the nearest relative ancestor
 * @returns {Component} - Flyout element
 */

function Flyout(props) {
  var _refs$reference, _refs$reference$curre;

  const {
    anchorRef,
    arrow: arrowConfig,
    children,
    className,
    id,
    placement,
    strategy,
    portalElem,
    role,
    onClose = Function.prototype,
    onPlacement = Function.prototype,
    stretch
  } = props;
  const arrowRef = (0, _react.useRef)(null);
  const arrowSize = (0, _utils.getArrowSize)(arrowConfig);

  const _useFloating = (0, _reactDom2.useFloating)({
    // https://floating-ui.com/docs/react-dom#updating
    whileElementsMounted: function () {
      try {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return (0, _reactDom2.autoUpdate)(...args, {
          animationFrame: true
        });
      } catch (err) {
        return Function.prototype;
      }
    },
    placement,
    strategy,
    middleware: getMiddleware({
      arrowRef
    })
  }),
        {
    // middlewareData contains information returned from the middleware, used for additional attributes
    middlewareData,
    // reference is a function which get the computed position of the anchorRef
    reference,
    // floating is the ref function to assign to the flyout
    floating,
    // refs of the elements in the DOM
    refs
  } = _useFloating,
        floatingData = (0, _objectWithoutProperties2.default)(_useFloating, _excluded); // Using a virtual element approach for positioning to avoid rendering a reference element inside the component
  // https://floating-ui.com/docs/react-dom#virtual-element


  (0, _react.useLayoutEffect)(() => {
    var _anchorRef$current;

    if (!(anchorRef !== null && anchorRef !== void 0 && (_anchorRef$current = anchorRef.current) !== null && _anchorRef$current !== void 0 && _anchorRef$current.getBoundingClientRect)) return;
    reference(anchorRef.current);
  }, [reference, anchorRef, children]); // Handle events that occur outside of the flyout context

  (0, _react.useEffect)(() => {
    var _anchorRef$current2;

    if (!(anchorRef !== null && anchorRef !== void 0 && (_anchorRef$current2 = anchorRef.current) !== null && _anchorRef$current2 !== void 0 && _anchorRef$current2.getBoundingClientRect) || !refs.floating.current) return;
    return (0, _utils.outsideListeners)([anchorRef.current, refs.floating.current], onClose);
  }, [anchorRef, refs.floating, onClose]); // Fire event if the placement changes

  (0, _react.useLayoutEffect)(() => {
    onPlacement(floatingData.placement);
  }, [floatingData.placement, onPlacement]); // Do not render if no anchorRef or children

  if (!anchorRef || !children) {
    return null;
  } // If stretch, set the minimum width of the flyout to the reference offset width


  const minWidth = stretch ? (_refs$reference = refs.reference) === null || _refs$reference === void 0 ? void 0 : (_refs$reference$curre = _refs$reference.current) === null || _refs$reference$curre === void 0 ? void 0 : _refs$reference$curre.offsetWidth : null;

  const flyout = /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({
    className: (0, _classnames.default)(UX_FLYOUT_CLASSNAME, className),
    id: id,
    role: role,
    ref: floating,
    style: (0, _utils.getFlyoutStyle)(_objectSpread({
      arrowSize,
      minWidth
    }, floatingData))
  }, (0, _utils.getFlyoutAttributes)(_objectSpread(_objectSpread({}, middlewareData), floatingData))), children, arrowConfig && /*#__PURE__*/_react.default.createElement(Arrow, (0, _extends2.default)({
    ref: arrowRef
  }, middlewareData)));

  return portalElem ? /*#__PURE__*/_reactDom.default.createPortal(flyout, portalElem) : flyout;
}

Flyout.propTypes = {
  /** Reference to a DOM element where the flyout should be visually attached. The flyout will not render without this */
  anchorRef: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.shape({
    current: _propTypes.default.object
  })]),

  /** Determines if an arrow should be included on the flyout, if a string is provided, set the size of the arrow */
  arrow: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.string]),

  /** Children to render within the flyout */
  children: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.node), _propTypes.default.node]),

  /** Id for the flyout, used for accessibility */
  id: _propTypes.default.string,

  /** Placement, for more details see https://floating-ui.com/ */
  placement: _propTypes.default.oneOf(UX_FLYOUT_PLACEMENTS),

  /** Sets the strategy for @floating-ui (absolute/fixed) */
  strategy: _propTypes.default.oneOf(['absolute', 'fixed']),

  /** Role for the flyout, used for accessibility */
  role: _propTypes.default.string,

  /** Fires when the user attempts to escape from the flyout */
  onClose: _propTypes.default.func,

  /** Fires when the flyout position changes */
  onPlacement: _propTypes.default.func,

  /** Stretches the flyout to the nearest relative ancestor */
  stretch: _propTypes.default.bool,

  /** Optional class name for positioning */
  className: _propTypes.default.string,

  /** Optional releact element to create a react portal from  */
  portalElem: _propTypes.default.object
};
Flyout.displayName = 'Flyout';
var _default = Flyout;
exports.default = _default;