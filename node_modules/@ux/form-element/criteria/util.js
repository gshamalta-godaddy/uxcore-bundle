"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combineFunctions = combineFunctions;
exports.detach = detach;
exports.isElementOfComponentType = isElementOfComponentType;

/**
 * Checks if a React element is or inherits from React component.
 *
 * @param {ReactElement} element The element instance
 * @param {ReactComponent} component The target component
 * @returns {Boolean} Result
 * @private
 */
function isElementOfComponentType(element, component) {
  return element.type === component || element.type.prototype instanceof component;
}
/**
 * Takes two functions and combines them into one.
 *
 * @param {Function} funcA First function
 * @param {Function} funcB Second function
 * @returns {Function} Resulting function
 */


function combineFunctions(funcA, funcB) {
  if (typeof funcA !== 'function') {
    throw new Error('First argument is not a function');
  }

  if (typeof funcB !== 'function') {
    throw new Error('Second argument is not a function');
  }

  return function () {
    funcA(...arguments);
    funcB(...arguments);
  };
}
/**
 * Takes an object and names of properties to extract into new object.
 * Results in the extracted object and an object with the remaining properties.
 *
 * @param {Object} obj The target object.
 * @param {...String} args Names of properties to detach.
 * @returns {[Object,Object]} Resulting objects in array
 */


function detach(obj) {
  const a = {};
  const b = {};
  const keys = Object.keys(obj);

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  args.filter(arg => keys.indexOf(arg) >= 0).map(k => a[k] = obj[k]);
  keys.filter(k => !a[k]).map(k => b[k] = obj[k]);
  return [a, b];
}