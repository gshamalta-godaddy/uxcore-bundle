"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _criteria = _interopRequireDefault(require("./criteria"));

var _util = require("./util");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * Names of FormElement events to wire up.
 *
 * @type {string[]}
 * @private
 */
const EVENT_PROPS = ['onChange', 'onFocus', 'onBlur', 'onValidation'];
/**
 * Component used to wire up Criteria to components which inherit from FormElement.
 *
 * @displayName Connect
 *
 * @class Connect
 * @public
 */

class Connect extends _react.Component {
  constructor() {
    super(...arguments);
    this.state = _objectSpread(_objectSpread({}, this.sate), {}, {
      value: '',
      visible: false,
      isValid: false,
      hadInput: false
    });
    this._setupInput = this._setupInput.bind(this);
    this._setupCriteria = this._setupCriteria.bind(this);
    this._onValidChangeHandler = this._onValidChangeHandler.bind(this);
    this._onChangeHandler = this._onChangeHandler.bind(this);
    this._onValidationHandler = this._onValidationHandler.bind(this);
    this._onFocusHandler = this._onFocusHandler.bind(this);
    this._onBlurHandler = this._onBlurHandler.bind(this);
  }
  /**
   * React lifecycle hook invoked when component is about to mount.
   *
   * @private
   */


  componentDidMount() {
    if ('value' in this.props.children[0].props) {
      this.setState({
        value: this.props.children[0].props.value
      });
    }

    if (this.props.forceValidation) {
      this.setState({
        hadInput: this.props.forceValidation
      });
    }
  }
  /**
   * Callback used when FormElement input value is updated.
   *
   * @param {any} value Value to validate against.
   * @private
   */


  _onValidationHandler(value) {
    this.setState({
      value: value,
      hadInput: true
    });
  }
  /**
   * Callback used when FormElement input value changes.
   *
   * @param {Object} evt Change event.
   * @private
   */


  _onChangeHandler(evt) {
    this.setState({
      value: evt.target.value,
      hadInput: true
    });
  }
  /**
   * Callback used when FormElement gains focus.
   *
   * @private
   */


  _onFocusHandler() {
    this.setState({
      visible: true
    });
  }
  /**
   * Callback used when FormElement loses focus.
   *
   * @private
   */


  _onBlurHandler() {
    setTimeout(() => {
      this.setState({
        visible: false
      });
    }, 250);
  }
  /**
   * Callback used when Criteria changes valid state.
   *
   * @param {Boolean} name Name of the Criteria.
   * @param {Boolean} isValid Valid state of Criteria.
   * @private
   */


  _onValidChangeHandler(name, isValid) {
    this.setState({
      isValid
    });
  }
  /**
   * Wires up callbacks to the FormElement.
   *
   * @param {ReactElement} element FormElement.
   * @returns {ReactElement} wired up FormElement.
   * @private
   */


  _setupInput(element) {
    const self = this;
    const state = self.state;
    const {
      validate
    } = element.props;
    const props = {}; //
    // If this component has ever had focus then validation
    // should be run. Otherwise, if it has never had user interaction
    // it should be displayed as valid even if it is invalid.
    //

    if (state.hadInput) {
      let valid = state.isValid;

      if (typeof validate === 'function') {
        valid = valid && validate(state.value);
      }

      props.validates = valid;
    } //
    // If we are visible then pass alone the `open` class to the form
    // element associated with this instance.
    //


    if (state.visible && (!self.props.enableModern || !state.isValid)) {
      props.className = 'open';
    }

    EVENT_PROPS.forEach(method => {
      if (typeof element.props[method] === 'function') {
        props[method] = (0, _util.combineFunctions)(element.props[method], self[`_${method}Handler`]);
      } else {
        props[method] = self[`_${method}Handler`];
      }
    });
    return /*#__PURE__*/_react.default.cloneElement(element, props);
  }
  /**
   * Wires up callbacks to the Criteria component.
   *
   * @param {ReactElement} element Criteria element.
   * @returns {ReactElement} wired up Criteria.
   * @private
   */


  _setupCriteria(element) {
    const props = this.props;
    const state = this.state;
    return /*#__PURE__*/_react.default.cloneElement(element, {
      standalone: false,
      value: state.value,
      visible: state.visible,
      enableModern: props.enableModern,
      onValidChange: typeof element.props.onValidChange === 'function' ? (0, _util.combineFunctions)(element.props.onValidChange, this._onValidChangeHandler) : this._onValidChangeHandler
    });
  }
  /**
   * Renders the component.
   *
   * @returns {React.DOM} Rendered form element.
   * @private
   */


  render() {
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "ux-criteria-connect"
    }, this._setupInput(this.props.children[0]), this._setupCriteria(this.props.children[1]));
  }
  /**
   * PropType check that make sure child components are correct type and order.
   *
   * @param {Array} props Props
   * @param {String} propName Name of prop
   * @param {String} componentName Name of component
   * @returns {*} null or Error if invalid children
   * @private
   */


  static childrenPropTypes(props, propName, componentName) {
    const _children = _react.default.Children.toArray(props[propName]);

    if (_children.length !== 2) {
      return new Error(`${componentName} may only have 2 child components`);
    }

    const input = _children[0];
    const criteria = _children[1];

    if (!input.props.label && !input.props.placeholder) {
      return new Error(`${componentName} must have a FormElement component as the first child`);
    }

    if (!(0, _util.isElementOfComponentType)(criteria, _criteria.default)) {
      return new Error(`${componentName} must have a Criteria component as second child`);
    }

    return null;
  }

}
/**
 * PropType validation.
 *
 * @type {Object}
 * @private
 */


exports.default = Connect;
Connect.propTypes = {
  /** The child elements */
  children: Connect.childrenPropTypes,

  /** Whether validation should be performed on initial mount */
  forceValidation: _propTypes.default.bool,

  /** Enable control animations and absolute positioning.
   * This should be avoided unless your app/site is experiencing
   * major issues as this will be removed shortly.  */
  enableModern: _propTypes.default.bool
};
Connect.defaultProps = {
  enableModern: true
};