"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _button = _interopRequireDefault(require("@ux/button"));

var _index = _interopRequireDefault(require("../lib/index.js"));

var _classNames = _interopRequireDefault(require("@ux/component-utilities/lib/classNames"));

var _useClickOutsideHoc = _interopRequireDefault(require("@ux/component-utilities/lib/use-click-outside-hoc"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * CountryDropdown renders the country selector dropdown for the TelephoneInput
 * @displayName CountryDropdown
 * @class CountryDropdown
 *
 */
class CountryDropdown extends _react.PureComponent {
  /**
   * Render the country dropdown
   *
   * @returns {React.DOM} rendered component
   * @private
   */
  render() {
    const {
      countryData,
      onCountrySelect,
      activeClassName
    } = this.props;
    const selected = this.props.selectedCountry;

    const onSelectedClick = event => onCountrySelect(event, selected);

    return /*#__PURE__*/_react.default.createElement("ul", {
      id: "phoneCountryList",
      className: "dropdown-menu dropdown-menu-items",
      role: "menu"
    }, /*#__PURE__*/_react.default.createElement("div", {
      id: selected.countryKey,
      key: selected.countryKey,
      role: "presentation",
      className: activeClassName,
      onClick: onSelectedClick
    }, /*#__PURE__*/_react.default.createElement("a", {
      role: "menuitem",
      href: '#' + selected.countryKey
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "country-id"
    }, selected.countryKey, " "), /*#__PURE__*/_react.default.createElement("span", {
      className: "country-name"
    }, selected.label, " "), /*#__PURE__*/_react.default.createElement("span", {
      className: "dial-code"
    }, '+' + selected.callingCode, " "))), countryData.map(country => {
      if (country.countryKey === selected.countryKey) {
        return;
      }

      const onClick = event => onCountrySelect(event, country);

      return /*#__PURE__*/_react.default.createElement("div", {
        id: country.countryKey,
        key: country.countryKey,
        role: "presentation",
        className: "dropdown-item",
        onClick: onClick
      }, /*#__PURE__*/_react.default.createElement("a", {
        role: "menuitem",
        href: '#' + country.countryKey
      }, /*#__PURE__*/_react.default.createElement("span", {
        className: "country-id"
      }, country.countryKey, " "), /*#__PURE__*/_react.default.createElement("span", {
        className: "country-name"
      }, country.label, " "), /*#__PURE__*/_react.default.createElement("span", {
        className: "dial-code"
      }, '+' + country.callingCode, " ")));
    }));
  }

}

CountryDropdown.propTypes = {
  /** An array of countries and their associated calling data. */
  countryData: _propTypes.default.array.isRequired,

  /** Selected country object which will render first in the dropdown list before the rest of countryData. */
  selectedCountry: _propTypes.default.object.isRequired,

  /** Styles applied for the active item */
  activeClassName: _propTypes.default.string.isRequired,

  /** Handle country selection, update the phone number with the calling code and notify the parent of the change */
  onCountrySelect: _propTypes.default.func.isRequired
};
const phoneRegEx = /^\+([0-9]){1,3}\.([0-9]){6,14}$/;
const maxLength = 17;
/**
 * TelephoneInput renders a component with country calling code selector
 *
 * @displayName TelephoneInput
 * @class TelephoneInput
 */

class TelephoneInput extends _react.Component {
  // eslint-disable-next-line max-statements
  constructor(props) {
    super(props);
    const {
      countryKey,
      phoneNumber,
      countryData,
      marketId,
      presorted
    } = props;
    const countryDataProps = Array.isArray(countryData) && countryData.length && this.sortCountryData(countryData, marketId, presorted) || [{
      countryKey: 'US',
      label: 'United States',
      callingCode: '1'
    }];
    const normalizedCountryData = this.normalizeCountryData(countryDataProps);
    const parsedPhoneNumber = this.parsePhoneNumber(phoneNumber);
    const phoneCountryKey = this.getCountryKeyFromCallingCode(parsedPhoneNumber.callingCode, countryKey, normalizedCountryData);
    const countryCallingCode = this.getCallingCodeFromCountryKey(countryKey, countryDataProps);
    this.state = {
      showCountryList: false,
      callingCode: parsedPhoneNumber.callingCode || countryCallingCode,
      lineNumber: parsedPhoneNumber.lineNumber,
      countryKey: phoneCountryKey || countryKey,
      countryData: countryDataProps,
      normalizedCountryData,
      hadInput: false,
      inputError: false
    };
    this.onInputBlur = this.onInputBlur.bind(this);
    this.onInputFocus = this.onInputFocus.bind(this);
    this.onInputChange = this.onInputChange.bind(this);
    this.onInputKeyDown = this.onInputKeyDown.bind(this);
    this.onOutsideClick = this.onOutsideClick.bind(this);
    this.onCountryClick = this.onCountryClick.bind(this);
    this.onCountrySelect = this.onCountrySelect.bind(this);
    this.phoneControl = /*#__PURE__*/_react.default.createRef();
  }
  /**
   * After component mounts, call the onChangeHandler for initial validation
   *
   * @returns {void}
   * @private
   */


  componentDidMount() {
    const {
      phoneNumber,
      countryKey
    } = this.props;
    const event = document.createEvent('Event');
    this.props.onChangeHandler(event, phoneNumber, this.validatePhoneNumber(phoneNumber), countryKey);
  }
  /**
   * Focus on input when callingCode change. On Android devices, check
   * to see if the boundary of the selection is less than the calling code
   * prefix. If it is then force cursor to the end.
   *
   * @param {Object} prevProps - previous props
   * @param {Object} prevState - previous state
   * @returns {void}
   * @private
   */

  /* eslint-disable-next-line max-statements, complexity */


  componentDidUpdate(prevProps, prevState) {
    const props = this.props;
    const updates = {};
    const {
      elements: {
        input
      }
    } = this.phoneInput;

    if (!prevState.callingCode && prevState.callingCode !== this.state.callingCode) {
      input.focus();
    } //
    // **ANDROID MOBILE ONLY FIX** Force the cursor to the end of the input
    // if the selectionStart is less than the calling code prefix.
    //


    const {
      lineNumber,
      callingCode
    } = this.state;

    if (lineNumber && callingCode && input.selectionStart < `+${callingCode}.`.length) {
      const phoneNumber = this.state.phoneNumber || this.buildPhoneNumber(callingCode, lineNumber) || '';
      input.selectionStart = input.selectionEnd = phoneNumber.length;
    }

    if (!lineNumber && props.countryKey !== prevProps.countryKey) {
      updates.countryKey = props.countryKey;
      updates.callingCode = this.getCallingCodeFromCountryKey(props.countryKey);
    }

    if (prevProps.phoneNumber !== props.phoneNumber) {
      const parsedNumber = this.parsePhoneNumber(props.phoneNumber);
      const phoneNumber = this.buildPhoneNumber(parsedNumber.callingCode, parsedNumber.lineNumber);
      updates.callingCode = parsedNumber.callingCode;
      updates.lineNumber = parsedNumber.lineNumber;
      updates.phoneNumber = phoneNumber;
    }

    if (props.countryData && props.countryData !== prevProps.countryData) {
      const marketId = props.marketId || prevProps.marketId;
      updates.countryData = this.sortCountryData(props.countryData, marketId, props.presorted);
    }

    if (prevProps.countryData !== props.countryData) {
      updates.normalizedCountryData = this.normalizeCountryData(updates.countryData);
    }

    if (Object.keys(updates).length) {
      this.setState(updates);
    }
  }
  /**
   * Sort the countries by label
   *
   * @param {array} data - data from api
   * @param {string=} marketId - BCP-47 language string to use as locale when comparing entries, defaults to 'en-US'
   * @param {bool=} presorted - indicates if data is already sorted, defaults to false
   * @returns {string} marketId
   * @public
   */


  sortCountryData(data) {
    let marketId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
    let presorted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (presorted) {
      return data;
    }

    return data.slice().sort(function (a, b) {
      return a.label.localeCompare(b.label, marketId);
    });
  }
  /**
   * Compose a complete phone number from the calling code and line number
   *
   * @param {number} callingCode - Country callingCode
   * @param {string} lineNumber - Phone number
   * @returns {string} Complete phone number
   * @public
   */


  buildPhoneNumber(callingCode, lineNumber) {
    let phoneNumber = '';

    if (callingCode) {
      phoneNumber += '+' + callingCode + '.';
    }

    if (lineNumber) {
      phoneNumber += lineNumber;
    }

    return phoneNumber;
  }
  /**
   * Find the country by calling code
   *
   * @param {string} countryKey Country key
   * @param {array} dataset Optional dataset to use.
   * @returns {number} callingCode
   * @public
   */


  getCallingCodeFromCountryKey(countryKey, dataset) {
    const countryData = dataset || this.state.countryData || [];
    let callingCode = null;

    for (let i = countryData.length; i--;) {
      if (countryData[i].countryKey === countryKey) {
        callingCode = countryData[i].callingCode;
        break;
      }
    }

    return callingCode;
  }
  /**
   * Find the country by calling code.
   * FYI: If there are multiple countries with the same code,
   * it will return the first one.
   *
   * @param {number} callingCode Country callingCode
   * @param {string} countryKey Current country key
   * @param {array} normalizedCountryData Optional dataset to use.
   * @returns {string} countryKey
   * @public
   */


  getCountryKeyFromCallingCode(callingCode, countryKey, normalizedCountryData) {
    if (!countryKey) countryKey = this.state.countryKey;

    if (!normalizedCountryData) {
      normalizedCountryData = this.state.normalizedCountryData || this.normalizeCountryData();
    }

    if (callingCode && normalizedCountryData[callingCode]) {
      if (normalizedCountryData[callingCode].indexOf(countryKey) < 0) {
        countryKey = normalizedCountryData[callingCode][0];
      }
    }

    return countryKey;
  }
  /**
   * Normalize country data by calling code. Ensure US is first for calling
   * code 1.
   *
   * @param {Array} countryData Data to normalize
   * @returns {Object} Normalized country data by calling code
   * @private
   */


  normalizeCountryData(countryData) {
    countryData = countryData || this.state.countryData;
    const normalizedCountryData = {
      1: ['US']
    };

    if (Array.isArray(countryData)) {
      for (let i = countryData.length - 1; i >= 0; i--) {
        const country = countryData[i];

        if (country.countryKey !== 'US') {
          const callingCode = country.callingCode;

          if (!normalizedCountryData[callingCode]) {
            normalizedCountryData[callingCode] = [];
          }

          normalizedCountryData[callingCode].push(country.countryKey);
        }
      }
    }

    return normalizedCountryData;
  }
  /**
   * Handle the country dropdown click
   *
   * @returns {void}
   * @private
   */


  onCountryClick() {
    const show = this.state.showCountryList;
    this.setState({
      showCountryList: !show
    });
  }
  /**
   * Handle country selection, update the phone number with the calling code
   * and notify the parent of the change
   *
   * @param {Object} event - Event for click
   * @param {Object} country - Country object being clicked
   * @returns {void}
   */


  onCountrySelect(event, country) {
    // added to avoid issues with hash routing.
    event.preventDefault();
    const newNumber = this.buildPhoneNumber(country.callingCode, this.state.lineNumber);
    this.setState({
      phoneNumber: newNumber,
      countryKey: country.countryKey,
      callingCode: country.callingCode,
      showCountryList: false
    });
    this.props.onChangeHandler(event, newNumber, this.validatePhoneNumber(newNumber), country.countryKey);
  }
  /**
   * Handle clicking on the document to determine if the country list should be hidden
   *
   * @param {Object} event - Event for click
   * @param {Function} fn - listener for click event
   * @private
   */


  onOutsideClick(event, fn) {
    if (this.state.showCountryList) {
      this.setState({
        outsideListener: fn,
        showCountryList: false
      });
    }
  }
  /**
   * Handle keyboard input change, look up country, render the new phone number
   *
   * @param {Object} event - Event for KeyDown
   * @returns {void}
   * @private
   */


  onInputChange(event) {
    const newValue = event.target.value;
    const parsedPhoneNumber = this.parsePhoneNumber(newValue);
    const countryKey = this.getCountryKeyFromCallingCode(parsedPhoneNumber.callingCode);
    const callingCode = parsedPhoneNumber.callingCode || this.getCallingCodeFromCountryKey(countryKey);
    const newNumber = this.buildPhoneNumber(callingCode, parsedPhoneNumber.lineNumber);
    let hadInput = this.state.hadInput;

    if (this.props.required && !this.state.hadInput) {
      hadInput = true;
    }

    this.setState({
      lineNumber: parsedPhoneNumber.lineNumber,
      phoneNumber: newNumber,
      callingCode,
      countryKey,
      hadInput
    });
    this.props.onChangeHandler(event, newNumber, this.validatePhoneNumber(newNumber), countryKey);
  }
  /**
   * Handle input blur, remove calling code from input if no line number is provided
   *
   * @returns {void}
   * @private
   */


  onInputBlur() {
    const callingCode = this.buildPhoneNumber(this.state.callingCode);
    const phoneInput = this.phoneInput.elements.input.value || '';
    const inputError = this.props.required && this.state.hadInput && phoneInput === '';

    if (phoneInput === callingCode) {
      this.setState({
        lineNumber: null,
        inputError
      });
    }
  }
  /**
   * Handle input focus, hide the country list, populate calling code if empty
   *
   * @param {Object} event - Event for Focus
   * @returns {void}
   * @private
   */


  onInputFocus() {
    const updated = {
      showCountryList: false,
      inputError: false
    };

    if (this.phoneInput.elements.input.value === '') {
      updated.callingCode = this.getCallingCodeFromCountryKey(this.state.countryKey);
    }

    this.setState(updated);
  }
  /**
   * Handle input key down, if down arrow key, show country list
   *
   * @param {Object} event - Event for KeyDown
   * @returns {void}
   * @private
   */

  /* eslint-disable-next-line max-statements, complexity */


  onInputKeyDown(event) {
    let key = event.key;
    const safelistKeys = ['Backspace', 'ArrowLeft', 'ArrowRight', 'ArrowDown', 'Delete', 'Tab']; //
    // Safari@10.1 workaround (and perhaps others), which is lacking a `key` identifiers. This maps each number to
    // their actual value, keys from the safelist are properly identified.
    //

    if (key === 'Unidentified') key = event.keyCode - 48;
    const safeModifierKeys = event.ctrlKey || event.metaKey;

    if (!/^[0-9]$/.test(key) && !safeModifierKeys && !~safelistKeys.indexOf(key)) {
      event.preventDefault();
    } //
    // If key is backspace or delete handle the deletion of characters from index to left
    // and then items right of index and left
    //


    if (key === 'Backspace' || key === 'Delete') {
      const directionModifier = key === 'Delete';
      const {
        value,
        selectionStart,
        selectionEnd
      } = event.target;
      const selection = value.substring(selectionStart, selectionEnd);
      const firstPeriodPos = value.indexOf('.') + 1;

      if (firstPeriodPos) {
        const noSelectionBeforeDot = selectionStart + directionModifier <= firstPeriodPos && selectionStart === selectionEnd;
        const cursorBeforeDotNotFullSel = selectionStart + directionModifier < firstPeriodPos && selection !== value;
        const dotSelectedButNotFullSel = ~selection.indexOf('.') && selection !== value;

        if (noSelectionBeforeDot || cursorBeforeDotNotFullSel || dotSelectedButNotFullSel) {
          event.preventDefault();
        }
      }
    }

    if (!this.state.showCountryList && key === 'ArrowDown') {
      this.setState({
        showCountryList: true
      });
    }
  }
  /**
   * Parse the phone number to determine the calling code and line number
   *
   * @param {string} phoneNumber - Phone number to be parsed
   * @returns {Object} callingCode and lineNumber
   * @public
   */


  parsePhoneNumber(phoneNumber) {
    let callingCode = null;
    let lineNumber = phoneNumber;

    if (phoneNumber && phoneNumber[0] === '+') {
      phoneNumber = phoneNumber.replace('+', '');
      const dotIndex = phoneNumber.indexOf('.');

      if (dotIndex > 0) {
        callingCode = phoneNumber.substring(0, dotIndex);
        lineNumber = phoneNumber.substring(dotIndex + 1);
      }
    }

    return {
      callingCode: callingCode,
      lineNumber: lineNumber
    };
  }
  /**
   * Validate the phone number passes the is required check and regex check
   *
   * @param {string} phoneNumber - Phone number to be parsed
   * @returns {boolean} Does phone number pass regEx text
   * @public
   */


  validatePhoneNumber(phoneNumber) {
    let isValid = true;
    const {
      isRequired
    } = this.props;
    const isEmpty = !phoneNumber || phoneNumber.length === 0;

    if (isRequired) {
      isValid = !isEmpty;
    }

    if (isValid && (isRequired || !isRequired && !isEmpty)) {
      isValid = phoneRegEx.test(phoneNumber);
    }

    return isValid;
  }
  /**
   * Gets the countryData item that should be selected.
   * RIf countryKey is not in data, returns US data or first item in list
   * @returns {Object} countryData item that should be selected
   * @private
   */


  getSelectedCountry() {
    const {
      countryKey,
      countryData
    } = this.state;
    const selectedCountry = countryData.filter(country => country.countryKey === countryKey)[0];

    if (!selectedCountry) {
      if (!countryData.some(country => country.countryKey === 'US')) {
        return countryData[0];
      }

      return {
        callingCode: '1',
        countryKey: 'US',
        label: 'United States'
      };
    }

    return selectedCountry;
  }
  /**
   * Render the country list
   * @param {Object} selected The item that should render as selected
   * @param {string} selected.countryKey The selected item's country key
   * @param {string} selected.callingCode The selected item's calling code
   * @returns {ReactElement} rendered country menu list
   */


  renderCountryList(selected) {
    const {
      showCountryList,
      countryData
    } = this.state;
    const classes = (0, _classNames.default)('dropdown', 'ux-select-dropdown', 'ux-tel-container', {
      open: showCountryList
    });
    return /*#__PURE__*/_react.default.createElement("div", {
      style: {
        top: 'inherit'
      },
      className: classes
    }, /*#__PURE__*/_react.default.createElement(CountryDropdown, {
      selectedCountry: selected,
      activeClassName: "dropdown-item active",
      onCountrySelect: this.onCountrySelect,
      countryData: countryData
    }));
  }
  /**
   * Render the phone component
   *
   * @returns {React.DOM} rendered component
   * @private
   */


  render() {
    const {
      name,
      placeholderText,
      id
    } = this.props;
    const {
      callingCode,
      lineNumber
    } = this.state;
    const phoneNumber = lineNumber ? this.buildPhoneNumber(callingCode, lineNumber) : '';
    const selectedCountry = this.getSelectedCountry();
    const countryList = this.renderCountryList(selectedCountry);
    const keyCode = `${selectedCountry.countryKey} +${selectedCountry.callingCode}`;
    return /*#__PURE__*/_react.default.createElement(_useClickOutsideHoc.default, {
      targetRef: this.phoneControl,
      onClick: this.onOutsideClick
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: "form-group",
      ref: this.phoneControl
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: "ux-tel-container"
    }, /*#__PURE__*/_react.default.createElement(_button.default, {
      className: (0, _classNames.default)('ux-tel-btn', {
        'ux-tel-btn-danger': this.state.inputError
      }),
      id: "basic-addon1",
      onClick: this.onCountryClick,
      as: "select",
      text: keyCode
    }), /*#__PURE__*/_react.default.createElement(_index.default, {
      className: "form-control ctHidden ux-tel-input",
      name: name,
      id: id,
      maxLength: maxLength,
      onBlur: this.onInputBlur,
      onChange: this.onInputChange,
      onFocus: this.onInputFocus,
      onKeyDown: this.onInputKeyDown,
      placeholder: placeholderText,
      label: this.props.label,
      required: this.props.required,
      value: phoneNumber,
      ref: input => {
        this.phoneInput = input;
      },
      type: "tel"
    })), countryList));
  }

}

exports.default = TelephoneInput;
TelephoneInput.propTypes = {
  /** An array of countries and their associated calling data. */
  countryData: _propTypes.default.array.isRequired,

  /** The current country. Default is US */
  countryKey: _propTypes.default.string.isRequired,

  /** Id of the input field */
  id: _propTypes.default.string,

  /** If true, indicates a required field */
  isRequired: _propTypes.default.bool,

  /** The label for the Form element */
  label: _propTypes.default.node,

  /** The current market. Default is en-US */
  marketId: _propTypes.default.string.isRequired,

  /** name of the input, useful for form auto completion. Default is phone */
  name: _propTypes.default.string,

  /** Handles initial validation after component mounts, and handles input changes */
  onChangeHandler: _propTypes.default.func.isRequired,

  /** Current phone number with callingCode and lineNumber */
  phoneNumber: _propTypes.default.string,

  /** Text in form field before user input */
  placeholderText: _propTypes.default.string,

  /** If true, the component will not attempt to sort the countryData array. */
  presorted: _propTypes.default.bool,

  /**
   * A boolean or string to indicate if the input field is required. If
   * a string is provided, it will be used as the error message.
   */
  required: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.node])
};
TelephoneInput.defaultProps = {
  isRequired: false,
  name: 'phone',
  presorted: false
};