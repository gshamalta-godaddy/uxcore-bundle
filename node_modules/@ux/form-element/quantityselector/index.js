"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _id2 = _interopRequireDefault(require("@ux/component-utilities/lib/id"));

var _classNames = _interopRequireDefault(require("@ux/component-utilities/lib/classNames"));

var _button = _interopRequireDefault(require("@ux/button"));

var _plus = _interopRequireDefault(require("@ux/icon/plus"));

var _minus = _interopRequireDefault(require("@ux/icon/minus"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

//
// Reusable regular expression for numeric validation.
//
const isNumber = /^(0|[1-9][0-9]*)$/;
/**
* Default aria-labels
*/

const DEFAULT_ARIA_LABELS = {
  increment: 'Add',
  decrement: 'Subtract',
  label: 'Choose how many'
};
/**
 * React component that renders the QuantitySelector. Expect a
 * minimum value, a maximum value and a default value.
 *
 * @displayName Quantity Selector
 * @class QuantitySelector
 *
 * @public
 */

class QuantitySelector extends _react.Component {
  constructor(props) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    super(props, ...args);
    this._onChange = this._onChange.bind(this);
    this._onKeydown = this._onKeydown.bind(this);
    this.getId = this.getId.bind(this);
    this.decrease = this.step.bind(this, -1);
    this.increase = this.step.bind(this, 1);
    this.state = {
      id: this.getId(),
      value: this._safeDefaultValue(props.defaultValue, props)
    };
  }
  /**
   * Sources the component id, first from the id prop, and then from the supplied label
   * component. If neither of those exist, an empty string is returned.
   *
   * @returns {string} computed id for the component
   *
   * @public
   */


  getId() {
    const {
      id,
      label
    } = this.props;
    if (id) return id;else if (label) {
      return /*#__PURE__*/_react.default.isValidElement(label) // If the label is a React element with an `id` prop...
      ? label.props.id // use its `id` prop; otherwise...
      : (0, _id2.default)('label', {
        props: this.props
      }); // generate an `id` from it
    }
    return '';
  }
  /**
   * Attempts to increase the quanity `by` the specified value. If
   * the current value is invalid or the empty string set the value to
   * min if attempting to decrease and max if attempting to increase.
   *
   * @param {number} by Amount to increase by
   * @returns {void}
   *
   * @public
   */


  step(by) {
    const {
      max,
      min
    } = this.props;
    const {
      isError,
      value
    } = this.state;
    const invalid = value > max || value < min || isError === true;
    let nextValue;

    if (value === '' || invalid) {
      nextValue = by === -1 ? min : max;
      return this._setValue(nextValue, true);
    }

    nextValue = value + by;
    if (nextValue < min) nextValue = min;
    if (nextValue > max) nextValue = max;

    this._setValue(nextValue, nextValue <= max && nextValue >= min && isError !== true);
  }
  /**
   * Handles the DOM change event from the text input on this instance.
   * we perform our own pattern matching here because we want the numeric
   * keypad when on mobile, but need the actual value change.
   *
   * @param {Event} evt DOM 'change' event.
   * @returns {void}
   *
   * @private
   */


  _onChange(evt) {
    if (evt && evt.target) {
      const value = evt.target.value;

      if (value === '') {
        return this._setValue(value, true);
      }

      if (isNumber.test(value)) {
        return this._checkRange(parseInt(value, 10));
      }

      this._setValue(value);
    }
  }
  /**
   * Handles the keyboard events to increment or decrement this instance.
   * @param {Event} e Keyboard input event from the browser.
   *
   * @private
   */


  _onKeydown(e) {
    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
      e.preventDefault();
      e.stopPropagation();
      this.step(e.key === 'ArrowUp' ? 1 : -1);
    }
  }
  /**
   * Attempts to determine if the value if valid or invalid
   *
   * @param {number} value Desired next value for this component.
   * @returns {void}
   *
   * @private
   */


  _checkRange(value) {
    const {
      max,
      min
    } = this.props;
    return this._setValue(value, value <= max && value >= min);
  }
  /**
   * Returns the value to update the internal state for this instance based on
   * the given `defaultValue`.
   *
   * @param {number} defaultValue Next default value to set.
   * @param {Object} props Current props to set on this instance.
   * @returns {number} Range-safe defaultValue to be used in initial state or `setState`.
   *
   * @private
   */


  _safeDefaultValue(defaultValue, props) {
    const {
      max,
      min,
      onChange
    } = props;
    const noDefault = typeof defaultValue === 'undefined';
    let value = noDefault ? this.state && this.state.value || min : defaultValue; //
    // Remark (indexzero): should we police for negative min and/or max values?
    //

    if (typeof value === 'number') {
      if (value > max) value = max;
      if (value < min) value = min;
    }

    if (onChange && !noDefault) {
      onChange(value, true);
    }

    return value;
  }
  /**
   * Explicitly sets the value and removes any error state that might
   * exist. This method performs no validation and assumes the value
   * to be validated already.
   *
   * @param {number} value Next value for this component.
   * @param {boolean} isValid Value indicating if the value provided is valid.
   *
   * @private
   */


  _setValue(value, isValid) {
    const {
      onChange
    } = this.props;
    const nextState = {
      value,
      isError: true
    };

    if (isValid) {
      nextState.isError = null;
    }

    if (onChange) {
      onChange(value, isValid || false);
    }

    this.setState(nextState);
  }
  /**
   * Ensure that if a new `defaultValue` is provided update all state accordingly
   * @param  {Object} prevProps Previous set of properties set on this instance.
   */


  componentDidUpdate(prevProps) {
    if (this.props.defaultValue !== prevProps.defaultValue) {
      this.setState({
        value: this._safeDefaultValue(this.props.defaultValue, this.props)
      });
    }
  }
  /**
   * Render the QuantitySelector. Depending on the value the "-" and "+" buttons will
   * be disabled.
   *
   * @returns {ReactElement} QuantitySelector with appropriate value.
   *
   * @private
   */


  render() {
    // eslint-disable-line complexity
    const {
      max,
      min,
      errorMessage,
      disabled,
      label,
      ariaLabels
    } = this.props;
    const {
      id,
      value,
      isError
    } = this.state;
    const invalid = isError || value > max || value < min;
    const classname = (0, _classNames.default)('ux-quantity-selector', {
      'has-danger': isError
    });
    return /*#__PURE__*/_react.default.createElement("div", {
      className: classname
    }, label && /*#__PURE__*/_react.default.createElement("label", {
      htmlFor: id,
      id: `label-${id}`
    }, label), /*#__PURE__*/_react.default.createElement("div", {
      className: "input-group form-control",
      "aria-labelledby": label ? `label-${id}` : null,
      "aria-label": !label ? ariaLabels.label : null,
      role: "spinbutton",
      tabIndex: "-1",
      onKeyDown: this._onKeydown,
      "aria-valuemin": min,
      "aria-valuemax": max,
      "aria-valuenow": value
    }, /*#__PURE__*/_react.default.createElement(_button.default, {
      design: "control",
      icon: /*#__PURE__*/_react.default.createElement(_minus.default, null),
      onClick: this.decrease,
      disabled: disabled || value !== '' && !invalid && value <= min,
      "aria-label": ariaLabels.decrement
    }), /*#__PURE__*/_react.default.createElement("input", {
      id: id,
      type: "tel",
      disabled: disabled,
      value: value,
      onChange: this._onChange,
      className: "ux-quantity-selector-text form-control"
    }), /*#__PURE__*/_react.default.createElement(_button.default, {
      design: "control",
      icon: /*#__PURE__*/_react.default.createElement(_plus.default, null),
      onClick: this.increase,
      disabled: disabled || value !== '' && !invalid && value >= max,
      "aria-label": ariaLabels.increment
    })), isError && /*#__PURE__*/_react.default.createElement("div", {
      className: "form-text form-error",
      role: "alert"
    }, errorMessage));
  }

}
/**
 * Default property values.
 *
 * @type {Object}
 *
 * @public
 */


exports.default = QuantitySelector;
QuantitySelector.defaultProps = {
  disabled: false,
  min: 0,
  ariaLabels: DEFAULT_ARIA_LABELS
};
/**
 * Property validation.
 *
 * @type {Object}
 *
 * @public
 */

QuantitySelector.propTypes = {
  /** Id for input control to associate a label with */
  id: _propTypes.default.string,

  /** Label component associated with the quantity selector */
  label: _propTypes.default.node,

  /** Change the value of the input field */
  onChange: _propTypes.default.func,

  /** Message when error happens */
  errorMessage: _propTypes.default.string.isRequired,

  /** Maximum number the quantity can be selected up to */
  max: _propTypes.default.number.isRequired,

  /** Minimum number the quantity can be selected down to */
  min: _propTypes.default.number,

  /** Default value of the input field */
  defaultValue: _propTypes.default.number,

  /** Sets the disabled state of the button */
  disabled: _propTypes.default.bool,

  /** Screenreader labels for sub-elements */
  ariaLabels: _propTypes.default.shape({
    /** Screen reader label for "increment" double left chevron button */
    increment: _propTypes.default.string,

    /** Screen reader label for "decrement" double left chevron button */
    decrement: _propTypes.default.string,

    /** Screen reader label for the quantity selector as a whole */
    label: _propTypes.default.string
  })
};
