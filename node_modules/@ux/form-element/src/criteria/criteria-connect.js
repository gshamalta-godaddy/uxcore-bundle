import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Criteria from './criteria';
import { isElementOfComponentType, combineFunctions } from './util';

/**
 * Names of FormElement events to wire up.
 *
 * @type {string[]}
 * @private
 */
const EVENT_PROPS = ['onChange', 'onFocus', 'onBlur', 'onValidation'];

/**
 * Component used to wire up Criteria to components which inherit from FormElement.
 *
 * @displayName Connect
 *
 * @class Connect
 * @public
 */
export default class Connect extends Component {
  constructor() {
    super(...arguments);

    this.state = {
      ...this.sate,
      value: '',
      visible: false,
      isValid: false,
      hadInput: false
    };

    this._setupInput = this._setupInput.bind(this);
    this._setupCriteria = this._setupCriteria.bind(this);
    this._onValidChangeHandler = this._onValidChangeHandler.bind(this);
    this._onChangeHandler = this._onChangeHandler.bind(this);
    this._onValidationHandler = this._onValidationHandler.bind(this);
    this._onFocusHandler = this._onFocusHandler.bind(this);
    this._onBlurHandler = this._onBlurHandler.bind(this);
  }

  /**
   * React lifecycle hook invoked when component is about to mount.
   *
   * @private
   */
  componentDidMount() {
    if ('value' in this.props.children[0].props) {
      this.setState({
        value: this.props.children[0].props.value
      });
    }

    if (this.props.forceValidation) {
      this.setState({
        hadInput: this.props.forceValidation
      });
    }
  }

  /**
   * Callback used when FormElement input value is updated.
   *
   * @param {any} value Value to validate against.
   * @private
   */
  _onValidationHandler(value) {
    this.setState({
      value: value,
      hadInput: true
    });
  }

  /**
   * Callback used when FormElement input value changes.
   *
   * @param {Object} evt Change event.
   * @private
   */
  _onChangeHandler(evt) {
    this.setState({
      value: evt.target.value,
      hadInput: true
    });
  }

  /**
   * Callback used when FormElement gains focus.
   *
   * @private
   */
  _onFocusHandler() {
    this.setState({
      visible: true
    });
  }

  /**
   * Callback used when FormElement loses focus.
   *
   * @private
   */
  _onBlurHandler() {
    setTimeout(() => {
      this.setState({
        visible: false
      });
    }, 250);
  }

  /**
   * Callback used when Criteria changes valid state.
   *
   * @param {Boolean} name Name of the Criteria.
   * @param {Boolean} isValid Valid state of Criteria.
   * @private
   */
  _onValidChangeHandler(name, isValid) {
    this.setState({
      isValid
    });
  }

  /**
   * Wires up callbacks to the FormElement.
   *
   * @param {ReactElement} element FormElement.
   * @returns {ReactElement} wired up FormElement.
   * @private
   */
  _setupInput(element) {
    const self = this;
    const state = self.state;
    const { validate } = element.props;
    const props = { };

    //
    // If this component has ever had focus then validation
    // should be run. Otherwise, if it has never had user interaction
    // it should be displayed as valid even if it is invalid.
    //
    if (state.hadInput) {
      let valid = state.isValid;

      if (typeof validate === 'function') {
        valid = valid && validate(state.value);
      }

      props.validates = valid;
    }

    //
    // If we are visible then pass alone the `open` class to the form
    // element associated with this instance.
    //

    if (state.visible && (!self.props.enableModern || !state.isValid)) {
      props.className = 'open';
    }

    EVENT_PROPS.forEach(method => {
      if (typeof element.props[method] === 'function') {
        props[method] = combineFunctions(element.props[method], self[`_${method}Handler`]);
      } else {
        props[method] = self[`_${method}Handler`];
      }
    });

    return React.cloneElement(element, props);
  }

  /**
   * Wires up callbacks to the Criteria component.
   *
   * @param {ReactElement} element Criteria element.
   * @returns {ReactElement} wired up Criteria.
   * @private
   */
  _setupCriteria(element) {
    const props = this.props;
    const state = this.state;

    return React.cloneElement(element, {
      standalone: false,
      value: state.value,
      visible: state.visible,
      enableModern: props.enableModern,
      onValidChange: typeof element.props.onValidChange === 'function' ?
        combineFunctions(element.props.onValidChange, this._onValidChangeHandler) : this._onValidChangeHandler
    });
  }

  /**
   * Renders the component.
   *
   * @returns {React.DOM} Rendered form element.
   * @private
   */
  render() {
    return (
      <div className='ux-criteria-connect'>
        { this._setupInput(this.props.children[0]) }
        { this._setupCriteria(this.props.children[1]) }
      </div>
    );
  }

  /**
   * PropType check that make sure child components are correct type and order.
   *
   * @param {Array} props Props
   * @param {String} propName Name of prop
   * @param {String} componentName Name of component
   * @returns {*} null or Error if invalid children
   * @private
   */
  static childrenPropTypes(props, propName, componentName) {
    const _children = React.Children.toArray(props[propName]);
    if (_children.length !== 2) {
      return new Error(
        `${componentName} may only have 2 child components`
      );
    }

    const input = _children[0];
    const criteria = _children[1];
    if (!input.props.label && !input.props.placeholder) {
      return new Error(
        `${componentName} must have a FormElement component as the first child`
      );
    }

    if (!isElementOfComponentType(criteria, Criteria)) {
      return new Error(
        `${componentName} must have a Criteria component as second child`
      );
    }

    return null;
  }
}

/**
 * PropType validation.
 *
 * @type {Object}
 * @private
 */
Connect.propTypes = {
  /** The child elements */
  children: Connect.childrenPropTypes,
  /** Whether validation should be performed on initial mount */
  forceValidation: PropTypes.bool,
  /** Enable control animations and absolute positioning.
   * This should be avoided unless your app/site is experiencing
   * major issues as this will be removed shortly.  */
  enableModern: PropTypes.bool
};

Connect.defaultProps = {
  enableModern: true
};
