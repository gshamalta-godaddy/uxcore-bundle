import React, { Component } from 'react';
import { propTypes, getValue, getType, getStateProperty } from './enums';
import _id from '@ux/component-utilities/lib/id';
import { Validates } from 'react-validation-context';
import PropTypes from 'prop-types';
import Textual from './textual';
import Flip from './flip';

const undef = void 0;

/**
 * Helper function to discover data to use.
 *
 * @param {String} name Name of the key to search.
 * @param {Array} dataset Data set to search
 * @param {Mixed} fallback Optional fallback data.
 * @returns {Any} The found result.
 * @private
 */
function find(name, dataset, fallback) {
  const data = dataset.filter(obj => typeof obj[name] !== 'undefined')[0];

  if (typeof data !== 'object') {
    return fallback;
  }

  return data[name];
}

/**
 * Base class that contains the validation logic for inputs
 *
 * @displayName FormElement
 *
 * @class Base
 * @public
 */
export default class Base extends Component {
  constructor(props) {
    super(...arguments);
    const required = this.select('required');

    this.state = {
      hadInput: !required || 'validates' in props || false
    };

    const type = this.select('type');
    this.isFlip = type === 'checkbox' || type === 'radio';

    this.ignoreProps = [];
    this.elements = {};

    this.clear = this.clear.bind(this);
    this.onChange = this.onChange.bind(this);
  }

  /**
   * React lifecycle hook invoked when component is mounted. Unless the overriding `validates`
   * property is present, initially load the Input as valid and only call `validating` on change.
   *
   * @private
   */
  componentDidMount() {
    const { props } = this;

    const required = this.select('required');

    if ('validates' in props || required) {
      this.validating(
        this.select('value'),
        this.select('validate'),
        (error, isValid) => {
          this.setState({
            isValid,
            error
          });
        }
      );
    }
  }

  /**
   * Handle state changes.
   *
   * @param {Object} prevProps previous this.props.
   * @param {Object} prevState previous this.state.
   */
  componentDidUpdate(prevProps, prevState) { // eslint-disable-line max-statements, complexity
    const nextProps = this.props;
    const lookups = [prevState, prevProps, this];

    if (
      'validates' in nextProps &&
      prevProps.validates !== nextProps.validates
    ) {
      const failure = nextProps.failure || find('failure', lookups);

      this.setState({
        error: failure && !nextProps.validates ? failure : null,
        isValid: nextProps.validates
      });
    }

    const nextValidate = nextProps.validate;
    const validate = find('validate', lookups);
    const value = nextProps.value || find('value', lookups);

    if (
      'value' in nextProps &&
      nextProps.value !== prevProps.value &&
      'onValidation' in nextProps
    ) {
      nextProps.onValidation(nextProps.value);
    }

    const failureMessage =
      nextProps.failure ||
      (typeof nextProps.required !== 'boolean' ? nextProps.required : undef);

    //
    // Only revalidate the value if both functions exist, are different and their return value is not equal.
    // This will ensure `validate` does not run if identical arrow or bound functions are passed
    // as properties, that are only distinct by memory reference.
    //
    if (nextValidate !== validate) {
      if (nextValidate && validate && nextValidate(value) === validate(value)) {
        return;
      }

      this.validating(value, nextProps.validate, (error, isValid) => {
        this.setState({
          isValid,
          error:
            isValid === false && prevState.error !== failureMessage
              ? failureMessage
              : error
        });
      });
    } else if (
      prevState.isValid === false &&
      prevState.error !== failureMessage
    ) {
      this.setState({
        error: failureMessage
      });
    }
  }

  /**
   * Clean up and merge the properties that can be passed to the internal input element.
   *
   * @param {Object} data Attributes.
   * @returns {Object} properties that can be spread,
   * @private
   */
  filter(data) {
    const props = this.props;
    const spread = Object.keys(props)
      .filter(
        v =>
          !(
            v in data ||
            v in propTypes.element ||
            this.ignoreProps.includes(v)
          )
      )
      .reduce((memo, key) => {
        memo[key] = props[key];
        return memo;
      }, {});

    if (
      this.isFlip &&
      typeof spread.checked !== 'undefined' &&
      typeof spread.defaultChecked !== 'undefined'
    ) {
      delete spread.defaultChecked;
    }

    return spread;
  }

  /**
   * Minor mock change handler that should be provided by the developer.
   *
   * @param {Event} event Change event.
   * @param {boolean=} isClear Is the input being cleared by the clear button, defaults to false
   * @private
   */
  onChange(event, isClear = false) {
    const property = !isClear ? getStateProperty(getType(event)) : 'value';
    const value = !isClear ? getValue(event) : this.state.value;
    const props = this.props;

    this.setState({
      hadInput: true
    });

    //
    // Check if the input validates and set state appropriately.
    //
    this.validating(value, this.select('validate'), (error, isValid) => {
      this.setState({
        isValid,
        error
      });

      //
      // Always call the provided onChange listener as developers might be
      // interested in doing additional validation against event.target.value.
      // Only call the default onChange mock if no value was explicitly passed
      // as property, this prevents duplicating value states.
      //
      if ('onChange' in props) props.onChange(event, value);
      if ('onValidation' in props) props.onValidation(value);
      if (!(property in props))
        this.setState({
          [property]: value
        });
    });
  }

  /**
   * Generate all the attributes to be rendered on an input.
   *
   * @returns {Object} Required data to render an input.
   * @private
   */
  attributes() {
    const { isValid, hadInput } = this.state;
    const defaultValue = this.select('defaultValue');
    let { id } = this.props;

    // If no `id` prop was specified, fall back to label
    if (!id) {
      const label = this.select('label');

      id = React.isValidElement(label) // If the label is a React element with an `id` prop... // use its `id` prop; otherwise...
        ? label.props.id
        : _id('label', { props: this.props }); // generate an `id` from it
    }

    const result = {
      id,
      type: this.select('type', 'text'),
      name: this.select('name'),

      //
      // For value, we want to prefer props over the state, as a provided value
      // prop will indicate that the user is controlling the input, instead of
      // being the default uncontrolled input
      //
      value: find('value', [this.props, this.state, this], defaultValue || ''),

      placeholder: this.select('placeholder'),
      readOnly: this.select('readOnly'),
      disabled: this.select('disabled'),
      autoComplete: this.select('autoComplete'),
      autoCorrect: this.select('autoCorrect'),
      autoCapitalize: this.select('autoCapitalize'),
      dir: this.select('dir'),
      spellCheck: this.select('spellCheck'),
      onChange: this.onChange,
      onBlur: this.select('onBlur')
    };

    if (hadInput && isValid === false) {
      result['data-invalid'] = true;
      result['aria-invalid'] = 'true';
    }
    if (!hadInput || isValid === true) {
      result['data-valid'] = true;
    }

    return result;
  }

  /**
   * Clear the input value.
   *
   * @param {Event} event Input event.
   * @public
   */
  clear(event) {
    const input = this.elements.input;

    if (event) {
      event.preventDefault();
      event.persist();
    }

    if (input) {
      this.setState(
        {
          value: ''
        },
        function () {
          this.onChange(event, true);
        }
      );
      input.focus();
    }
  }

  /**
   * Get data from either the state, props or set property. Allow empty strings to
   * be returned, especially important around `value` property.
   *
   * @param {String} name Property name.
   * @param {Mixed} fallback Fallback value when property does not exist.
   * @returns {Mixed} The value.
   * @private
   */
  select(name, fallback) {
    return find(name, [this.state || {}, this.props, this], fallback);
  }

  /**
   * Checks if the input validates.
   *
   * @param {Mixed} value String or number representating the value to validate.
   * @param {Function} validator Validator function to use. By default, selects the 'validate' property.
   * @param {Function} done Completion callback.
   * @returns {Mixed} The result of the callback.
   * @private
   */
  validating(value, validator, done) { // eslint-disable-line max-statements, complexity
    validator = validator || this.select('validate');

    const required = this.select('required');
    const failure = this.select('failure');
    const input = this.elements.input;

    //
    // `validates` prop overrides everything else.
    //
    if ('validates' in this.props) {
      if (failure && !this.props.validates) {
        return done(failure, false);
      }

      return done(undef, this.props.validates);
    }

    if (!(required || typeof validator === 'function')) {
      return done(undef, null);
    }

    if (input) {
      value = input.value || value;
    } else if (typeof value === 'undefined') {
      value = this.select('value') || this.select('defaultValue');
    }

    if (typeof value === 'string') {
      value = value.trim();
    }

    //
    // No value provided, but input is required. Only render as invalid if required.
    // Assume `required` is the error message if it is a string.
    //
    if (!value) {
      return done(required, required ? false : null);
    }

    // If a message for failure is provided and the input is invalid
    const isValid = validator && validator.call(this, value);
    if (failure && isValid === false) {
      return done(failure, false);
    }

    return done(undef, validator ? isValid : null);
  }

  /**
   * Render the actual component.
   *
   * @returns {React.DOM} Rendered form element.
   * @private
   */
  render() {
    const { onValidChange, clearable, size } = this.props;
    const data = this.attributes();
    const { isValid: validates, hadInput } = this.state;

    const props = {
      ...data,
      hadInput,
      validates,
      size,
      elements: this.elements,
      error: this._error(),
      notice: this._notice(),
      controls: this._controls(),
      input: this._input(data),
      required: this._required(),
      hideLabel: this.select('hideLabel'),
      label: this.select('label'),
      grid: this.select('grid'),
      inline: !!this.select('inline'),
      proxy: !!this.select('proxy'),
      ariaLabels: this.props.ariaLabels
    };

    if (this.isFlip) {
      props.design = this.select('design');
      props.style = this.select('toggleStyle', this.props.style);
      props.action = this.select('action');
      props.checked = !!this.select('checked', !!this.select('defaultChecked'));
      props.indeterminate = !!this.select('indeterminate');
    }

    if (clearable) {
      props.clearable =
        typeof clearable === 'function' ? clearable : this.clear;
    }

    const Input = this.isFlip ? Flip : Textual;

    return (
      <Validates
        name={ data.id || data.name }
        validates={ validates }
        onValidChange={ onValidChange }>
        <Input { ...props } />
      </Validates>
    );
  }
}

/**
 * Allowed Validation properties.
 *
 * @enum {Object} propTypes
 * @public
 */
Base.propTypes = {
  ...propTypes.element,
  /** A function that is triggered every time that your button is clicked. */
  action: PropTypes.func,
  /** The default value for input element. */
  defaultValue: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.bool
  ]),
  /** True if the input should receive merch styles  */
  merch: PropTypes.bool,
  /** The name of the input element, so you know under what name your value will be submitted. */
  name: PropTypes.string,
  /** A function that is triggered when the value is updated by the user. */
  onChange: PropTypes.func,
  /** A function that is triggered after the value is updated, by the user or programatically.
   *  Note: Do not use this when wrapping with a Critera.Connect component. */
  onValidation: PropTypes.func,
  /** For checkbox only. True when checkbox's state is indeterminate. */
  indeterminate: PropTypes.bool,
  /**
   * A boolean or string to indicate if the input field is required. If
   * a string is provided, it will be used as the error message.
   */
  required: PropTypes.oneOfType([PropTypes.bool, PropTypes.node]),
  /** Indicates if the input is valid.  Overrides the validate function.
   * Note: Use this when the output of validate is the result of higher
   * order properties that are passed in. */
  validates: PropTypes.bool,
  /** A function that returns a boolean as indication for invalid or valid
   * state of the input element. It receives the value as first argument.
   * Note: use this when state is internal to the element, e.g. value or
   * onChange should not be passed in as property. */
  validate: PropTypes.func,
  /** optional styles passed through to flip's button */
  toggleStyle: PropTypes.object,
  /** Screenreader labels for sub-elements */
  ariaLabels: PropTypes.shape({
    /** Screen reader label for clear field button */
    clear: PropTypes.string
  })
};
