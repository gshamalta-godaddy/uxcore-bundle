import PropTypes from 'prop-types';
import Button from '@ux/button';

/**
 * Default properties used for components.
 *
 * @type {Object}
 * @public
 */
const defaultProps = {
  input: {
    size: 'default',
    value: '',
    grid: {}
  }
};

/**
 * Allowed properties for both the wrapping element and internal input element.
 *
 * @type {Object}
 * @public
 */
const props = {
  /** DEPRECATED: Please use 'controls'. This indicates that a button has to be rendered on the right side of the label which
   * you can use to hide/show things for a given element. This does require the action property
   * to also be supplied. */
  button: PropTypes.node,
  /** DEPRECATED: Please use 'controls'. optional secondary form element button to be used in conjunction with button.
   * If href is provided it will be set on navigation instead of button if both are provided.
   * If any action is provided it will be used on button or ignored if no button is supplied. */
  navigation: PropTypes.node,
  /** Controls to be rendered to the right side of the label, this can be any grouping of elements. */
  controls: PropTypes.node,
  elements: PropTypes.object,
  /** An error element that will be rendered */
  error: PropTypes.element,
  /** An object with classNames if you want to render the input elements in a specific grid.
   * It should have a label and input property with the classNames as value. Note: Provide
   * numbers that represent the relative flex property instead of a className. */
  grid: PropTypes.object,
  /** Hide the label for the element */
  hideLabel: PropTypes.bool,
  /** The ID of the element, if none is provided, an ID will be generated. It is recommended to provide an ID */
  id: PropTypes.string,
  /** Indication if the element should be rendered as inline element. */
  inline: PropTypes.bool,
  /** A raw input element to be rendered */
  input: PropTypes.element,
  /** The label for the element */
  label: PropTypes.node.isRequired,
  /** Prevent the user from changing the value of the input. */
  readOnly: PropTypes.bool,
  /** Optional small text that needs to be added at the bottom of the input element. Can be used for hints. */
  notice: PropTypes.node,
  /** A change handler triggered whenever the input value changes. */
  onChange: PropTypes.func,
  /** A change handler triggered whenever the component blurs (is deselected). */
  onBlur: PropTypes.func,
  /** Disables the form element */
  disabled: PropTypes.bool,
  /** Do not render the element in a fieldset but use an empty div instead. */
  proxy: PropTypes.bool,
  /** The type of input element that needs to be rendered. If nothing is provided, the default text type is used instead. */
  type: PropTypes.string,
  /** For checkbox only. True when checkbox's state is indeterminate. */
  indeterminate: PropTypes.bool,
  /** Marks the form element as required for the form */
  required: PropTypes.oneOfType([
    PropTypes.node,
    PropTypes.bool
  ]),
  /** The value for input element. */
  value: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.bool
  ])
};

/**
 * Defined seperatly as the UXCore2 bundle will remove propTypes for performance,
 * FormElement._input depends on this data, this reference will keep it around.
 *
 * @type {Object}
 * @public
 */
const propTypes = {
  input: props,
  element: {
    ...props,
    /** A string to specify what, if any, autocomplete data should be used.
     * https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete */
    autoComplete: PropTypes.string,
    /** A string to use as an error message under the input element for invalid input. */
    failure: PropTypes.string,
    /** Indicates if the input is valid.  Overrides the validate function.
     * Note: Use this when the output of validate is the result of higher
     * order properties that are passed in. */
    validates: PropTypes.bool,
    /** A function that returns a boolean as indication for invalid or valid
     * state of the input element. It receives the value as first argument.
     * Note: use this when state is internal to the element, e.g. value or
     * onChange should not be passed in as property. */
    validate: PropTypes.func,
    /** A function that is triggered after the value is updated, by the user or programatically.
      *  Note: Do not use this when wrapping with a Critera.Connect component. */
    onValidation: PropTypes.func,
    /** Optional string, either large or small, that corresponds to a large/small height and font size
     * of the input field. The default sizes will display if no string is given */
    size: PropTypes.string,
    /** Callback for validity changes. See "Validation". */
    onValidChange: PropTypes.func,
    /** The design to use for the input, see @ux/button for design options */
    design: PropTypes.oneOf(Object.values(Button.designs)),
    /** Adds a small clickable clear button on the element to allow users to easily erase the value from the input.*/
    clearable: PropTypes.oneOfType([
      PropTypes.func,
      PropTypes.bool
    ])
  }
};

/**
 * Validates event object
 *
 * @param {SyntheticEvent} event Change event of TextInput or input element.
 * @returns {Boolean} Argument is eventlike.
 * @public
 */
function isEvent(event) {
  return typeof event === 'object' && 'target' in event;
}

/**
 * Return the value from an event.
 *
 * @param {SyntheticEvent} event Change event of TextInput or input element.
 * @returns {String} Input value.
 * @public
 */
function getValue(event) {
  if (!isEvent(event)) {
    return event;
  }

  const target = event.target || {};

  return target.value;
}

/**
 * Return the type of input element
 *
 * @param {SyntheticEvent} event Change event of TextInput or input element.
 * @returns {String|Undefined} Input type.
 * @public
 */
function getType(event) {
  if (!isEvent(event)) {
    return;
  }

  return event.target.type || 'text';
}

/**
 * Get the property name that should be used to store in state.
 *
 * @param {String} type Input type.
 * @returns {String} Property name.
 * @public
 */
function getStateProperty(type) {
  //
  // For types like checkbox, radio or unknown (i.e. RN Switch) return `checked` as the preferred property
  //
  if (!type || type === 'checkbox' || type === 'radio') {
    return 'checked';
  }

  return 'value';
}

export {
  getStateProperty,
  defaultProps,
  propTypes,
  getValue,
  getType
};
