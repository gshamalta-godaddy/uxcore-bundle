import React, { Component } from 'react';
import PropTypes from 'prop-types';
import classNames from '@ux/component-utilities/lib/classNames';
import Fieldset from '@ux/fieldset';
import Checkmark from '@ux/icon/checkmark';
import Minus from '@ux/icon/minus';
import Button from '@ux/button';
import { propTypes, defaultProps } from './enums';

/**
 * Renders a radio/checkbox element according to the design specifications.
 *
 * @displayName Flip (Radio / Checkbox) (Web)
 *
 * @class Flip
 * @private
 */
export class Flip extends Component {
  /**
   * Render the actual component.
   *
   * @returns {React.DOM} The component.
   * @private
   */
  render() {
    let currentChecked = !!this.props.checked;
    if (typeof this.props.elements.input !== 'undefined') {
      currentChecked = this.props.elements.input.checked;
    }

    //
    // This forces the input element to be rendered as a correct checkbox/radio
    // element.
    //
    const isButton =
      this.props.design === 'button' || Button.designs.includes(this.props.design);
    const className = classNames(
      {
        'ux-custom-control-inline': this.props.inline
      },
      ['ux-custom-control', `ux-custom-${this.props.type}`]
    );
    const targetClassName = classNames(
      {
        'ux-button': isButton,
        [`ux-button-${this.props.design}`]: Button.designs.includes(this.props.design)
      },
      ['ux-custom-target']
    );

    const indicatorClassName = 'ux-control-indicator';
    let indicator;
    if (this.props.type === 'checkbox') {
      indicator = this.props.indeterminate ? (
        <Minus className={ indicatorClassName } />
      ) : (
        <Checkmark className={ indicatorClassName } />
      );
    } else if (this.props.type === 'radio') {
      indicator = <span className={ indicatorClassName }></span>;
    }
    const label = (
      <label
        className={ classNames({
          'sr-only': this.props.hideLabel && !isButton
        }) }
        htmlFor={ this.props.id }
        ref={ r => {
          this.props.elements.label = r;
        } }
        id={ 'label-' + this.props.id }>
        {this.props.label}
      </label>
    );

    const target = (
      <div
        className={ targetClassName }
        disabled={ this.props.disabled }
        role='switch'
        aria-checked={ currentChecked }>
        {this.props.input}
        {!isButton && indicator}
        {label}
      </div>
    );

    const control = (
      <div className={ className }>
        {target}
        {this.props.notice}
        {this.props.error}
      </div>
    );

    return <Fieldset proxy={ !!this.props.proxy }>{control}</Fieldset>;
  }
}

/**
 * PropType validation
 *
 * @type {Object}
 * @private
 */
Flip.propTypes = {
  ...propTypes.input,
  /** The design to use for the input, see @ux/button for design options */
  design: PropTypes.oneOf(Object.values(Button.designs)),
  /** True if the element (radio or checkbox) is checked */
  checked: PropTypes.bool,
  /** For checkbox only. True when checkbox's state is indeterminate. */
  indeterminate: PropTypes.bool
};

/**
 *
 * @enum {Object} defaultProps
 * @public
 */
Flip.defaultProps = {
  ...defaultProps.input
};

export default Flip;
