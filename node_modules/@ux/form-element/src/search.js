/* eslint-disable no-undefined */
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import rip from 'rip-out';
import escapeRegExp from 'lodash.escaperegexp';
import debounce from 'debounce';
import Button from '@ux/button';
import FormElement from '../lib/index.js';
import SearchIcon from '@ux/icon/search';
import classNames from '@ux/component-utilities/lib/classNames';
import scrollIntoViewIfNeeded from '@ux/component-utilities/lib/scroll-into-view';
import { DropdownItem } from '@ux/dropdown';

const has = Object.prototype.hasOwnProperty;

const DefaultItem = ({ item, onSelect, selected }) => {
  return (
    <DropdownItem onClick={ () => { onSelect(item); return true; } } active={ selected } >
      {item}
    </DropdownItem>
  );
};

DefaultItem.defaultProps = {
  onSelect: () => {}
};

DefaultItem.propTypes = {
  item: PropTypes.string.isRequired,
  onSelect: PropTypes.func,
  selected: PropTypes.bool
};

/**
* Default aria-labels
*/
const DEFAULT_ARIA_LABELS = {
  searchLabel: 'Search box',
  searchButton: 'Search button',
  label: 'Search'
};

/**
 * Define propTypes to prevent removal for PROD builds.
 *
 * @type {Object}
 * @private
 */
const propTypes = {
  /** AutoCapitalize setting for form element, 'off' means no autocapitalize */
  autoCapitalize: PropTypes.string,
  /** AutoComplete setting for the form element, only applicable if no data is present */
  autoComplete: PropTypes.string,
  /** AutoCorrect setting for form element, 'off' means no autocorrect */
  autoCorrect: PropTypes.string,
  /** Button will be included */
  button: PropTypes.bool,
  /** Text to include on button */
  buttonText: PropTypes.node,
  /** Sets button type, defaults to submit. */
  buttonType: PropTypes.oneOf(['submit', 'button']),
  /** passDownProps for the internal Button component. */
  buttonProps: PropTypes.object,
  /** Classes applied */
  className: PropTypes.string,
  /** When true, a clear button will be shown when there's content in the searchbox, when Func, the higher order component wrapping searchBox should manage state.value to clear content. */
  clearable: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),
  /** The current filtered subset of props.data being displayed for any filter */
  data: PropTypes.array,
  /** Debounce your inputs for fast react */
  debounce: PropTypes.number,
  /** Determines the direction of typing, 'ltr' means left to right */
  dir: PropTypes.string,
  /** This flag determines if the results should be shown when the list has been truncated using the maxResults property. When true the flyout will remain hidden until the number of filtered results is less than equal to maxResults */
  hideTruncatedResults: PropTypes.bool,
  /** The active filter of the instance. This will only change after any potential debouncing has occurred.*/
  filter: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  /** This indicates that a button has to be rendered on the right side of the searchbox and indicates the icon name that should be displayed */
  icon: PropTypes.oneOfType([PropTypes.bool, PropTypes.elementType]),
  /** Unique id to pass to the FormElement Component */
  id: PropTypes.string,
  /** A max number of results to return. */
  maxResults: PropTypes.number,
  /** A change handler triggered whenever the input value changes. */
  onChange: PropTypes.func,
  /** Handles onchange event for the searchbox. Sets up states and decides filtered data. */
  onFilter: PropTypes.func,
  /** Callback function that is sent to each rendered item. It is triggered on-select of the item or if `onSearch` is not provided and search is triggered. */
  onSelect: PropTypes.func,
  /** An event handler triggered when the search is triggered. If not provided, `onSelect` is called. */
  onSearch: PropTypes.func,
  /** Placeholder text to be displayed in the searchbox */
  placeholder: PropTypes.string,
  /** If set, will be invoked to render each item in props.data. */
  renderItem: PropTypes.func,
  /** Allow the search to be cleared externally */
  reset: PropTypes.bool,
  /** Provide some results when query returns empty */
  resultsOnEmpty: PropTypes.bool,
  /** Size of the component */
  size: PropTypes.string,
  /** SpellCheck setting for form element, false means no spellcheck */
  spellCheck: PropTypes.bool,
  /** If data is an object, the value of this property determines the name of the property that holds the string to filter through */
  text: PropTypes.string,
  /** Function called on each piece of data to transform it into a string. */
  transform: PropTypes.func,
  /** The value for input. */
  value: PropTypes.string,
  /** Screenreader labels for search */
  ariaLabels: PropTypes.shape({
    /** Screen reader label for search input bar.  */
    searchLabel: PropTypes.string,
    /** Screen reader label for search button when it doesn't have text in it. Used when only icon is used */
    searchButton: PropTypes.string,
    /** Screen reader label for search component */
    label: PropTypes.string
  })
};

/**
 * Search control creates an input control that filters a provided list of objects.
 *
 * @displayName Search
 * @class Search
 * @public
 */
class Search extends Component {
  constructor() {
    super(...arguments);
    this.onElementValueChange = this.onElementValueChange.bind(this);
    this.onFilterChange = this.onFilterChange.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.onSelect = this.onSelect.bind(this);
    this.onSelected = this.onSelected.bind(this);
    this.builtInFilter = this.builtInFilter.bind(this);
    this.builtInTransform = this.builtInTransform.bind(this);
    this.clear = this.clear.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
    this.setStateAndClose = this.setStateAndClose.bind(this);
    this.preventBlur = this.preventBlur.bind(this);
    this.calledWarn = false;
    if (this.props.debounce) {
      this.onFilterChange = debounce(this.onFilterChange, this.props.debounce);
    }

    // initial state
    this.state = this.state || {};
    this.state = {
      ...this.state,
      data: [],
      filter: '',
      keyboardSelectionIndex: -1,
      open: false,
      preventBlur: false,
      suggestion: '',
      suggestionEnabled: this.shouldEnableSuggestion(this.props),
      value: this.props.value
    };

    this._warn();
  }

  /**
   *  console warning about missing id for accessibility purposes
   */
  _warn() {
    if (process.env.NODE_ENV === 'production') return;

    if (!this.props.id && !this.calledWarn) {
      this.calledWarn = true;
      console.warn('Warning: <Search> requires an id prop to be fully accessible.'); /* eslint-disable-line */
    }
  }

  /**
   * @returns {function} Transformation function that can be used to transform a datum to a string.
   */
  get transform() {
    return typeof this.props.transform === 'function'
      ? this.props.transform
      : this.builtInTransform;
  }

  /**
   * Apply filtering to data.
   *
   * @param {string} dataArray the data array to filter. It can be an array of string or an array of objects.
   * @param {string} value the string to filter data by. Uses state.filter by default
   * @returns {array} an array containing data that was not filtered out
   * @private
   */
  applyFilter(dataArray, value) {
    if (!value && !this.props.resultsOnEmpty) { return []; }

    const { transform } = this;

    const customFilter = typeof this.props.filter === 'function';
    const { maxResults, hideTruncatedResults } = this.props;
    const results = [];
    let numResults = 0;

    dataArray.every(data => {
      const includeItem = customFilter
        ? this.props.filter(data, value)
        : this.builtInFilter(transform(data), value);

      if (includeItem) {
        results.push(data);
        numResults++;
      }
      return hideTruncatedResults
        ? numResults <= maxResults // allow overrun by one to detect exceeding maxResults
        : numResults < maxResults;
    });

    return (hideTruncatedResults && numResults > maxResults)
      ? []
      : results;
  }

  /**
   * Transform a datum into a string that can be used for rendering and filtering.
   *
   * @param {string|Object} datum The datum to transform.
   * @returns {string} A string representation of the datum, or undefined.
   * @private
   */
  builtInTransform(datum) {
    if (typeof datum === 'string') return datum;
    const key = this.props.text || null;

    if (has.call(datum, key)) {
      return datum[ key ].toString();
    }
  }

  /**
   * Performs the filter operation on `props.filter` taking into account the default
   * states (startsWith, endsWith, and includes).
   *
   * @param   {string} datum Item within `props.data` to potentially include in results
   * @param   {string} value Current search value
   * @returns {boolean} Value indicating if `datum` should be included in results.
   */
  builtInFilter(datum, value) {
    if (!datum) return false;

    const lowerDatum = datum.toLowerCase();
    const lowerValue = (value || '').toLowerCase();
    let { startsWith, endsWith, includes } = this.props.filter || {};
    if (!startsWith && !endsWith && !includes) {
      startsWith = true;
      endsWith = true;
    }

    const firstIndex = lowerDatum.indexOf(lowerValue);
    if ((startsWith && firstIndex === 0)
      || (includes && ~firstIndex)) {
      return true;
    }

    const lastIndex = lowerDatum.lastIndexOf(lowerValue);
    if (endsWith && lastIndex !== -1 && lastIndex === lowerDatum.length - lowerValue.length) {
      return true;
    }

    return false;
  }

  /**
   * clears the control.
   *
   * @private
   */
  clear() {
    this.onFilterChange('');
  }

  /**
   * Returns suggestion based on passed in data and filter.
   *
   * @param {string} data the data array to suggest from
   * @param {string} value the string to filter data by. Uses state.filter by default
   * @returns {string} suggested text
   * @private
   */
  getSuggestion(data, value) {
    value = value || this.state.filter;
    if (this.state.keyboardSelectionIndex >= 0) {
      const item = data[ this.state.keyboardSelectionIndex ];
      return item ? this.transform(item) : '';
    }

    const transformedData = data.map(this.transform);
    const escapedValue = escapeRegExp(value);
    const reg = new RegExp('\\b' + escapedValue + '\\w*\\b', 'gi');
    const lowerValue = value.toLowerCase();

    for (let i = 0; i < transformedData.length; i++) {
      if (!transformedData[ i ] || transformedData[ i ].toLowerCase() === lowerValue) continue;
      const matches = transformedData[ i ].match(reg);

      if (matches) return transformedData[ i ];
    }
    return '';
  }

  /**
   * Sets up states and decides filtered data.
   *
   * @param {string} value the string to filter data by. Defaults to state.filter
   * @returns {Array} filtered data
   * @private
   */
  filterBy(value) {
    let filteredData = [];
    value = (value || value === '') ? value : this.state.filter;
    if (value || this.props.resultsOnEmpty) {
      filteredData = this.applyFilter(this.props.data, value.toLowerCase());
    }

    const suggestion = this.state.suggestionEnabled
      ? this.getSuggestion(filteredData, value)
      : '';

    this.setState({
      suggestion: suggestion,
      open: filteredData.length > 0,
      data: filteredData,
      filter: value,
      value
    });

    this.props.onFilter(value, filteredData);
    return filteredData;
  }

  /**
   * Prevents the component from triggering onBlur, ie: when you click on a list
   * item.
   *
   * @private
   */
  preventBlur() {
    this.setState({ preventBlur: true });
  }

  /**
   * Invokes `setState` with the `extraState` provided along with the
   * necessary state to close this instance. Reduces duplication of these
   * properties throughout the code.
   *
   * @param {Object} extraState Additional state information to set with close.
   */
  setStateAndClose(extraState) {
    this.setState({
      ...extraState,
      open: false,
      preventBlur: false,
      suggestion: this.state.suggestion
    });
  }

  /**
   * Checks if suggestions should be enabled.
   *
   * @param {Object} props Properties (this.props or nextProps) to determine if suggestion should be enabled.
   * @returns {bool} Returns true only if the filter is startsWith exclusively, otherwise false
   */
  shouldEnableSuggestion(props) {
    const { filter } = props;
    return filter
      && typeof filter === 'object'
      && filter.startsWith
      && !filter.includes
      && !filter.endsWith;
  }

  /**
   * Handles the arrows keyboard action.
   *
   * @param {object} e Event object sent from the browser
   * @private
   */
  onArrowUpDown(e) {
    if (!this.state.open) { return; }

    let { keyboardSelectionIndex } = this.state;
    const delta = e.key === 'ArrowDown' ? 1 : -1;

    if (keyboardSelectionIndex === -1 && e.key === 'ArrowUp') {
      keyboardSelectionIndex = 0;
    }

    keyboardSelectionIndex += delta;

    // Wraparound of keyboardSelectionIndex to be within [0..data.length-1] range
    const dataLength = this.state.data.length;
    keyboardSelectionIndex = (keyboardSelectionIndex + dataLength) % dataLength;

    this.setState({
      keyboardSelectionIndex,
      suggestion: keyboardSelectionIndex >= 0
        ? this.transform(this.state.data[ keyboardSelectionIndex ])
        : this.state.suggestion
    });

    if (this.listContainer && this.listContainer.childNodes[ keyboardSelectionIndex ]) {
      scrollIntoViewIfNeeded(this.listContainer.childNodes[ keyboardSelectionIndex ]);
    }

    e.preventDefault();
  }

  /**
   * A change handler triggered whenever the component blurs (is deselected).
   *
   * @private
   */
  onBlur() {
    setTimeout(() => {
      if (!this.state.preventBlur) {
        this.setStateAndClose({
          suggestion: '',
          keyboardSelectionIndex: -1
        });
      }
    }, 1);
  }

  /**
   * Handles onchange event for the searchbox. Gets the value from the event and calls
   * the actual (possibly debounced) handler onFilterChange()
   *
   * @param {object} ev the event object sent from the browser
   * @private
   */
  onElementValueChange(ev) {
    const value = ev.target.value;
    this.setState({ value });
    this.onFilterChange(value);
  }

  /**
   * Handles onchange event for the searchbox. Sets up states and decides filtered data.
   *
   * @param {string} value new input field value
   * @private
   */
  onFilterChange(value) {
    const filteredData = this.filterBy(value);
    this.setState({ keyboardSelectionIndex: -1 });
    this.props.onChange(value, filteredData);
  }

  /**
   * Handles focus for the searchbox.
   *
   * @private
   */
  onFocus() {
    this.filterBy(this.state.value);
    this.setState({
      open: this.props.resultsOnEmpty || this.state.data.length > 0,
      preventBlur: false
    });
  }

  /**
   * Fill the textbox when the right arrow is clicked and a suggestion exists.
   *
   * @param {object} e Event object sent from the browser
   * @private
   */
  onKeyDown(e) {
    if (!this.formElement) return;
    const suggestion = this.state.suggestion;

    switch (e.key) {

      case 'ArrowRight':
        if (!this.state.suggestionEnabled || !this.state.suggestion) return;
        this.setState({
          suggestion: '',
          value: suggestion
        });
        this.filterBy(suggestion);
        break;

      case 'Enter': {
        const { keyboardSelectionIndex } = this.state;
        if (this.state.keyboardSelectionIndex >= 0) {
          const item = this.state.data[ keyboardSelectionIndex ];
          const value = this.transform(item);
          this.setStateAndClose({
            value,
            suggestion: ''
          });

          if (this.props.onSelect) {
            this.props.onSelect(value);
          }
        } else {
          this.onSelected();
        }

        break;
      }

      case 'ArrowDown':
      case 'ArrowUp':
        this.onArrowUpDown(e);
        break;

      default:
        break;
    }
  }

  /**
   * Callback function that is sent to each rendered item. It is triggered
   * on-select of the item.
   *
   * @param {string} value the string that was selected
   * @param {bool} isSearch determines whether to call the `onSearch` or `onSelect` callback
   * @private
   */
  onSelect(value, isSearch = false) {
    this.filterBy(value);
    this.setState({
      open: false,
      suggestion: ''
    });

    if (isSearch && this.props.onSearch) {
      this.props.onSearch(value);
    } else if (this.props.onSelect) {
      this.props.onSelect(value);
    }
  }

  /**
   * Called when the button is clicked. This action is equivalent to a selection.
   *
   * @private
   */
  onSelected() {
    this.onSelect(this.state.value, true);
  }

  /**
    * When props change check to see if suggestionEnabled needs to be changed.
    *
    * @param {Object} prevProps All props being set on this instance.
    * @private
    */
  componentDidUpdate(prevProps) {
    const nextState = {};
    let filter = this.state.value;

    // If the value prop changes and it's different from the internally tracked state, run a filter update
    if (this.props.value !== prevProps.value && this.props.value !== this.state.value) {
      filter = this.props.value;
      nextState.value = this.props.value;
    }

    if (prevProps.data !== this.props.data) {
      nextState.data = this.props.data;
    }

    if (prevProps.filter !== this.props.filter) {
      nextState.suggestionEnabled = this.shouldEnableSuggestion(this.props);
    }

    if (this.props.reset) {
      filter = '';
    }

    if (Object.keys(nextState).length) {
      this.setState(nextState, () => {
        if (nextState.data || this.props.reset) {
          this.filterBy(filter);
        }
      });
    } else if (this.props.reset && this.state.value) {
      this.filterBy(filter);
    }
  }

  /**
    * Only update on change to props if data, filter, open or reset changed.
    *
    * @param  {Object} nextProps All props being set on this instance.
    * @param  {Object} nextState All state properties for upcoming setState
    * @returns {bool} Returns true if data, filter, open or reset changed
    */
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps.reset
      || this.props.data !== nextProps.data
      || this.props.filter !== nextProps.filter
      || this.state.data !== nextState.data
      || this.props.value !== nextProps.value
      || this.state.value !== nextState.value
      || this.state.open !== nextState.open
      || this.props.className !== nextProps.className
      || (nextState.open && this.state.keyboardSelectionIndex !== nextState.keyboardSelectionIndex);
  }

  /**
   * Render a button when buttontext or button is defined.
   *
   * @returns {JSX} Button Searchbox button component
   * @private
   */
  renderButton() {

    let Icon;
    if (this.props.icon || this.props.button) {
      Icon = SearchIcon;
      if (typeof this.props.icon !== 'boolean') {
        Icon = this.props.icon;
      }
    }

    let size;
    if (this.props.size === 'small') {
      size = 'small';
    }

    return (
      Icon &&
      <Button
        { ...this.props.buttonProps }
        aria-label={ !this.props.buttonText ? this.props.ariaLabels.searchButton : null }
        design='primary'
        icon={ <Icon /> }
        type={ this.props.buttonType }
        onClick={ this.onSelected }
        size={ size }
        text={ this.props.buttonText }
        aria-controls={ this.props.id ? `${this.props.id}-input` : undefined }
      />
    );
  }

  /**
   * Render the list items based.
   *
   * @returns {JSX} the list component
   */
  renderList() {
    if (this.state.open) {
      const { keyboardSelectionIndex } = this.state;
      const { transform } = this;

      return (
        <div role='listbox'
          tabIndex='-1'
          className='ux-search-list-container dropdown-menu'
          onMouseDown={ this.preventBlur }
          id={ this.props.id ? `${this.props.id}-listBox` : undefined }
          ref={ (c) => { this.listContainer = c; } }>
          {
            this.state.data.map((item, index) => {
              if (typeof this.props.renderItem === 'function') {
                return this.props.renderItem(transform(item), index, this.onSelect, item, index === keyboardSelectionIndex);
              }

              return (
                <DefaultItem
                  role='option'
                  key={ index }
                  item={ transform(item) }
                  onSelect={ this.onSelect }
                  selected={ index === keyboardSelectionIndex } />
              );
            })
          }
        </div>
      );
    }
  }

  /**
   * Get the suggestion div.
   *
   * @returns {JSX} the lookahead component
   * @private
   */
  renderLookAhead() {
    const filter = this.state.filter || '';
    const suggestion = this.state.suggestion;

    if (!suggestion) return '';

    const lookaheadWidth = this.formElement.elements.input.offsetWidth;
    // This is the width of the space between the end of the form-element
    // and the clearable with a bit of extra space to make it look nice.
    // This allows the lookahead text to not go underneath the clearable icon
    const clearableIconSpacing = 65;
    const finalSize = lookaheadWidth - clearableIconSpacing;

    const remainder = suggestion.substring(filter.length);
    return (
      <div
        aria-hidden='true'
        tabIndex='-1'
        onKeyDown={ this.onKeyDown }
        onMouseDown={ this.preventBlur }
        onClick={ () => { if (this.formElement) this.formElement.elements.input.focus(); } }
        className='ux-search-lookahead'>
        <span className='ux-search-lookahead-filter' style={{ visibility: 'hidden' }}>{filter}</span>
        <span className='ux-search-lookahead-remainder' style={{ width: finalSize }}>{ remainder }</span>
      </div>
    );
  }

  render() {
    const { placeholder, clearable, className, ariaLabels, id, ...props } = this.props;
    const { suggestion, suggestionEnabled, value, open } = this.state;
    const unknownProps = rip(props, ...Object.keys(propTypes));
    const clsx = classNames('input-group', 'ux-search', className, { open });

    const placeholderText = !suggestion.length || !suggestionEnabled
      ? placeholder
      : '';

    const autoComplete = props.autoComplete || (props.data && props.data.length ? 'off' : 'on');
    const dataLength = props.data && props.data.length;

    return (
      <div role={ dataLength ? 'combobox' : 'search' }
        aria-haspopup={ dataLength ? 'listbox' : null }
        aria-expanded={ open ? 'true' : 'false' }
        aria-owns={ id ? `${id}-listbox` : undefined }
        className={ clsx } { ...unknownProps }
        aria-label={ ariaLabels.label }
        id={ id ? `label-${id}` : undefined }>
        <FormElement
          aria-label={ ariaLabels.searchLabel }
          aria-autocomplete='list'
          label=''
          id={ id }
          value={ value }
          name='searchText'
          autoComplete={ autoComplete }
          ref={ c => { this.formElement = c; } }
          className='form-control'
          onChange={ this.onElementValueChange }
          onKeyDown={ this.onKeyDown }
          onFocus={ this.onFocus }
          onBlur={ this.onBlur }
          placeholder={ placeholderText }
          size={ this.props.size }
          clearable={ clearable === true ? this.clear : clearable }
          autoCorrect={ this.props.autoCorrect }
          autoCapitalize={ this.props.autoCapitalize }
          dir={ this.props.dir }
          spellCheck={ this.props.spellCheck }
        />

        {suggestionEnabled && this.renderLookAhead()}
        {this.renderList()}

        <span className='input-group-btn'>
          {this.renderButton()}
        </span>
      </div>
    );
  }
}

/**
 * Property validation.
 *
 * @type {Object}
 * @public
 */
Search.propTypes = propTypes;

/**
 * Default properties of the control
 *
 * @type {Object}
 * @public
 */
Search.defaultProps = {
  button: false,
  buttonText: '',
  buttonType: 'submit',
  buttonProps: {},
  className: '',
  clearable: true,
  data: [],
  debounce: 0,
  hideTruncatedResults: false,
  icon: SearchIcon,
  filter: { startsWith: true },
  maxResults: Infinity,
  onChange: function () {},
  onFilter: function () {},
  onSelect: function () {},
  placeholder: '',
  reset: false,
  renderItem: null,
  resultsOnEmpty: false,
  size: 'default',
  text: '',
  value: '',
  ariaLabels: DEFAULT_ARIA_LABELS
};

export {
  Search as default,
  DefaultItem
};
