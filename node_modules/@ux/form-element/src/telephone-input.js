import React, { Component, PureComponent } from 'react';
import PropTypes from 'prop-types';
import Button from '@ux/button';
import FormElement from '../lib/index.js';
import classNames from '@ux/component-utilities/lib/classNames';
import ClickOutside from '@ux/component-utilities/lib/use-click-outside-hoc';

/**
 * CountryDropdown renders the country selector dropdown for the TelephoneInput
 * @displayName CountryDropdown
 * @class CountryDropdown
 *
 */
class CountryDropdown extends PureComponent {
  /**
   * Render the country dropdown
   *
   * @returns {React.DOM} rendered component
   * @private
   */
  render() {
    const { countryData, onCountrySelect, activeClassName } = this.props;
    const selected = this.props.selectedCountry;

    const onSelectedClick = (event) => onCountrySelect(event, selected);

    return (
      <ul id='phoneCountryList' className='dropdown-menu dropdown-menu-items' role='menu'>
        <div id={ selected.countryKey }
          key={ selected.countryKey }
          role='presentation'
          className={ activeClassName }
          onClick={ onSelectedClick }>
          <a role='menuitem' href={ '#' + selected.countryKey }>
            <span className='country-id'>{ selected.countryKey } </span>
            <span className='country-name'>{ selected.label } </span>
            <span className='dial-code'>{ '+' + selected.callingCode } </span>
          </a>
        </div>

        {
          countryData.map((country) => {
            if (country.countryKey === selected.countryKey) { return; }

            const onClick = (event) => onCountrySelect(event, country);

            return (
              <div id={ country.countryKey }
                key={ country.countryKey }
                role='presentation'
                className='dropdown-item'
                onClick={ onClick }>
                <a role='menuitem' href={ '#' + country.countryKey }>
                  <span className='country-id'>{ country.countryKey } </span>
                  <span className='country-name'>{ country.label } </span>
                  <span className='dial-code'>{ '+' + country.callingCode } </span>
                </a>
              </div>
            );
          })
        }
      </ul>
    );
  }
}

CountryDropdown.propTypes = {
  /** An array of countries and their associated calling data. */
  countryData: PropTypes.array.isRequired,
  /** Selected country object which will render first in the dropdown list before the rest of countryData. */
  selectedCountry: PropTypes.object.isRequired,
  /** Styles applied for the active item */
  activeClassName: PropTypes.string.isRequired,
  /** Handle country selection, update the phone number with the calling code and notify the parent of the change */
  onCountrySelect: PropTypes.func.isRequired
};

const phoneRegEx = /^\+([0-9]){1,3}\.([0-9]){6,14}$/;
const maxLength = 17;

/**
 * TelephoneInput renders a component with country calling code selector
 *
 * @displayName TelephoneInput
 * @class TelephoneInput
 */
export default class TelephoneInput extends Component {
  // eslint-disable-next-line max-statements
  constructor(props) {
    super(props);

    const { countryKey, phoneNumber, countryData, marketId, presorted } = props;

    const countryDataProps = (Array.isArray(countryData) &&
      countryData.length &&
      this.sortCountryData(countryData, marketId, presorted)) || [
      {
        countryKey: 'US',
        label: 'United States',
        callingCode: '1'
      }
    ];

    const normalizedCountryData = this.normalizeCountryData(countryDataProps);
    const parsedPhoneNumber = this.parsePhoneNumber(phoneNumber);
    const phoneCountryKey = this.getCountryKeyFromCallingCode(
      parsedPhoneNumber.callingCode,
      countryKey,
      normalizedCountryData
    );
    const countryCallingCode = this.getCallingCodeFromCountryKey(countryKey, countryDataProps);

    this.state = {
      showCountryList: false,
      callingCode: parsedPhoneNumber.callingCode || countryCallingCode,
      lineNumber: parsedPhoneNumber.lineNumber,
      countryKey: phoneCountryKey || countryKey,
      countryData: countryDataProps,
      normalizedCountryData,
      hadInput: false,
      inputError: false
    };

    this.onInputBlur = this.onInputBlur.bind(this);
    this.onInputFocus = this.onInputFocus.bind(this);
    this.onInputChange = this.onInputChange.bind(this);
    this.onInputKeyDown = this.onInputKeyDown.bind(this);
    this.onOutsideClick = this.onOutsideClick.bind(this);
    this.onCountryClick = this.onCountryClick.bind(this);
    this.onCountrySelect = this.onCountrySelect.bind(this);
    this.phoneControl = React.createRef();
  }

  /**
   * After component mounts, call the onChangeHandler for initial validation
   *
   * @returns {void}
   * @private
   */
  componentDidMount() {
    const { phoneNumber, countryKey } = this.props;
    const event = document.createEvent('Event');

    this.props.onChangeHandler(event, phoneNumber, this.validatePhoneNumber(phoneNumber), countryKey);
  }

  /**
   * Focus on input when callingCode change. On Android devices, check
   * to see if the boundary of the selection is less than the calling code
   * prefix. If it is then force cursor to the end.
   *
   * @param {Object} prevProps - previous props
   * @param {Object} prevState - previous state
   * @returns {void}
   * @private
   */
  /* eslint-disable-next-line max-statements, complexity */
  componentDidUpdate(prevProps, prevState) {
    const props = this.props;
    const updates = {};
    const { elements: { input } } = this.phoneInput;

    if (!prevState.callingCode && prevState.callingCode !== this.state.callingCode) {
      input.focus();
    }

    //
    // **ANDROID MOBILE ONLY FIX** Force the cursor to the end of the input
    // if the selectionStart is less than the calling code prefix.
    //
    const { lineNumber, callingCode } = this.state;
    if (lineNumber && callingCode && input.selectionStart < `+${callingCode}.`.length) {
      const phoneNumber = this.state.phoneNumber || this.buildPhoneNumber(callingCode, lineNumber) || '';
      input.selectionStart = input.selectionEnd = phoneNumber.length;
    }

    if (!lineNumber && props.countryKey !== prevProps.countryKey) {
      updates.countryKey = props.countryKey;
      updates.callingCode = this.getCallingCodeFromCountryKey(props.countryKey);
    }

    if (prevProps.phoneNumber !== props.phoneNumber) {
      const parsedNumber = this.parsePhoneNumber(props.phoneNumber);
      const phoneNumber = this.buildPhoneNumber(parsedNumber.callingCode, parsedNumber.lineNumber);
      updates.callingCode = parsedNumber.callingCode;
      updates.lineNumber = parsedNumber.lineNumber;
      updates.phoneNumber = phoneNumber;
    }

    if (props.countryData && props.countryData !== prevProps.countryData) {
      const marketId = props.marketId || prevProps.marketId;
      updates.countryData = this.sortCountryData(props.countryData, marketId, props.presorted);
    }

    if (prevProps.countryData !== props.countryData) {
      updates.normalizedCountryData = this.normalizeCountryData(updates.countryData);
    }

    if (Object.keys(updates).length) {
      this.setState(updates);
    }
  }


  /**
   * Sort the countries by label
   *
   * @param {array} data - data from api
   * @param {string=} marketId - BCP-47 language string to use as locale when comparing entries, defaults to 'en-US'
   * @param {bool=} presorted - indicates if data is already sorted, defaults to false
   * @returns {string} marketId
   * @public
   */
  sortCountryData(data, marketId = 'en-US', presorted = false) {
    if (presorted) {
      return data;
    }

    return data.slice().sort(function (a, b) {
      return a.label.localeCompare(b.label, marketId);
    });
  }

  /**
   * Compose a complete phone number from the calling code and line number
   *
   * @param {number} callingCode - Country callingCode
   * @param {string} lineNumber - Phone number
   * @returns {string} Complete phone number
   * @public
   */
  buildPhoneNumber(callingCode, lineNumber) {
    let phoneNumber = '';
    if (callingCode) {
      phoneNumber += '+' + callingCode + '.';
    }
    if (lineNumber) {
      phoneNumber += lineNumber;
    }
    return phoneNumber;
  }

  /**
   * Find the country by calling code
   *
   * @param {string} countryKey Country key
   * @param {array} dataset Optional dataset to use.
   * @returns {number} callingCode
   * @public
   */
  getCallingCodeFromCountryKey(countryKey, dataset) {
    const countryData = dataset || this.state.countryData || [];
    let callingCode = null;

    for (let i = countryData.length; i--;) {
      if (countryData[i].countryKey === countryKey) {
        callingCode = countryData[i].callingCode;
        break;
      }
    }

    return callingCode;
  }

  /**
   * Find the country by calling code.
   * FYI: If there are multiple countries with the same code,
   * it will return the first one.
   *
   * @param {number} callingCode Country callingCode
   * @param {string} countryKey Current country key
   * @param {array} normalizedCountryData Optional dataset to use.
   * @returns {string} countryKey
   * @public
   */
  getCountryKeyFromCallingCode(callingCode, countryKey, normalizedCountryData) {
    if (!countryKey) countryKey = this.state.countryKey;

    if (!normalizedCountryData) {
      normalizedCountryData = this.state.normalizedCountryData || this.normalizeCountryData();
    }

    if (callingCode && normalizedCountryData[callingCode]) {
      if (normalizedCountryData[callingCode].indexOf(countryKey) < 0) {
        countryKey = normalizedCountryData[callingCode][0];
      }
    }

    return countryKey;
  }

  /**
   * Normalize country data by calling code. Ensure US is first for calling
   * code 1.
   *
   * @param {Array} countryData Data to normalize
   * @returns {Object} Normalized country data by calling code
   * @private
   */
  normalizeCountryData(countryData) {
    countryData = countryData || this.state.countryData;
    const normalizedCountryData = { 1: ['US'] };

    if (Array.isArray(countryData)) {
      for (let i = countryData.length - 1; i >= 0; i--) {
        const country = countryData[i];

        if (country.countryKey !== 'US') {
          const callingCode = country.callingCode;

          if (!normalizedCountryData[callingCode]) {
            normalizedCountryData[callingCode] = [];
          }

          normalizedCountryData[callingCode].push(country.countryKey);
        }
      }
    }

    return normalizedCountryData;
  }

  /**
   * Handle the country dropdown click
   *
   * @returns {void}
   * @private
   */
  onCountryClick() {
    const show = this.state.showCountryList;
    this.setState({ showCountryList: !show });
  }

  /**
   * Handle country selection, update the phone number with the calling code
   * and notify the parent of the change
   *
   * @param {Object} event - Event for click
   * @param {Object} country - Country object being clicked
   * @returns {void}
   */
  onCountrySelect(event, country) {
    // added to avoid issues with hash routing.
    event.preventDefault();

    const newNumber = this.buildPhoneNumber(country.callingCode, this.state.lineNumber);

    this.setState({
      phoneNumber: newNumber,
      countryKey: country.countryKey,
      callingCode: country.callingCode,
      showCountryList: false
    });

    this.props.onChangeHandler(event, newNumber, this.validatePhoneNumber(newNumber), country.countryKey);
  }

  /**
   * Handle clicking on the document to determine if the country list should be hidden
   *
   * @param {Object} event - Event for click
   * @param {Function} fn - listener for click event
   * @private
   */
  onOutsideClick(event, fn) {
    if (this.state.showCountryList) {
      this.setState({
        outsideListener: fn,
        showCountryList: false
      });
    }
  }

  /**
   * Handle keyboard input change, look up country, render the new phone number
   *
   * @param {Object} event - Event for KeyDown
   * @returns {void}
   * @private
   */
  onInputChange(event) {
    const newValue = event.target.value;
    const parsedPhoneNumber = this.parsePhoneNumber(newValue);
    const countryKey = this.getCountryKeyFromCallingCode(parsedPhoneNumber.callingCode);
    const callingCode = parsedPhoneNumber.callingCode || this.getCallingCodeFromCountryKey(countryKey);
    const newNumber = this.buildPhoneNumber(callingCode, parsedPhoneNumber.lineNumber);

    let hadInput = this.state.hadInput;
    if (this.props.required && !this.state.hadInput) {
      hadInput = true;
    }

    this.setState({
      lineNumber: parsedPhoneNumber.lineNumber,
      phoneNumber: newNumber,
      callingCode,
      countryKey,
      hadInput
    });

    this.props.onChangeHandler(event, newNumber, this.validatePhoneNumber(newNumber), countryKey);
  }

  /**
   * Handle input blur, remove calling code from input if no line number is provided
   *
   * @returns {void}
   * @private
   */
  onInputBlur() {
    const callingCode = this.buildPhoneNumber(this.state.callingCode);
    const phoneInput = this.phoneInput.elements.input.value || '';

    const inputError = this.props.required && this.state.hadInput && phoneInput === '';
    if (phoneInput === callingCode) {
      this.setState({
        lineNumber: null,
        inputError
      });
    }
  }

  /**
   * Handle input focus, hide the country list, populate calling code if empty
   *
   * @param {Object} event - Event for Focus
   * @returns {void}
   * @private
   */
  onInputFocus() {
    const updated = { showCountryList: false, inputError: false };
    if (this.phoneInput.elements.input.value === '') {
      updated.callingCode = this.getCallingCodeFromCountryKey(this.state.countryKey);
    }

    this.setState(updated);
  }

  /**
   * Handle input key down, if down arrow key, show country list
   *
   * @param {Object} event - Event for KeyDown
   * @returns {void}
   * @private
   */
  /* eslint-disable-next-line max-statements, complexity */
  onInputKeyDown(event) {
    let key = event.key;
    const safelistKeys = ['Backspace', 'ArrowLeft', 'ArrowRight', 'ArrowDown', 'Delete', 'Tab'];

    //
    // Safari@10.1 workaround (and perhaps others), which is lacking a `key` identifiers. This maps each number to
    // their actual value, keys from the safelist are properly identified.
    //
    if (key === 'Unidentified') key = event.keyCode - 48;

    const safeModifierKeys = event.ctrlKey || event.metaKey;

    if (!/^[0-9]$/.test(key) && !safeModifierKeys && !~safelistKeys.indexOf(key)) {
      event.preventDefault();
    }

    //
    // If key is backspace or delete handle the deletion of characters from index to left
    // and then items right of index and left
    //
    if (key === 'Backspace' || key === 'Delete') {
      const directionModifier = key === 'Delete';
      const { value, selectionStart, selectionEnd } = event.target;
      const selection = value.substring(selectionStart, selectionEnd);
      const firstPeriodPos = value.indexOf('.') + 1;

      if (firstPeriodPos) {
        const noSelectionBeforeDot =
          selectionStart + directionModifier <= firstPeriodPos && selectionStart === selectionEnd;
        const cursorBeforeDotNotFullSel = selectionStart + directionModifier < firstPeriodPos && selection !== value;
        const dotSelectedButNotFullSel = ~selection.indexOf('.') && selection !== value;

        if (noSelectionBeforeDot || cursorBeforeDotNotFullSel || dotSelectedButNotFullSel) {
          event.preventDefault();
        }
      }
    }

    if (!this.state.showCountryList && key === 'ArrowDown') {
      this.setState({ showCountryList: true });
    }
  }

  /**
   * Parse the phone number to determine the calling code and line number
   *
   * @param {string} phoneNumber - Phone number to be parsed
   * @returns {Object} callingCode and lineNumber
   * @public
   */
  parsePhoneNumber(phoneNumber) {
    let callingCode = null;
    let lineNumber = phoneNumber;

    if (phoneNumber && phoneNumber[0] === '+') {
      phoneNumber = phoneNumber.replace('+', '');
      const dotIndex = phoneNumber.indexOf('.');
      if (dotIndex > 0) {
        callingCode = phoneNumber.substring(0, dotIndex);
        lineNumber = phoneNumber.substring(dotIndex + 1);
      }
    }

    return {
      callingCode: callingCode,
      lineNumber: lineNumber
    };
  }

  /**
   * Validate the phone number passes the is required check and regex check
   *
   * @param {string} phoneNumber - Phone number to be parsed
   * @returns {boolean} Does phone number pass regEx text
   * @public
   */
  validatePhoneNumber(phoneNumber) {
    let isValid = true;
    const { isRequired } = this.props;
    const isEmpty = !phoneNumber || phoneNumber.length === 0;

    if (isRequired) {
      isValid = !isEmpty;
    }

    if (isValid && (isRequired || (!isRequired && !isEmpty))) {
      isValid = phoneRegEx.test(phoneNumber);
    }

    return isValid;
  }

  /**
   * Gets the countryData item that should be selected.
   * RIf countryKey is not in data, returns US data or first item in list
   * @returns {Object} countryData item that should be selected
   * @private
   */
  getSelectedCountry() {
    const { countryKey, countryData } = this.state;
    const selectedCountry = countryData.filter(country => country.countryKey === countryKey)[0];
    if (!selectedCountry) {
      if (!countryData.some(country => country.countryKey === 'US')) {
        return countryData[0];
      }
      return { callingCode: '1', countryKey: 'US', label: 'United States' };
    }
    return selectedCountry;
  }

  /**
   * Render the country list
   * @param {Object} selected The item that should render as selected
   * @param {string} selected.countryKey The selected item's country key
   * @param {string} selected.callingCode The selected item's calling code
   * @returns {ReactElement} rendered country menu list
   */
  renderCountryList(selected) {
    const { showCountryList, countryData } = this.state;

    const classes = classNames('dropdown', 'ux-select-dropdown', 'ux-tel-container', { open: showCountryList });

    return (
      <div style={{ top: 'inherit' }} className={ classes }>
        <CountryDropdown
          selectedCountry={ selected }
          activeClassName='dropdown-item active'
          onCountrySelect={ this.onCountrySelect }
          countryData={ countryData }
        />
      </div>
    );
  }

  /**
   * Render the phone component
   *
   * @returns {React.DOM} rendered component
   * @private
   */
  render() {
    const { name, placeholderText, id } = this.props;
    const { callingCode, lineNumber } = this.state;
    const phoneNumber = lineNumber ? this.buildPhoneNumber(callingCode, lineNumber) : '';
    const selectedCountry = this.getSelectedCountry();
    const countryList = this.renderCountryList(selectedCountry);
    const keyCode =  `${selectedCountry.countryKey} +${selectedCountry.callingCode}`;

    return (
      <ClickOutside
        targetRef={ this.phoneControl }
        onClick={ this.onOutsideClick }
      >
        <div
          className='form-group'
          ref={ this.phoneControl }
        >
          <div className='ux-tel-container'>
            <Button
              className={ classNames('ux-tel-btn', { 'ux-tel-btn-danger': this.state.inputError }) }
              id='basic-addon1'
              onClick={ this.onCountryClick }
              as='select'
              text={ keyCode }/>
            <FormElement
              className='form-control ctHidden ux-tel-input'
              name={ name }
              id={ id }
              maxLength={ maxLength }
              onBlur={ this.onInputBlur }
              onChange={ this.onInputChange }
              onFocus={ this.onInputFocus }
              onKeyDown={ this.onInputKeyDown }
              placeholder={ placeholderText }
              label={ this.props.label }
              required={ this.props.required }
              value={ phoneNumber }
              ref={ input => {
                this.phoneInput = input;
              } }
              type='tel'
            />
          </div>
          {countryList}
        </div>
      </ClickOutside>
    );
  }
}

TelephoneInput.propTypes = {
  /** An array of countries and their associated calling data. */
  countryData: PropTypes.array.isRequired,
  /** The current country. Default is US */
  countryKey: PropTypes.string.isRequired,
  /** Id of the input field */
  id: PropTypes.string,
  /** If true, indicates a required field */
  isRequired: PropTypes.bool,
  /** The label for the Form element */
  label: PropTypes.node,
  /** The current market. Default is en-US */
  marketId: PropTypes.string.isRequired,
  /** name of the input, useful for form auto completion. Default is phone */
  name: PropTypes.string,
  /** Handles initial validation after component mounts, and handles input changes */
  onChangeHandler: PropTypes.func.isRequired,
  /** Current phone number with callingCode and lineNumber */
  phoneNumber: PropTypes.string,
  /** Text in form field before user input */
  placeholderText: PropTypes.string,
  /** If true, the component will not attempt to sort the countryData array. */
  presorted: PropTypes.bool,
  /**
   * A boolean or string to indicate if the input field is required. If
   * a string is provided, it will be used as the error message.
   */
  required: PropTypes.oneOfType([PropTypes.bool, PropTypes.node])
};

TelephoneInput.defaultProps = {
  isRequired: false,
  name: 'phone',
  presorted: false
};
