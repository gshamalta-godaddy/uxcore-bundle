import React from 'react';
import PropTypes from 'prop-types';
import FormElement from '@ux/form-element';
import Button from '@ux/button';

/**
 * Render multiple FormElements in a single fieldset.
 *
 * @displayName Form-Group
 *
 * @class Group
 * @public
 */
export default class Group extends React.Component {
  /**
   * Map and return data.inputs as FormElement components.
   *
   * @param {Object} properties Additional properties to spread on the element.
   * @returns {Array} Collection of FormElements.
   * @private
   */
  inputs(properties) {
    const { inputs, design } = this.props;

    return inputs.map((data, index) => {
      return <FormElement
        { ...data }
        { ...properties }
        design={ design }
        key={ index }
        type={ this.type }
        proxy
      />;
    });
  }

  // eslint doesn't like documenting return types for "abstract" functions
  /* eslint-disable valid-jsdoc */
  /**
   * Default view that can be rendered in react. Should be overruled for platform
   * specific rendering.
   *
   * @returns {React.DOM} A fieldset of form elements.
   * @public
   */
  get view() {
    throw new Error('View implementation required');
  }

  /**
   * Default type that can be rendered in react.
   * Should be overruled for platform specific rendering.
   *
   * @returns {String} The FormElement type to use
   * @public
   */
  get type() {
    throw new Error('Type implementation required');
  }
  /* eslint-enable valid-jsdoc */

  /**
   * Render the input elements
   *
   * @returns {React.DOM} A fieldset of form elements.
   * @private
   */
  render() {
    return this.view;
  }
}

/**
 * PropType validation for the component.
 *
 * @type {Object}
 * @private
 */
Group.propTypes = {
  /** Array of form-element props, one for each input rendered */
  inputs: PropTypes.array,
  /** Child components */
  children: PropTypes.node,
  /** Do not render the elements in fieldsets but use an empty div instead */
  proxy: PropTypes.bool,
  /** The design to use for the inputs, see @ux/button for design options */
  design: PropTypes.oneOf(Button.designs)
};
