"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.UX_GROWL_DELAY_MS = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _dialog = _interopRequireDefault(require("@ux/dialog"));

var _button = _interopRequireDefault(require("@ux/button"));

var _legacy = require("./legacy");

const _excluded = ["dismiss", "lifetime"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const UX_GROWL_CLASSNAME = 'ux-growl';
const UX_GROWL_DELAY_MS = '--uxGrowl-message--delayMilliseconds';
/**
 * Toggles the animation for the messages
 *
 * @param {Object} config - Configuration object
 * @param {Element} config.currentTarget - The DOM node to check
 * @param {Number} config.lifetime - How long the message should persist for
 * @returns {Boolean} - Whether or not the animation is active
 */

exports.UX_GROWL_DELAY_MS = UX_GROWL_DELAY_MS;

function toggleAnimationTrigger(_ref) {
  let {
    currentTarget,
    lifetime
  } = _ref;
  const exists = hasDismissal({
    currentTarget,
    lifetime
  });
  !isNaN(lifetime) && currentTarget.style.setProperty(UX_GROWL_DELAY_MS, `${lifetime}ms`);
  return exists;
}
/**
 * Determines if the dismissal animation should exist
 *
 * @param {Object} config - Configuration object
 * @param {Element} config.currentTarget - The DOM node to check
 * @param {Number} config.lifetime - How long the message should persist for
 * @returns {Boolean} - Whether or not the dismissal animation is applied
 */


function hasDismissal(_ref2) {
  let {
    currentTarget,
    lifetime
  } = _ref2;
  return !isNaN(lifetime) && Boolean(currentTarget.style.getPropertyValue(UX_GROWL_DELAY_MS));
}
/**
 * Controls when the dismissal should pause
 *
 * @param {Object} config - Configuration object
 * @param {Element} config.currentTarget - The DOM node to check
 * @param {Number} config.lifetime - How long the message should persist for
 * @param {Boolean} config.active - Whether or not to pause the dismissal
 */


function pauseDismissal(_ref3) {
  let {
    currentTarget,
    lifetime,
    pause
  } = _ref3;
  // If the message persists, do nothing
  if (!hasDismissal(currentTarget, lifetime)) return; // Otherwise, we stop the dismissal animation from running while active

  if (pause) {
    currentTarget.style.setProperty('animation-name', 'none');
  } else {
    currentTarget.style.removeProperty('animation-name');
  }
}
/**
 * A wrapper for the <Dialog/> component which adds animation
 *
 * @param {Function} dismiss - Function which dismisses the message by id
 * @param {Number} lifetime - How long the message should persist for
 * @param {String} emphasis - Describes the importance of the message
 * @returns {Component} - <Message/> component with a <Dialog/>
 */


const Message = /*#__PURE__*/(0, _react.memo)(_ref4 => {
  let {
    dismiss,
    lifetime
  } = _ref4,
      rest = (0, _objectWithoutProperties2.default)(_ref4, _excluded);
  const {
    id
  } = rest;

  const onAnimationEnd = _ref5 => {
    let {
      currentTarget
    } = _ref5;
    toggleAnimationTrigger({
      currentTarget,
      lifetime
    }) && dismiss(id);
  };

  const userEventIn = _ref6 => {
    let {
      currentTarget
    } = _ref6;
    pauseDismissal({
      currentTarget,
      lifetime,
      pause: true
    });
  };

  const userEventOut = _ref7 => {
    let {
      currentTarget
    } = _ref7;
    pauseDismissal({
      currentTarget,
      lifetime,
      pause: false
    });
  };

  return /*#__PURE__*/_react.default.createElement("li", {
    className: `${UX_GROWL_CLASSNAME}-message`,
    onFocus: userEventIn,
    onBlur: userEventOut,
    onMouseEnter: userEventIn,
    onMouseLeave: userEventOut,
    onAnimationEnd: onAnimationEnd
  }, /*#__PURE__*/_react.default.createElement(_dialog.default, (0, _extends2.default)({
    role: "alert",
    stretch: true,
    onClose: () => dismiss(id)
  }, rest)));
});
Message.propTypes = {
  /** Function which dismisses the message by id */
  dismiss: _propTypes.default.func,

  /** How long the message should persist for */
  lifetime: _propTypes.default.number
};
let preloadedMessages = [];
/**
 * Create a <Growl/> component
 *
 * @param {Object} props - Configuration object
 * @param {String} [props.closeLabel] - Label for the button to clear messages
 * @returns {Component} - <Growl/> component
 */

function Growl() {
  let {
    closeLabel
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const [messages, setMessages] = (0, _react.useState)([]);
  const addMessage = (0, _react.useCallback)(message => setMessages(prevMessages => prevMessages.concat((0, _legacy.transform)(message))), []);
  const removeMessage = (0, _react.useCallback)(id => setMessages(prevMessages => prevMessages.filter(message => message.id !== id)), []);
  (0, _react.useEffect)(() => {
    Growl.__mounted++;

    const onUnmountCleanup = () => Growl.__mounted--;

    if (Growl.__mounted > 1) {
      process.env.NODE_ENV !== 'production' && console.warn('<Growl /> has been mounted more than once. This may produce undefined behavior and overlapping or doubled messages.');
    }

    Growl.addGrowlMessage = addMessage;
    Growl.removeGrowlMessage = removeMessage;

    while (preloadedMessages.length > 0) {
      Growl.addGrowlMessage(preloadedMessages.shift());
    }

    return onUnmountCleanup;
  }, []); // eslint-disable-line react-hooks/exhaustive-deps
  // The above disabled exhaustive-deps becuase addMessage and removeMessage are stable due to useCallback

  const clearButton = /*#__PURE__*/_react.default.createElement(_button.default, {
    className: `${UX_GROWL_CLASSNAME}-clear`,
    text: closeLabel || 'Close All',
    onClick: () => setMessages([]),
    design: "primary"
  });

  const growl = /*#__PURE__*/_react.default.createElement("div", {
    className: `${UX_GROWL_CLASSNAME}-shell`,
    "aria-live": "polite"
  }, messages.length > 1 && clearButton, /*#__PURE__*/_react.default.createElement("ul", {
    className: `${UX_GROWL_CLASSNAME}-messages`
  }, messages.map(props => /*#__PURE__*/_react.default.createElement(Message // eslint-disable-next-line react/prop-types
  , (0, _extends2.default)({
    key: props.id // Always use the internal remove message instead of Growl.removeGrowlMessage in case of a double mount.
    ,
    dismiss: removeMessage
  }, props)))));

  return messages.length ? /*#__PURE__*/_reactDom.default.createPortal(growl, document.body) : null;
} // Initial function to warn when the <Growl/> is not yet mounted


Growl.addGrowlMessage = config => {
  // eslint-disable-next-line max-len
  process.env.NODE_ENV !== 'production' && console.warn('You attemped to add a growl message before <Growl /> was mounted and ready. We will attempt to replay this message when <Growl /> is finally mounted.', config);
  preloadedMessages.push(config);
};

Growl.removeGrowlMessage = id => {
  // eslint-disable-next-line max-len
  process.env.NODE_ENV !== 'production' && console.warn('You attemped to remove a growl message before <Growl /> was mounted and ready. We will attempt to remove this message from the replay.', id);
  preloadedMessages = preloadedMessages.filter(message => message.id !== id);
};

Growl.__mounted = 0;
Growl.propTypes = {
  /** Label for the button to clear messages */
  closeLabel: _propTypes.default.string
};
var _default = Growl;
exports.default = _default;