/* eslint-disable no-process-env, no-console */
import React, { useState, memo, useEffect, useCallback } from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import Dialog from '@ux/dialog';
import Button from '@ux/button';
import { transform } from './legacy';

const UX_GROWL_CLASSNAME = 'ux-growl';
export const UX_GROWL_DELAY_MS = '--uxGrowl-message--delayMilliseconds';

/**
 * Toggles the animation for the messages
 *
 * @param {Object} config - Configuration object
 * @param {Element} config.currentTarget - The DOM node to check
 * @param {Number} config.lifetime - How long the message should persist for
 * @returns {Boolean} - Whether or not the animation is active
 */
function toggleAnimationTrigger({ currentTarget, lifetime }) {
  const exists = hasDismissal({ currentTarget, lifetime });
  !isNaN(lifetime) && currentTarget.style.setProperty(UX_GROWL_DELAY_MS, `${lifetime}ms`);
  return exists;
}

/**
 * Determines if the dismissal animation should exist
 *
 * @param {Object} config - Configuration object
 * @param {Element} config.currentTarget - The DOM node to check
 * @param {Number} config.lifetime - How long the message should persist for
 * @returns {Boolean} - Whether or not the dismissal animation is applied
 */
function hasDismissal({ currentTarget, lifetime }) {
  return !isNaN(lifetime) && Boolean(currentTarget.style.getPropertyValue(UX_GROWL_DELAY_MS));
}

/**
 * Controls when the dismissal should pause
 *
 * @param {Object} config - Configuration object
 * @param {Element} config.currentTarget - The DOM node to check
 * @param {Number} config.lifetime - How long the message should persist for
 * @param {Boolean} config.active - Whether or not to pause the dismissal
 */
function pauseDismissal({ currentTarget, lifetime, pause }) {
  // If the message persists, do nothing
  if (!hasDismissal(currentTarget, lifetime)) return;

  // Otherwise, we stop the dismissal animation from running while active
  if (pause) {
    currentTarget.style.setProperty('animation-name', 'none');
  } else {
    currentTarget.style.removeProperty('animation-name');
  }
}

/**
 * A wrapper for the <Dialog/> component which adds animation
 *
 * @param {Function} dismiss - Function which dismisses the message by id
 * @param {Number} lifetime - How long the message should persist for
 * @param {String} emphasis - Describes the importance of the message
 * @returns {Component} - <Message/> component with a <Dialog/>
 */
const Message = memo(({ dismiss, lifetime, ...rest }) => {
  const { id } = rest;

  const onAnimationEnd = ({ currentTarget }) => { toggleAnimationTrigger({ currentTarget, lifetime }) && dismiss(id); };
  const userEventIn = ({ currentTarget }) => { pauseDismissal({ currentTarget, lifetime, pause: true }); };
  const userEventOut = ({ currentTarget }) => { pauseDismissal({ currentTarget, lifetime, pause: false }); };
  return (
    <li
      className={ `${UX_GROWL_CLASSNAME}-message` }
      onFocus={ userEventIn }
      onBlur={ userEventOut }
      onMouseEnter={ userEventIn }
      onMouseLeave={ userEventOut }
      onAnimationEnd={ onAnimationEnd }>
      <Dialog role='alert' stretch={ true } onClose={ () => dismiss(id) } { ...rest }/>
    </li>
  );
});

Message.propTypes = {
  /** Function which dismisses the message by id */
  dismiss: PropTypes.func,
  /** How long the message should persist for */
  lifetime: PropTypes.number
};

let preloadedMessages = [];

/**
 * Create a <Growl/> component
 *
 * @param {Object} props - Configuration object
 * @param {String} [props.closeLabel] - Label for the button to clear messages
 * @returns {Component} - <Growl/> component
 */
function Growl({ closeLabel } = {}) {
  const [messages, setMessages] = useState([]);

  const addMessage = useCallback((message) => setMessages(prevMessages => prevMessages.concat(transform(message))), []);
  const removeMessage = useCallback((id) => setMessages(prevMessages => prevMessages.filter((message) => message.id !== id)), []);

  useEffect(() => {
    Growl.__mounted++;
    const onUnmountCleanup = () => Growl.__mounted--;

    if (Growl.__mounted > 1) {
      process.env.NODE_ENV !== 'production' && console.warn('<Growl /> has been mounted more than once. This may produce undefined behavior and overlapping or doubled messages.');
    }

    Growl.addGrowlMessage = addMessage;
    Growl.removeGrowlMessage = removeMessage;

    while (preloadedMessages.length > 0) {
      Growl.addGrowlMessage(preloadedMessages.shift());
    }

    return onUnmountCleanup;
  }, []); // eslint-disable-line react-hooks/exhaustive-deps
  // The above disabled exhaustive-deps becuase addMessage and removeMessage are stable due to useCallback

  const clearButton = (
    <Button
      className={ `${UX_GROWL_CLASSNAME}-clear` }
      text={ closeLabel || 'Close All' }
      onClick={ () => setMessages([]) }
      design='primary'/>
  );

  const growl = (
    <div className={ `${UX_GROWL_CLASSNAME}-shell` } aria-live='polite'>
      { messages.length > 1 && clearButton }
      <ul className={ `${UX_GROWL_CLASSNAME}-messages` }>
        { messages.map((props) => (
          <Message
            // eslint-disable-next-line react/prop-types
            key={ props.id }
            // Always use the internal remove message instead of Growl.removeGrowlMessage in case of a double mount.
            dismiss={ removeMessage }
            { ...props }/>
        )) }
      </ul>
    </div>
  );

  return messages.length ? ReactDOM.createPortal(growl, document.body) : null;
}

// Initial function to warn when the <Growl/> is not yet mounted
Growl.addGrowlMessage = (config) => {
  // eslint-disable-next-line max-len
  process.env.NODE_ENV !== 'production' && console.warn('You attemped to add a growl message before <Growl /> was mounted and ready. We will attempt to replay this message when <Growl /> is finally mounted.', config);
  preloadedMessages.push(config);
};

Growl.removeGrowlMessage = (id) => {
  // eslint-disable-next-line max-len
  process.env.NODE_ENV !== 'production' && console.warn('You attemped to remove a growl message before <Growl /> was mounted and ready. We will attempt to remove this message from the replay.', id);
  preloadedMessages = preloadedMessages.filter((message) => message.id !== id);
};

Growl.__mounted = 0;

Growl.propTypes = {
  /** Label for the button to clear messages */
  closeLabel: PropTypes.string
};

export default Growl;
