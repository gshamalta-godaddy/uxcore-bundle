"use strict";

var _react = _interopRequireWildcard(require("react"));

var _svgosm = require("./svgosm.js");

var _propTypes = _interopRequireDefault(require("prop-types"));

const _excluded = ["width", "height", "placeholder", "className", "title", "desc", "role"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * Detect if we are running in a Node.js environment.
 *
 * @type {Boolean}
 * @private
 */
const isNode = !!(typeof process !== 'undefined' && process.versions && process.versions.node);
/**
 * Generates our dedicated Icon component.
 *
 * @param {String} displayName Name of the Icon.
 * @param {String} deprecated Indication if the icon should be deprecated
 * @returns {React.Component} The React Component.
 * @public
 */

module.exports = function create(displayName, deprecated) {
  const warned = {};
  /**
   * The base component that renders the Icon.
   *
   * @constructor
   * @param {Object} props All the props
   * @param {Number} props.width Width of the icon.
   * @param {Number} props.height Height of the icon.
   * @param {String} props.className Class name of the icon.
   * @param {String} props.title A11y title of the icon.
   * @param {String} props.desc A11y description of the icon.
   * @param {String} props.role A11y role for the icon.
   * @param {Object} props.placeholder Information used to statically render the icon.
   * @param {Object} props.props The rest of the props that are spread on the <use> tag.
   * @param {React.Ref} ref Forwarding reference
   * @private
   */

  const Fwd = /*#__PURE__*/_react.default.forwardRef(function Icon(_ref, ref) {
    let {
      width = '1.5em',
      height = '1.5em',
      placeholder,
      className,
      title,
      desc,
      role = 'presentation'
    } = _ref,
        rest = _objectWithoutProperties(_ref, _excluded);

    const [sym, setSymbol] = (0, _react.useState)(placeholder); //
    // We use the useEffect hook to bypass the SSR hydration warnings. In a SSR
    // application we do not have access to the icon information as that is
    // extracted from the CSS. Nor do we want to duplicate the content in
    // HTML as that means we're shipping the icons multiple times to our users.
    //

    (0, _react.useEffect)(function retry() {
      const res = _svgosm.svgosm.get(displayName, function extract() {
        const details = _svgosm.svgosm.extract(`uxp-icon-${displayName}`);

        if (!details) return;
        return Object.assign(details, {
          title: title,
          desc: desc
        });
      });

      if (res) return setSymbol(res); //
      // If we don't have a result from the svg manager it's most likely caused
      // by missing CSS so we're going to advice the user, only dev/test,
      // in the browser (because we don't care bout node.js env) that they need
      // to import the CSS.
      //

      if (process.env.NODE_ENV !== 'production' && !isNode && !warned.css) {
        console.log(`Unable to render the icon, did you forget to include the required css? @ux/icon/${displayName}/index.(css|scss)?`);
        warned.css = true;
      }
    }, [displayName]); //
    // Return early with no content if there isn't any icon to render.
    //

    if (!sym) return null;
    const props = {};
    const svg = {
      className: ['uxicon-svg-container', className].join(' ').trim(),
      height: height || sym.height,
      width: width || sym.width,
      role,
      ref
    }; //
    // Extract the `aria-` prefixed props from the supplied props as they
    // need to be applied to the <svg> element, the rest of the props
    // need to be applied to the <use> element, for styling purposes.
    //

    Object.keys(rest).forEach(function propSort(key) {
      if (key.startsWith('aria-') || key.startsWith('data-')) svg[key] = rest[key];else props[key] = rest[key];
    }); //
    // When no `aria-labelledby` is provided to us, but we did receive a title
    // or a desc, we're going to generate the correct aria- role by default.
    //

    if (!svg['aria-labelledby'] && (title || desc)) {
      const unique = sym.link.slice(1);
      const labels = [];
      if (title) labels.push(`${unique}-title`);
      if (desc) labels.push(`${unique}-desc`);
      svg['aria-labelledby'] = labels.join(' ');
    }

    return /*#__PURE__*/_react.default.createElement("svg", svg, /*#__PURE__*/_react.default.createElement("use", _extends({
      fill: "currentColor"
    }, props, {
      xlinkHref: sym.link
    })));
  }); //
  // Ease debugging.
  //


  Fwd.displayName = displayName + 'Icon';
  /**
   * PropType validation.
   *
   * @type {Object}
   * @private
   */

  Fwd.propTypes = {
    width: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
    height: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
    placeholder: _propTypes.default.shape({
      link: _propTypes.default.string
    }),
    className: _propTypes.default.string,
    desc: _propTypes.default.string,
    title: _propTypes.default.string,
    role: _propTypes.default.string
  }; //
  // Ensure that this is not active in production environments, should be
  // auto deleted by minifiers.
  //

  if (process.env.NODE_ENV !== 'production') {
    //
    // Please note that the icon is passed as string because of our
    // {namespace:field} template pattern. The files are processed with babel
    // which thinks it's an object pattern and reformats it as a pretty object
    // which breaks the template engine. So we're just gonna pass it as string
    // to work around that limitation.
    //
    if (deprecated === 'true' && !warned.dep) {
      console.log(`The icon "${displayName}" is deprecated and will be removed in the next major release of @ux/icon`);
      warned.dep = true;
    }
  }

  return Fwd;
};