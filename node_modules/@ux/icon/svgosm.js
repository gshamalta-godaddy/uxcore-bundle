"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.svgosm = exports.default = exports.SVGOSM = void 0;
const _excluded = ["viewBox", "title", "desc", "shapes"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * Our default root element.
 *
 * @type {DOMElement|Null}
 * @private
 */
const html = typeof document !== 'undefined' ? document.body || document.documentElement : null;
/**
 * SVG Object Storage Manager (SVGOSM) attempts to reduce the SVG DOM footprint
 * by moving all SVG objects into symbols so they can be re-used without having
 * to inject the full SVG structure in multiple places.
 *
 * @class
 * @param {String} name Name, id of the container to inject.
 * @public
 */

class SVGOSM {
  constructor(name, root = html) {
    this.id = name; // Name of the container.

    this.tracker = {}; // Storage tracker to reduce DOM lookup.

    this.mounted = []; // List of all roots we need to operate in.

    this.root = root;
  }
  /**
   * Inject a new SVG element into a given root that is going to be used as
   * storage for all our new symbols so they can be referenced in our HTML.
   *
   * @param {DOMElement} root Container we need to mount in.
   * @public
   */


  mount(root) {
    const container = document.createElement('div');
    container.style = 'display:none';
    container.id = this.id;
    const svg = document.createElementNS(SVGOSM.xmlns, 'svg');
    container.appendChild(svg);
    root.appendChild(container);
    this.mounted.push({
      svg,
      root,
      container
    }); //
    // Populate with other discovered icons.
    //

    Object.keys(this.tracker).forEach(key => {
      svg.innerHTML += this.tracker[key].sym;
    });
  }
  /**
   * Extract information out the CSS of a given HTML element and extract the svg
   * content and the size of the element.
   *
   * @param {String} name Name of the CSS variable we need to extract.
   * @returns {Object|Undefined} The resulting information.
   * @public
   */


  extract(name) {
    if (!name) return;
    let match;

    if (this.root) {
      this.mount(this.root);
      this.root = null;
    }

    this.mounted.some(function search({
      container
    }) {
      const style = window.getComputedStyle(container, ':before');
      const cssvar = name.startsWith('--') ? name : `--${name}`;
      const cssvarvalue = style.getPropertyValue(cssvar);
      let content = style.getPropertyValue('content'); //
      // BLACK MAGIC WARNING: The following blocks provide the following:
      //
      // - Provide backwards compatibility to content: url(svg)
      // - Bail out of old font based content: "\char" properties
      // - Prefer cssvariable values over old content: url() as they can
      //   be overridden for white labels.
      //
      // The big problem here is that `content` can really be anything, it can
      // be `none`, it can be `''`, even `normal` when nothing is assigned to it
      // depending on the element it receives. So we need to figure out _when_
      // to bail out.
      //
      // Browsers also handle reading out the `content` property differently,
      // literally all over the place. Some encode the content, include the
      // quotes that are wrapped around the content, others just include the
      // actual string. So, we just want to normalize this to what ever we want
      // to validate against, which is a single character.
      //

      if (content.length === 3) content = content.charAt(1);

      if (content) {
        if (content.includes('svg')) {
          match = content;
        } else if (content.length === 1 && !/[a-z\d]/i.test(content)) {
          //
          // The contents of icon fonts would be a unicode wrapped in quotes. So
          // if it's 3 chars length (not binary size), and the 2nd character is
          // not alphabetical or a number, it must be unicde char and we should
          // proceed to **not** transform anything here.
          //
          return !!match;
        }
      } //
      // If a CSS variable is defined it should always be used as SVG contents.
      // When we found absolutely nothing at this point, bail out.
      //


      if (cssvarvalue && cssvarvalue.includes('svg')) match = cssvarvalue;
      return !!match;
    });
    if (!match) return;
    return this.parse(match);
  }
  /**
   * Parses the given SVG string and extracts contents.
   *
   * @param {String} str The encoded SVG string.
   * @returns {Object} Parsed SVG result.
   * @private
   */


  parse(str) {
    if (!~str.indexOf('svg')) return {};
    str = decodeURI(str).replace(/%23/g, '#').replace(/\\"/g, '"');
    const start = str.indexOf('>');
    const finish = str.indexOf('</svg>');
    const result = /viewBox=.*?([\d\s.]+)/.exec(str.substr(0, start));
    if (!result) return {};
    return {
      shapes: str.slice(start + 1, finish),
      viewBox: result[1]
    };
  }
  /**
   * Returns the correct reference to the object.
   *
   * @param {String} name The name of the object we want to use.
   * @param {Function} [fn] Sets the value if there isn't any.
   * @returns {Object|Null} The value that should be used in the `xlink:href` attr.
   * @public
   */


  get(name, fn) {
    const res = this.tracker[name];
    if (res || !fn) return res;
    this.set(name, fn(name));
    return this.tracker[name];
  }
  /**
   * Store a new Symbol in our managed SVG object.
   *
   * @param {String} name Name of the symbol.
   * @param {Object} data Detailed information about the symbol.
   * @param {String} data.viewBox The viewBox of the symbol.
   * @param {String} data.title Title of the symbol.
   * @param {String} data.desc Description of the symbol.
   * @param {String} data.shapes The actual symbol that need to be stored.
   * @returns {Boolean} Indication if the shape was inserted.
   * @public
   */


  sym(name, _ref = {}) {
    let {
      viewBox,
      title,
      desc,
      shapes
    } = _ref,
        data = _objectWithoutProperties(_ref, _excluded);

    if (!shapes) return false;
    const uid = `${this.id}-${name}`;
    const a11ytitle = title ? `<title id="${uid}-title">${title}</title>` : '';
    const a11ydesc = desc ? `<desc id="${uid}-desc">${desc}</desc>` : '';
    const sym = `<symbol id="${uid}" viewBox="${viewBox}">${a11ytitle}${a11ydesc}${shapes}</symbol>`;
    this.tracker[name] = _objectSpread(_objectSpread({}, data), {}, {
      link: `#${this.id}-${name}`,
      viewBox,
      sym
    });
    return sym;
  }
  /**
   * Store a new Symbol in our managed SVG object.
   *
   * @param {String} name Name of the symbol.
   * @param {Object} data Detailed information about the symbol.
   * @returns {Boolean} Indication if the shape was inserted.
   * @public
   */


  set(name, data) {
    const sym = this.sym(name, data);
    if (!sym) return false;

    if (this.root) {
      this.mount(this.root);
      this.root = null;
    }

    this.mounted.forEach(({
      svg
    }) => {
      svg.innerHTML += sym;
    });
    return true;
  }

}
/**
 * The XML namespace.
 *
 * @type {String}
 * @private
 */


exports.SVGOSM = exports.default = SVGOSM;
SVGOSM.xmlns = 'http://www.w3.org/2000/svg';
/**
 * Pre-create an instance.
 *
 * @type {SVGOSM}
 * @public
 */

const svgosm = new SVGOSM('svg-container');
exports.svgosm = svgosm;