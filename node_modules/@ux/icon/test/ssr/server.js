const { createFsFromVolume, Volume } = require('memfs');
const ReactDOMServer = require('react-dom/server');
const webpack = require('webpack');
const React = require('react');
const path = require('path');
const http = require('http');
const App = require('./app');

/**
 * Port number for our server.
 *
 * @type {Number}
 * @private
 */
const port = 9921;

/**
 * Our webpack configuration.
 *
 * @type {Object}
 */
const compiler = webpack({
  mode: 'development',
  entry: [

    //
    // Just to make it easy on our selfs, we're going to make the CSS file an
    // entry file so it gets included with the client bundle so we don't throw
    // any errors server side when we attempt to load a css file in our app
    // code.
    //
    // Note that order of inclusion does matter here. By assigning the css
    // file first it will be executed and applied **before** our application
    // code is rendered, as this is a condition that trigger potential SSR
    // warnings.
    //
    path.join(__dirname, '../../cloud-upload/index.css'),
    path.join(__dirname, 'client.js')
  ],
  output: {
    filename: 'bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader']
      }
    ]
  }
});

//
// Configure a fake output system so it doesn't write our compiled files to
// disk but to memory instead so we can return them.
//
// WebPack assumes the existance of a `join` method, which does not exist on
// file system API's so we need to forcefully assign one.
//
compiler.outputFileSystem = createFsFromVolume(new Volume());
compiler.outputFileSystem.join = require('memory-fs/lib/join');

/**
 * Our server that renders our example.
 *
 * @param {HTTPRequest} _req Incoming HTTP request.
 * @param {HTTPResponse} res Outgoing HTTP response.
 * @private
 */
const server = http.createServer(async function respond(_req, res) {
  compiler.run((err, stats) => {
    if (err || stats.hasErrors()) {
      res.writeHead(500, {
        'Content-Type': 'text/html'
      });

      console.log(err);
      return res.end('Failed to build <br />' + stats.toString());
    }

    res.writeHead(200, {
      'Content-Type': 'text/html'
    });

    //
    // Dive into our memory filesystem to extract the by webpack created
    // output file
    //
    const outputOptions = stats.compilation.outputOptions;
    // eslint-disable-next-line no-sync
    const asset = compiler.outputFileSystem.readFileSync(path.join(outputOptions.path, outputOptions.filename));

    res.end(`
      <!DOCTYPE html>
      <html>
        <head><title>SSR Test</title></head>
        <body>
          <div id="root">${ReactDOMServer.renderToString(React.createElement(App))}</div>
          <script>${asset}</script>
        </body>
      </html>
    `);
  });
});

//
// When the server is required directly we're just going to run it on our
// default port number. When it's required we're going to let the module that
// consumes our server to deal with it.
//
module.exports = server;
if (module !== require.main) return;

server.listen(port, function started() {
  console.log('server ready on: http://localhost:' + port);
});
