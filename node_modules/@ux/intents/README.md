# Intents

This is probably the most unique concept in the system, as it aims to solve a few problems.

## Overview

**Intents** are a representation of what the designer wants to convey when applying a style change. Consider the following CSS:

```css
.my-button {
  color: white;
  background-color: blue;
}
.my-button.is-critical {
  color: white;
  background-color: red;
}
```

In this example, the designer wants to convey that the button is in a critical state. The designer decides to display this state by changing the color of the background to red. The engineer coding the button needs to either ask the designer or find the proper color to be used for the button's different states. Now consider the use of intents:

```css
.my-button {
  color: var(--uxButton--foregroundColor);
  background-color: var(--uxButton--backgroundColor);
}
.my-button.is-critical {
  color: var(--uxButtonCritical--foregroundColor);
  background-color: var(--uxButtonCritical--backgroundColor);
}
```

In this example, the engineer only needs to apply the proper intent as the value for the property. In this way, the style of this property can be altered outside of the component globally from the theme level. We do not expect engineers to write out the CSS custom property name. Instead, we expect to export intents from this package for import into CSS-in-JS solutions.

## Usage

Very basic usage is described below:

```js
/* JS */
import Intents from '@ux/intents';
import { css } from 'linaria';

const intents = new Intents();
const button = css`{
  color: ${intents.ux.action.foregroundColor}; // var(--ux-action--foregroundColor)
  backgroundColor: ${intents.ux.action.backgroundColor}; // var(--ux-action--backgroundColor)
}`;
```

```scss
/* SCSS */
@import '~@ux/intents/lib/index';

.my-button {
  color: $ux-action-foregroundColor;
  background-color: $ux-action-backgroundColor;
}
```

We expect engineers to use intents on any property a theme could affect. This is typically for color, typography but could include other CSS properties like `border-radius`. A list of intents can be found in the [`./intentlist.json`](./intentlist.json) file.

### Theme intents
After creating a new instance of intents (`new Intents()`), you are provided with a large set of intents to style your component. These are **theme** intents as you cannot apply a default value to these. The following intent features (under `ux`) are provided.

### `text`
Describes text, specifically font properties:  `fontFamily` `fontSize` `lineHeight` `fontWeight`.
* **`text`** - describes the font of the body of the app, you can think of this as the styles would set on the `<body/>`.
* **`textParagraph`** - describes the font properties of paragraphs.
* **`textHeading`** - describes the font properties of headings.
* **`textTitle`** - describes the font properties of titles.
* **`textLabel`** - describes the font properties of labels for control components.
* **`textAction`** - describes the font properties for touchable items.
* **`textInput`** - describes the font properties in area where the user can type.
* **`textCaption`** - describes the font properties of text that is not the main focus of the component, ie help text.

Example: `intents.ux.textTitle.fontSize`

### `box`
Describes containers with the following properties: `backgroundColor` `foregroundColor` `borderColor` `outlineColor`, `borderRadius`, `borderWidth`.
* **`box`** - describes the look of the body of the app, you can think of this as the styles you would set on the `<body/>`.
* **`boxLowContrast`** - describes the look of a box made to complement the look of the `box` styles with a low contrast to the colors provided to the `box`. For example if `box.backgroundColor` is set to `#fff`, `boxLowContrast.backgroundColor` might be set to `#ddd`.
* **`boxHighContrast`** - describes the look of a box made to complement the look of the `box` styles with a high contrast to the colors provided to the `box`. For example if `box.backgroundColor` is set to `#fff`, `boxHighContrast.backgroundColor` might be set to `#111`.
* **`boxLowContrastOverlay`** - describes the look of a box made to complement the look of the `box` styles with a low contrast to the colors provided to the `box` and meant to appear on top of it with a slight transparency.
* **`boxHighContrastOverlay`** - describes the look of a box made to complement the look of the `box` styles with a high contrast to the colors provided to the `box` and meant to appear on top of it with a slight transparency.

Example: `intents.ux.boxLowContrast.backgroundColor`

### `action`
Describes clickable boxes with all of the properties of `box`. These may also include Expressions and Interactive modifiers.
* **`action`** - describes the look of general clickable target; a canonical button. Assume that this does not have a level of hierarchy in comparison to primary and secondary below.
* **`actionPrimary`** - describes the look of the primary clickable target within the app.
* **`actionSecondary`** - describes the look of the secondary clickable target within the app.
* **`actionControl`** - describes the look of the clickable target within a form control.

Example: `intents.ux.actionPrimary.foregroundColor`

### `navigate`
Describes clickable areas of siblings used for navigation with all of the properties of `action`. These may also include Expressions and Interactive modifiers. This category also includes the `textDecoration` property to decorate links as navigational items.
* **`navigate`** - describes the look of general clickable navigation item; a canonical link (`<a/>`). Assume that this does not have a level of hierarchy in comparison to primary and secondary below.
* **`navigatePrimary`** - describes the look of the primary clickable navigation item within the app.
* **`navigateSecondary`** - describes the look of the secondary clickable navigation item within the app.

Example: `intents.ux.navigatePrimary.foregroundColor`

### `control`
Describes interactive boxes for typing or selecting most commonly found in a `<form/>` with all of the properties of `box`. These may also include Expressions and Interactive modifiers.
* **`control`** - describes the look of a general interactive field. You can consider this what an `<input/>` tag would look like.
* **`controlKnob`** - describes the look of an interactive handle of a control, usually found in a toggle or slider.
* **`controlVoid`** - describes the look of non-interactive parts of the interactive field, ie. placeholder.

Example: `intents.ux.controlChosenHovered.borderColor`

### `feedback`
Describes boxes that display an accent based on a state with all of the properties of `box`. These may also include Interactive modifiers.
* **`feedback`** - describes a component or part of a component that displays feedback, ie. progress bar. The `feedbackColor` (`enums.properties.FEEDBACK_COLOR`) should map to the accent color of feedback. For example, for a critical state, you can assume this maps to a red color. This color can map to any color-related CSS property (`color`, `background-color`, `border-color` etc) within the CSS. There is also an associated `onFeedbackColor` to represent a color that can be used as the foreground color when the `feedbackColor` is applied as a background color.
* **`feedbackCritical`** - describes a component that is in a "critical" state, either error or danger.
* **`feedbackWarning`** - describes a component that is in a "warning" state.
* **`feedbackSuccess`** - describes a component that is in a "success" state.
* **`feedbackInfo`** - describes a component providing info which may differ from the accent provided by the default `feedback` accent.
There are additional feedback intents. The ones listed above are the most common. You can find a list under the expressions within the `src/theme-intents/feedback.js` file of this project.

Each of these also includes a high contrast version expected to be used when the color should contrast the `box` color. Example using `intents.ux.feedbackHighContrastCritical.feedbackColor` for error text.

Example: `intents.ux.feedbackCritical.feedbackColor`</br>
Example: `intents.ux.feedbackCritical.onFeedbackColor`

### `figure`
Describes boxes that exhibit data or illustrations where color is used to segregate data. The number of intents here will vary but begin with `figureColor`(`enums.properties.FIGURE_COLOR`) . The additional colors used within the component should be defined from `box` (background color, foreground color etc).

This group of intents increments starting at `0` to `19` (20 colors in total). Additional colors may be added by increasing the amount required within the config for `figure`.

Example `intents.ux.figure.figureColor12`</br>
Example `intents.ux.figure.figureColor5`

### Style Properties
The following style properties are to be used in intent naming:

* `backgroundColor`
* `foregroundColor`
* `borderColor`
* `outlineColor`
* `fontFamily`
* `fontSize`
* `lineHeight`
* `fontWeight`
* `borderRadius`
* `borderWidth`

### Component Intents

In order to create intents that are specific to a component, you can use the `.create()` method on the intent instance (more on this below). Additional intents will be added to the instance and are called **component** intents. You can assign a default value by assigning a string or intent to the object.

```js
import { css } from 'linaria';
import Intents, { enums }  from '@ux/intents';

const intents = new Intents();

intents.create('@ux/button', {
  expressions: [enums.expressions.DISABLED],
  interactions: [enums.interactions.HOVERED],
  styleProperties: [
    enums.properties.BACKGROUND_COLOR,
    enums.properties.FOREGROUND_COLOR,
  ]
});

intents.uxButton.backgroundColor = 'white';
intents.uxButton.foregroundColor = intents.ux.action.foregroundColor;

const button = css`{
  color: ${intents.uxButton.foregroundColor}; // var(--uxButton--foregroundColor, var(--ux-action--foregroundColor))
  backgroundColor: ${intents.uxButton.backgroundColor}; // var(--uxButton--backgroundColor, white)
}`;
```

You could also create and import a `intents.config.js` file which describes the intents for a component as this configuration of intents might become exceptionally large.

```js
// intents.config.js within @ux/button component package
import Intents, { enums }  from '@ux/intents';

const intents = new Intents();

// Create component intents
intents.create('@ux/button', {
  expressions: [enums.expressions.DISABLED],
  interactions: [enums.interactions.HOVERED],
  styleProperties: [
    enums.properties.BACKGROUND_COLOR,
    enums.properties.FOREGROUND_COLOR,
  ]
});

// Assign the fallback values to the newly created intents, this might take a while...
intents.uxButton.backgroundColor = intents.ux.action.backgroundColor;
intents.uxButton.foregroundColor = intents.ux.action.foregroundColor;
intents.uxButtonDisabled.backgroundColor = intents.ux.actionDisabled.backgroundColor;
intents.uxButtonDisabled.foregroundColor = intents.ux.actionDisabled.foregroundColor;
intents.uxButtonHovered.backgroundColor = intents.ux.actionHovered.backgroundColor;
intents.uxButtonHovered.foregroundColor = intents.ux.actionHovered.foregroundColor;
intents.uxButtonDisabledHovered.backgroundColor = intents.ux.actionDisabledHovered.backgroundColor;
intents.uxButtonDisabledHovered.foregroundColor = intents.ux.actionDisabledHovered.foregroundColor;

module.exports = intents;
```

```js
// @ux/button index.js
import { css } from 'linaria';
import intents from './intents.config.js';

const buttonStyles = css`
  background-color: ${intents.uxButton.backgroundColor};
`;
```

Assigning a theme intent to a component intent opens that property up to being themed easily through `@ux/themes`. Assigning a specific value here means that the property can only be themed when targeting that specific CSS Custom Property and may not be covered within `@ux/themes`. In other words, **it is recommended to assign an appropriate theme intent to a component intent** directly after creating the component intents. Also, you can only assign a value **once** to an intent. This ensures a values that is set is the only applied value in the lifecycle of the intent expected.

### Ramifications of not assigning fallback values to component intents

If you attempt to apply a component intent within a CSS-in-JS solution without assigning a fallback value, the console will warn you.

```js
import { css } from 'linaria';
import Intents, { enums } from '@ux/intents';

const intents = new Intents();

intents.create('@ux/button', {
  styleProperties: [
    enums.properties.BACKGROUND_COLOR,
  ]
});

const buttonStyles = css`
  background-color: ${intents.uxButton.backgroundColor}; // var(--uxButton--backgroundColor)
`;
```

```
Fallback value not set for uxButton.backgroundColor
```

This component intent is not expected to be covered within every theme and therefore is susceptible to not having a value assigned. On the other hand, the theme intents are expected to have full coverage for each theme. Attempting to cover both the theme and all the library's component intents in one theme is a massive undertaking.

## Intent features

The following is an example of a composite component which includes a few features: [`@ux/accordion`](https://gxsys.uxp.int.godaddy.com/components/accordion).

```js
import { css } from 'linaria';
import Intents, { enums } from '@ux/intents';

const intents = new Intents();

intents.create('@ux/accordion', {
  styleProperties: [
    enums.properties.BORDER_COLOR,
  ],
  features: {
    [enums.features.TITLE]: {
      styleProperties: [
        enums.properties.FONT_SIZE,
        enums.properties.FONT_WEIGHT,
        enums.properties.FONT_FAMILY,
        enums.properties.FOREGROUND_COLOR,
      ]
    },
    [enums.features.CONTENT]: {
      enums.properties.BACKGROUND_COLOR,
      enums.properties.FOREGROUND_COLOR,
    }
  }
});

// Assuming you've set all of the defaults, such as:
intents.uxAccordion.borderColor = intents.ux.box.borderColor;

const accordionStyles = css`
  .uxAccordion-container {
    border-top-color: ${intents.uxAccordion.borderColor};
    border-bottom-color ${intents.uxAccordion.borderColor};
  }

  .uxAccordion-summary {
    font-family: ${intents.uxAccordion.title.fontFamily};
    font-weight: ${intents.uxAccordion.title.fontWeight};
    font-size: ${intents.uxAccordion.title.fontSize};
  }

  .uxAccordion-details {
    background-color: ${intents.uxAccordion.content.backgroundColor};
    color: ${intents.uxAccordion.content.foregroundColor};
  }
`;
```

In the above example, simply having intents to describe the main `@ux/accordion` component is not enough to fully cover the inner parts of the component. Intents can have inner parts called **features**. There are several common features that can describe the inner parts of _most_ components. These are found under the exported `enums` under the `features` key.

| Feature | Enum |Description | Example(s) |
| ------- | ---- | ----------- | ------- |
| `body` | `enums.features.BODY` | Describes container that is expected to be a main focus for the component and have **HTML elements inside** of it as opposed to only text. | `uxModal.body` |
| `content` | `enums.features.CONTENT` | Describes container that is expected to be a main focus for the component and have **text inside** of it as opposed to HTML. | `uxGrowl.content` `uxTooltip.content` |
| `description` | `enums.features.DESCRIPTION` | Describes a container that is expected to hold auxiliary, help, or error text. | `uxFormElement.description` |
| `label` | `enums.features.LABEL` | Describes a container that is expected to be associated with a single option within a control. Consider this the element that would go with a single checkbox, radio button, toggle switch, or menu item. | `uxToggle.label` |
| `indicator` | `enums.features.INDICATOR` | Describes a marker within the component, this could be something visual like a checkmark or text where a label is already defined. | `uxCheckbox.indicator` |
| `meter` | `enums.features.METER` | Describes a container that is used to display a value visually. | `uxProgressBar.meter` |
| `knob` | `enums.features.KNOB` | Describes a specific part of a component designed to be interactive. This can include the handle on a toggle or slider. | `uxSlider.knob` |
| `title` | `enums.features.TITLE` | Describes a container that is used to identify the main importance of the component or to group components under one named category. | `uxCollapsible.title` |
| `item` | `enums.features.ITEM` | Describes a container which is meant a sibling to others in the same group. | `uxOptionlist.item` |
| `backdrop` | `enums.features.BACKDROP` | Describes a container that is expected to be overlayed on top of content in order to reduce the content's importance. | `uxModal.backdrop` |

A few features may be very specific to the component. For example the `uxCalendar.date` should describe a single date box within the calendar. These names provide more descriptive context to the usage of the intent in these specific places.

```js
intents.create('@ux/calendar', {
  features: {
    date: {
      styleProperties: [enums.properties.FOREGROUND_COLOR]
    }
  }
});

intents.uxCalendar.date.foregroundColor = '#111';
```

## Outside of UXCore

Usage of `@ux/intents` is not bound strictly to UXCore components. Any component can import these variables for use in a CSS-in-JS solution.

```js
import styled from 'styled-components';
import Intents from '@ux/intents';

const intents = new Intents();

const Button = styled.button`
  background-color: ${intents.ux.action.backgroundColor};
`;
```

## Exports

### `Intent`
This is the class that provides the base theme intents and allows the ability to create component intents. On a new instance of Intents (`const intents = new Intents()`) there are a few methods you can use.

#### `intents.create(componentName, config)`
Creates a set of component intents. `componentName` is normalized and camelCased. The `config` takes a few params, all of which are optional:
* `config.expressions` - expects an array of expression enums (`enums.expressions`) for the permutations of intents.
* `config.interactions` - expects an array of interaction enums (`enums.interactions`) for the permutations of intents.
* `config.styleProperties` - expects an array of style property enums (`enums.properties`) for the permutations of intents.
* `config.features` - An object that is a key/value pair describing intent configs for inner parts of the larger component intents. Keys should be from the feature enums (`enums.features`) but may be created based on component specificity.

You can see the above examples of this `README` for usage.

#### `intents.enumerate(componentName)`
This returns a list of all of the intents that can be used within this instance of intents. Providing a `componentName` argument will filter only the intents which start with that name (this catches different expressions and interactions). With this argument, it will list all intents.

### `enums`
These are for usage within the `intents.create()` method.
* `enums.expressions` - list of expected expressions (states) for a component to exist in (eg.: `DISABLED`).
* `enums.interactions` - list of expected interactions for a component to be affected by (eg.: `FOCUSED`).
* `enums.properties` - list of expected style properties to be updated by an intent (eg.: `BACKGROUND_COLOR`).
* `enums.features` - list of common features that are found within components to be described by an intent (eg.: `TITLE`).

### `toCssCustomProperty(dotNotation)`
This method returns what the CSS Custom Property will be for a given intent. It goes through the following rules:

1. Drop the `intents.` prefix (if found).
1. Prefix with the CSS Custom Property prefix `--`.
1. Change each subsequent dot (`.`) to a hyphen (`-`).
1. When arriving at the style property, include an additional hyphen (`-`).

`intents.ux.textParagraph.fontSize` => `--ux-textParagraph--fontSize`

`intents.uxModal.title.foregroundColor` => `--uxModal-title--foregroundColor`

`intents.ux.actionCriticalHovered.borderColor` => `--ux-actionCriticalHovered--borderColor`

### Sass / SCSS
The package also provides the theme intents as Sass variables. The translation is the following:

`intents.ux.action.backgroundColor` -> `$ux-action-backgroundColor` -> `var(--ux-action--backgroundColor)`

This will resolve to a CSS Custom Property after the Sass is compiled; the same found when sending an intent through the [`toCssCustomProperty`](#toCssCustomProperty(dotNotation)) function. Note: the hyphens used between Sass variables and the final CSS Custom Property are not the same. 

While the variables provided have generic fallbacks, the Sass export also provides a mixin to override the fallback values in the event you need to support a specific brand primarily. We do not recommend planning to keep this function available as we fully transition to the intents system and all pages are loading themes.

```scss
body {
  /* This sets the background color of the <body/> to green IF no theme has been loaded */
  background-color: override-fallback($ux-box-backgroundColor, green);
}
```