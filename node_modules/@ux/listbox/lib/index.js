"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _siblingSet = _interopRequireDefault(require("@ux/sibling-set"));

var _mergeRefs = _interopRequireDefault(require("merge-refs"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable camelcase, id-length */
const UX_LISTBOX_CLASSNAME = 'ux-listbox';
/**
 * Given an array of item objects, a "current" id, and a "step" (1 for forward, -1 for back),
 * this function returns the subsequent id that should now gain focus
 *
 * @param {Array<Object>} items array of item objects
 * @param {String} currentId current item id to step away from
 * @param {Number} step direction (and amount) to step
 * @returns {String} the next id given the step
 */

function findSubsequentItemId(items, currentId) {
  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  const possibleIndex = items.findIndex(item => item.id === currentId);
  const currentIndex = possibleIndex === -1 ? 0 : possibleIndex;
  const nextIndex = Math.max(0, Math.min(items.length - 1, currentIndex + step));
  return items[nextIndex].id;
}
/**
 * Internal component for managing behaviors around list items
 *
 * @param {*} props ListboxItem Props
 * @returns {Component} ListboxItem
 */


function ListboxItem(props) {
  const {
    id,
    as,
    isSelected,
    isFocused,
    onSelect,
    children
  } = props;
  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events
    _react.default.createElement("div", {
      id: id,
      className: "ux-button",
      tabIndex: -1,
      role: as === 'menu' ? 'menuitem' : 'option',
      "data-visually-focused": isFocused || null,
      "aria-selected": isSelected || null,
      onClick: onSelect
    }, children)
  );
}

ListboxItem.propTypes = {
  /** Unique identifier for the item */
  id: _propTypes.default.string.isRequired,

  /** Determines the correct ARIA role for the item */
  as: _propTypes.default.string.isRequired,

  /** Item is chosen by the user */
  isSelected: _propTypes.default.bool.isRequired,

  /** Item is navigated to by the user */
  isFocused: _propTypes.default.bool.isRequired,

  /** Callback when the selection occurs */
  onSelect: _propTypes.default.func.isRequired,

  /** Content of the item */
  children: _propTypes.default.node.isRequired
};
/**
 *
 * @param {Object} props - Configuration object
 * @returns {Component} - <Listbox/> component
 */

const Listbox = /*#__PURE__*/_react.default.forwardRef(function Listbox(props, ref) {
  const {
    id,
    as = 'listbox',
    stretch,
    className,
    items = [],
    tabIndex = '0',
    onConfirm = Function.prototype,
    selected,
    onActiveItemChange = Function.prototype,
    loop = false,
    anchorRef
  } = props || {};
  const combinedRef = (0, _mergeRefs.default)((0, _react.useRef)(null), ref);
  const [userActiveItemId, setActiveItemId] = (0, _react.useState)(null); // If a selected has been set and the user hasn't specified a highlight, "initialize" with the selected!

  const activeItemId = userActiveItemId != null && userActiveItemId !== 'undefined' ? userActiveItemId : selected;
  const handleActiveItemChange = (0, _react.useCallback)((itemId, meta) => {
    setActiveItemId(itemId);
    onActiveItemChange(itemId, meta);
  }, [setActiveItemId, onActiveItemChange]);
  (0, _react.useEffect)(() => {
    // If the user hasn't made a selection, no need to clear
    if (!userActiveItemId) return; // If the active item doesn't exist in items... clear the active item!
    // This usually happens when the list of items changes and the previously highlighted item
    // disappears. Most common in autocomplete scenarios

    if (![].concat(items).find(item => (item === null || item === void 0 ? void 0 : item.id) === userActiveItemId)) {
      return handleActiveItemChange(null, {
        event: null
      });
    }
  }, [userActiveItemId, items, handleActiveItemChange]);
  const generateOnConfirm = (0, _react.useCallback)(itemId => event => {
    var _combinedRef$current, _combinedRef$current$;

    onConfirm(itemId, {
      event
    });

    if ((_combinedRef$current = combinedRef.current) !== null && _combinedRef$current !== void 0 && (_combinedRef$current$ = _combinedRef$current.matches) !== null && _combinedRef$current$ !== void 0 && _combinedRef$current$.call(_combinedRef$current, ':focus-within')) {
      var _anchorRef$current, _anchorRef$current$fo;

      // If the listbox has focus, move it to anchor
      // This usually happens when the user _clicks_ a listbox item
      anchorRef === null || anchorRef === void 0 ? void 0 : (_anchorRef$current = anchorRef.current) === null || _anchorRef$current === void 0 ? void 0 : (_anchorRef$current$fo = _anchorRef$current.focus) === null || _anchorRef$current$fo === void 0 ? void 0 : _anchorRef$current$fo.call(_anchorRef$current);
    }
  }, [onConfirm, anchorRef, combinedRef]); // eslint-disable-next-line complexity

  const handleOnKeyDown = (0, _react.useCallback)(event => {
    const firstItemId = items[0].id;
    const lastItemId = items[items.length - 1].id;
    let itemId;

    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault();
        event.stopPropagation();
        itemId = !activeItemId || loop && lastItemId === activeItemId ? firstItemId : findSubsequentItemId(items, activeItemId, 1);
        break;

      case 'ArrowUp':
        event.preventDefault();
        event.stopPropagation();
        itemId = !activeItemId || loop && firstItemId === activeItemId ? lastItemId : findSubsequentItemId(items, activeItemId, -1);
        break;

      case 'Home':
        event.preventDefault();
        event.stopPropagation();
        itemId = firstItemId;
        break;

      case 'End':
        event.preventDefault();
        event.stopPropagation();
        itemId = lastItemId;
        break;
      // As focus does not follow individual items (as of yet) we need to intercept enter keypresses
      // in order to simulate selecting an item

      case 'Enter':
        {
          if (activeItemId == null) return false;
          event.preventDefault();
          event.stopPropagation();
          generateOnConfirm(activeItemId)(event);
          itemId = activeItemId;
          break;
        }

      default:
        // Noop
        break;
    }

    itemId !== activeItemId && handleActiveItemChange(itemId, {
      event
    });
  }, [items, loop, activeItemId, generateOnConfirm, handleActiveItemChange]);
  (0, _react.useEffect)(() => {
    // Listens for additional keys that may occur on a given anchor
    const elem = anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.current;
    elem === null || elem === void 0 ? void 0 : elem.addEventListener('keydown', handleOnKeyDown);
    return () => elem === null || elem === void 0 ? void 0 : elem.removeEventListener('keydown', handleOnKeyDown);
  }, [anchorRef, handleOnKeyDown]);
  (0, _react.useEffect)(() => {
    // Sets the aria-activedescedent if an anchor is given
    const elem = anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.current;
    activeItemId && (elem === null || elem === void 0 ? void 0 : elem.setAttribute('aria-activedescedent', activeItemId));
    return () => elem === null || elem === void 0 ? void 0 : elem.removeAttribute('aria-activedescedent');
  }, [anchorRef, activeItemId]);
  const handleOnBlur = (0, _react.useCallback)(event => {
    var _combinedRef$current2, _combinedRef$current3;

    // If any child items retain focus, ignore this blur callback
    if ((_combinedRef$current2 = combinedRef.current) !== null && _combinedRef$current2 !== void 0 && (_combinedRef$current3 = _combinedRef$current2.matches) !== null && _combinedRef$current3 !== void 0 && _combinedRef$current3.call(_combinedRef$current2, ':focus-within')) return; // Otherwise clear the active item!

    handleActiveItemChange(null, {
      event
    });
  }, [combinedRef, handleActiveItemChange]);
  if (items.length === 0) return null;
  return /*#__PURE__*/_react.default.createElement(_siblingSet.default, {
    ref: combinedRef,
    id: id,
    orientation: "vertical",
    stretch: stretch,
    className: (0, _classnames.default)(UX_LISTBOX_CLASSNAME, className),
    role: as === 'menu' ? 'menu' : 'listbox',
    tabIndex: tabIndex,
    onBlur: handleOnBlur,
    onKeyDown: handleOnKeyDown,
    "aria-activedescendant": !anchorRef ? activeItemId : null
  }, [].concat(items).map(item => /*#__PURE__*/_react.default.createElement(ListboxItem, {
    key: item.id,
    id: item.id // @TODO potentially splat ...item?
    ,
    as: as,
    isSelected: selected === item.id,
    isFocused: activeItemId === item.id,
    onSelect: generateOnConfirm(item.id)
  }, item.children)));
});

Listbox.propTypes = {
  /** Unique identifier for the component */
  id: _propTypes.default.string,

  /** Determines how the component should behave, namely aria roles used */
  as: _propTypes.default.oneOf(['listbox', 'menu']),

  /** Controls the stretch property of the underlying sibling set */
  stretch: _propTypes.default.bool,

  /** Array of values for the list. As of v2201.0.0 ONLY strings. */
  items: _propTypes.default.arrayOf(_propTypes.default.shape({
    id: _propTypes.default.string.isRequired,
    children: _propTypes.default.node.isRequired
  })).isRequired,

  /** Override tabIndex. Defaults to 0 */
  tabIndex: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),

  /** Callback when the item is chosen. The first argument is id of the item. */
  onConfirm: _propTypes.default.func,

  /** The selected item id */
  selected: _propTypes.default.string,

  /** Callback for when the active item (aka. the focused item is changed. The first argument is id of the item. */
  onActiveItemChange: _propTypes.default.func,

  /** Enables looping of item selection when using keyboard interaction */
  loop: _propTypes.default.bool,

  /** ref used to forward the onKeyDown handler used by Listbox */
  anchorRef: _propTypes.default.object
};
Listbox.displayName = 'Listbox';
var _default = Listbox;
exports.default = _default;