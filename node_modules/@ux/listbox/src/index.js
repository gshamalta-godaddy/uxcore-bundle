/* eslint-disable camelcase, id-length */
import React, { useCallback, useEffect, useState, useRef } from 'react';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import SiblingSet from '@ux/sibling-set';
import mergeRefs from 'merge-refs';

const UX_LISTBOX_CLASSNAME = 'ux-listbox';

/**
 * Given an array of item objects, a "current" id, and a "step" (1 for forward, -1 for back),
 * this function returns the subsequent id that should now gain focus
 *
 * @param {Array<Object>} items array of item objects
 * @param {String} currentId current item id to step away from
 * @param {Number} step direction (and amount) to step
 * @returns {String} the next id given the step
 */
function findSubsequentItemId(items, currentId, step = 1) {
  const possibleIndex = items.findIndex(item => item.id === currentId);
  const currentIndex = possibleIndex === -1 ? 0 : possibleIndex;
  const nextIndex = Math.max(0, Math.min(items.length - 1, (currentIndex + step)));

  return items[nextIndex].id;
}

/**
 * Internal component for managing behaviors around list items
 *
 * @param {*} props ListboxItem Props
 * @returns {Component} ListboxItem
 */
function ListboxItem(props) {
  const {
    id,
    as,
    isSelected,
    isFocused,
    onSelect,
    children
  } = props;

  return (
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events
    <div
      id={ id }
      className='ux-button'
      tabIndex={ -1 }
      role={ as === 'menu' ? 'menuitem' : 'option' }
      data-visually-focused={ isFocused || null }
      aria-selected={ isSelected || null }
      onClick={ onSelect }>
      { children }
    </div>
  );
}

ListboxItem.propTypes = {
  /** Unique identifier for the item */
  id: PropTypes.string.isRequired,
  /** Determines the correct ARIA role for the item */
  as: PropTypes.string.isRequired,
  /** Item is chosen by the user */
  isSelected: PropTypes.bool.isRequired,
  /** Item is navigated to by the user */
  isFocused: PropTypes.bool.isRequired,
  /** Callback when the selection occurs */
  onSelect: PropTypes.func.isRequired,
  /** Content of the item */
  children: PropTypes.node.isRequired
};

/**
 *
 * @param {Object} props - Configuration object
 * @returns {Component} - <Listbox/> component
 */
const Listbox = React.forwardRef(function Listbox(props, ref) {
  const {
    id,
    as = 'listbox',
    stretch,
    className,
    items = [],
    tabIndex = '0',
    onConfirm = Function.prototype,
    selected,
    onActiveItemChange = Function.prototype,
    loop = false,
    anchorRef
  } = props || {};

  const combinedRef = mergeRefs(useRef(null), ref);

  const [userActiveItemId, setActiveItemId] = useState(null);
  // If a selected has been set and the user hasn't specified a highlight, "initialize" with the selected!
  const activeItemId = (userActiveItemId != null  && userActiveItemId !== 'undefined') ? userActiveItemId : selected;

  const handleActiveItemChange = useCallback((itemId, meta) => {
    setActiveItemId(itemId);
    onActiveItemChange(itemId, meta);
  }, [setActiveItemId, onActiveItemChange]);

  useEffect(() => {
    // If the user hasn't made a selection, no need to clear
    if (!userActiveItemId) return;
    // If the active item doesn't exist in items... clear the active item!
    // This usually happens when the list of items changes and the previously highlighted item
    // disappears. Most common in autocomplete scenarios
    if (![].concat(items).find((item) => item?.id === userActiveItemId)) {
      return handleActiveItemChange(null, { event: null });
    }
  }, [userActiveItemId, items, handleActiveItemChange]);

  const generateOnConfirm = useCallback((itemId) => (event) => {
    onConfirm(itemId, { event });
    if (combinedRef.current?.matches?.(':focus-within')) {
      // If the listbox has focus, move it to anchor
      // This usually happens when the user _clicks_ a listbox item
      anchorRef?.current?.focus?.();
    }
  }, [onConfirm, anchorRef, combinedRef]);

  // eslint-disable-next-line complexity
  const handleOnKeyDown = useCallback((event) => {
    const firstItemId = items[0].id;
    const lastItemId = items[items.length - 1].id;
    let itemId;

    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault();
        event.stopPropagation();
        itemId = !activeItemId || (loop && lastItemId === activeItemId)
          ? firstItemId
          : findSubsequentItemId(items, activeItemId, 1);
        break;
      case 'ArrowUp':
        event.preventDefault();
        event.stopPropagation();
        itemId = !activeItemId || (loop && firstItemId === activeItemId)
          ? lastItemId
          : findSubsequentItemId(items, activeItemId, -1);
        break;
      case 'Home':
        event.preventDefault();
        event.stopPropagation();
        itemId = firstItemId;
        break;
      case 'End':
        event.preventDefault();
        event.stopPropagation();
        itemId = lastItemId;
        break;
      // As focus does not follow individual items (as of yet) we need to intercept enter keypresses
      // in order to simulate selecting an item
      case 'Enter': {
        if (activeItemId == null) return false;
        event.preventDefault();
        event.stopPropagation();
        generateOnConfirm(activeItemId)(event);
        itemId = activeItemId;
        break;
      }
      default:
        // Noop
        break;
    }

    itemId !== activeItemId && handleActiveItemChange(itemId, { event });

  }, [items, loop, activeItemId, generateOnConfirm, handleActiveItemChange]);

  useEffect(() => {
    // Listens for additional keys that may occur on a given anchor
    const elem = anchorRef?.current;
    elem?.addEventListener('keydown', handleOnKeyDown);
    return () => elem?.removeEventListener('keydown', handleOnKeyDown);
  }, [anchorRef, handleOnKeyDown]);

  useEffect(() => {
    // Sets the aria-activedescedent if an anchor is given
    const elem = anchorRef?.current;
    activeItemId && elem?.setAttribute('aria-activedescedent', activeItemId);
    return () => elem?.removeAttribute('aria-activedescedent');
  }, [anchorRef, activeItemId]);

  const handleOnBlur = useCallback((event) => {
    // If any child items retain focus, ignore this blur callback
    if (combinedRef.current?.matches?.(':focus-within')) return;
    // Otherwise clear the active item!
    handleActiveItemChange(null, { event });
  }, [combinedRef, handleActiveItemChange]);

  if (items.length === 0) return null;

  return (
    <SiblingSet
      ref={ combinedRef }
      id={ id }
      orientation='vertical'
      stretch={ stretch }
      className={ classnames(UX_LISTBOX_CLASSNAME, className) }
      role={ as === 'menu' ? 'menu' : 'listbox' }
      tabIndex={ tabIndex }
      onBlur={ handleOnBlur }
      onKeyDown={ handleOnKeyDown }
      aria-activedescendant={ !anchorRef ? activeItemId : null }>
      { [].concat(items).map((item) =>
        <ListboxItem
          key={ item.id }
          id={ item.id } // @TODO potentially splat ...item?
          as={ as }
          isSelected={ selected === item.id }
          isFocused={ activeItemId === item.id }
          onSelect={ generateOnConfirm(item.id) }>
          { item.children }
        </ListboxItem>
      ) }
    </SiblingSet>
  );
});

Listbox.propTypes = {
  /** Unique identifier for the component */
  id: PropTypes.string,
  /** Determines how the component should behave, namely aria roles used */
  as: PropTypes.oneOf(['listbox', 'menu']),
  /** Controls the stretch property of the underlying sibling set */
  stretch: PropTypes.bool,
  /** Array of values for the list. As of v2201.0.0 ONLY strings. */
  items: PropTypes.arrayOf(PropTypes.shape({
    id: PropTypes.string.isRequired,
    children: PropTypes.node.isRequired
  })).isRequired,
  /** Override tabIndex. Defaults to 0 */
  tabIndex: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  /** Callback when the item is chosen. The first argument is id of the item. */
  onConfirm: PropTypes.func,
  /** The selected item id */
  selected: PropTypes.string,
  /** Callback for when the active item (aka. the focused item is changed. The first argument is id of the item. */
  onActiveItemChange: PropTypes.func,
  /** Enables looping of item selection when using keyboard interaction */
  loop: PropTypes.bool,
  /** ref used to forward the onKeyDown handler used by Listbox */
  anchorRef: PropTypes.object
};

Listbox.displayName = 'Listbox';

export default Listbox;
