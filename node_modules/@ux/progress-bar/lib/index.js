"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _id2 = _interopRequireDefault(require("@ux/component-utilities/lib/id"));

var _breakpointsHoc = _interopRequireDefault(require("@ux/component-utilities/lib/breakpoints-hoc"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Possible status types
 *
 * @type {object}
 */
const STATUS = {
  Error: 'error',
  Warning: 'warning',
  Success: 'success',
  Info: 'info',
  Primary: 'primary'
};
/**
 * Circle size configurations needed for svg calculation.
 *
 * @type {object}
 */

const CIRCLE_SIZES = {
  XS: {
    size: 50,
    strokeWidth: 4
  },
  SM: {
    size: 100,
    strokeWidth: 6
  },
  MD: {
    size: 150,
    strokeWidth: 14
  },
  LG: {
    size: 250,
    strokeWidth: 22
  }
};
/**
 * Array of ordered breakpoints to check against
 *
 * @type {object}
 */

const BREAKPOINTS = ['mobile', 'phablet', 'tablet', 'desktop', 'large', 'xlarge'];
/**
* Display a progress bar
*
* @displayName ProgressBar
* @class ProgressBar
* @public
*/

class ProgressBar extends _react.Component {
  /**
   * Get the integer part of the current percentage completed (0-100)
   *
   * @returns {number} percent
   * @private
   */
  get _percent() {
    return Math.floor(this._exactPercent);
  }
  /**
   * Get the current percentage completed (0-100)
   *
   * @returns {number} percent
   * @private
   */


  get _exactPercent() {
    return this.props.value / this.props.max * 100;
  }
  /**
   * Get the label element if `label` prop is set.
   *
   * @returns {ReactElement} label element
   * @private
   */


  get _labelElement() {
    const id = (0, _id2.default)('label', {
      props: this.props
    }).toLowerCase();

    if (!this.props.label) {
      return null;
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      id: id,
      className: "ux-progress-label"
    }, this.props.label);
  }
  /**
   * Get the notice element if `notice` prop is set.
   *
   * @returns {ReactElement} notice element
   * @private
   */


  get _noticeElement() {
    if (!this.props.notice) {
      return null;
    }

    return /*#__PURE__*/_react.default.createElement("small", {
      className: "ux-progress-bar-notice"
    }, this.props.notice);
  }
  /**
   * Get the display element if `children` or `showPercent` prop is set.
   * Will not render if small bar.
   * @param {string} breakpoint current viewpoints
   * @returns {ReactElement} percentage text element
   * @private
   */


  _displayElement(breakpoint) {
    const {
      showPercent,
      children,
      shape,
      startShiftPercent
    } = this.props;

    const {
      value,
      unit
    } = this._size(breakpoint);

    let size = this._size(breakpoint);

    let style;

    if (value && unit) {
      size = value + unit;
      style = {
        lineHeight: size
      };
    }

    if (!(!!showPercent || !!children) || shape === 'bar' && ~size.lastIndexOf('xs')) {
      return null;
    }

    const percent = this._percent;
    const classNames = ['ux-progress-text'];

    if (percent < startShiftPercent && !(shape === 'bar' && ~size.lastIndexOf('sm'))) {
      classNames.push('ux-progress-text-start');
    }

    const displayElement = children || `${percent}%`;
    return /*#__PURE__*/_react.default.createElement("span", {
      "aria-hidden": "true",
      className: classNames.join(' '),
      style: style
    }, displayElement);
  }
  /**
   * Get the size to render the progress element at
   * @param {string} breakpoint current view point
   * @returns {string} size
   * @private
   */


  _size(breakpoint) {
    const {
      size
    } = this.props;

    if (typeof size === 'string' || size.value && size.unit) {
      return size;
    } else if (size[breakpoint]) {
      return size[breakpoint];
    } // find the next smallest breakdown size


    let breakdown;
    const targetIdx = BREAKPOINTS.indexOf(breakpoint);

    for (let idx = BREAKPOINTS.length - 1; idx >= 0; idx--) {
      if (size[BREAKPOINTS[idx]]) {
        breakdown = BREAKPOINTS[idx];

        if (idx < targetIdx) {
          break;
        }
      }
    }

    return !breakdown ? 'md' : size[breakdown];
  }
  /**
   * Get the classes to apply to the progress component.
   * @param {string} breakpoint current view point
   * @returns {string} classes
   * @private
   */
  // eslint-disable-next-line complexity


  _progressClasses(breakpoint) {
    const classNames = ['ux-progress'];
    classNames.push(`ux-progress-${this.props.shape}`);

    switch (this._size(breakpoint)) {
      case 'xsmall':
      case 'xs':
        classNames.push('ux-progress-xs');
        break;

      case 'small':
      case 'sm':
        classNames.push('ux-progress-sm');
        break;

      case 'large':
      case 'lg':
        classNames.push('ux-progress-lg');
        break;

      default:
        classNames.push('ux-progress-md');
    }

    switch (this.props.status) {
      case STATUS.Error:
        classNames.push('ux-progress-danger');
        break;

      case STATUS.Warning:
        classNames.push('ux-progress-warning');
        break;

      case STATUS.Info:
        classNames.push('ux-progress-info');
        break;

      case STATUS.Success:
        classNames.push('ux-progress-success');
        break;

      default:
        classNames.push('ux-progress-primary');
    }

    if (this.props.shape !== 'circle') {
      if (this.props.striped) {
        classNames.push('ux-progress-striped');
      }

      if (this._tickCount) {
        classNames.push('ux-progress-tick-marks');
      }
    }

    return classNames.join(' ');
  }

  isSmall(breakpoint) {
    const size = this._size(breakpoint);

    const {
      value,
      unit
    } = size;
    return size === 'sm' || size === 'small' || value < 1.5 && ~unit.indexOf('em') || value < 24;
  }
  /**
   * Get the number of tick marks to display
   *
   * @returns {number} count
   * @private
   */


  get _tickCount() {
    return this.props.tickCount || this.props.ticks.length;
  }
  /**
   * Get a single tick mark label
   *
   * @param {number} index index of label in row, starting at zero
   * @param {object} style additional style (if any) to apply to label
   * @returns {ReactElement} element
   * @private
   */


  tickLabel(index, style) {
    const {
      min,
      max,
      ticks,
      tickCount
    } = this.props;
    const offset = (max - min) / (this._tickCount - 1) + min;
    const value = tickCount ? index * offset : ticks[index];
    return /*#__PURE__*/_react.default.createElement("span", {
      key: value,
      className: "ux-progress-tick-label"
    }, /*#__PURE__*/_react.default.createElement("span", {
      style: style
    }, value));
  }
  /**
   * Get the row of tick mark labels
   *
   * @returns {ReactElement} element
   * @private
   */


  get _tickLabels() {
    const labels = [];
    let i = 0;

    if (i < this._tickCount) {
      labels.push(this.tickLabel(i, {
        transform: 'translateX(0)'
      }));
    }

    for (i = 1; i < this._tickCount - 1; i++) {
      labels.push(this.tickLabel(i));
    }

    if (i < this._tickCount) {
      labels.push(this.tickLabel(i, {
        transform: 'translateX(-100%)'
      }));
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: "ux-progress-tick-labels"
    }, labels);
  }
  /**
   * Get the row of tick mark lines
   *
   * @returns {ReactElement} element
   * @private
   */


  get _tickLines() {
    const ticks = [];

    for (let i = 0; i < this._tickCount - 2; i++) {
      ticks.push( /*#__PURE__*/_react.default.createElement("span", {
        key: i,
        className: "ux-progress-tick-line",
        style: {
          width: this.props.tickWidth
        }
      }));
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: "ux-progress-tick-lines"
    }, ticks);
  }
  /**
   * Get the progress element as a bar
   * @param {string} breakpoint current view point
   * @returns {ReactElement} element
   * @private
   */


  _bar(breakpoint) {
    const {
      value,
      unit
    } = this._size(breakpoint);

    const id = (0, _id2.default)('label', {
      props: this.props
    }).toLowerCase();
    const isSmall = this.isSmall(breakpoint);
    let style;

    if (value && unit) {
      style = {
        height: value + unit
      };
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: this._progressClasses(breakpoint)
    }, this._labelElement, !!this._tickCount && !this.props.hideTickLabels && this._tickLabels, /*#__PURE__*/_react.default.createElement("div", {
      role: "progressbar",
      "aria-valuenow": this._percent,
      "aria-valuemax": this.props.max,
      "aria-valuemin": this.props.min,
      "aria-labelledby": id,
      style: style,
      className: "ux-progress-area"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "ux-progress-fill",
      style: {
        width: `${this._exactPercent}%`
      }
    }, !isSmall && this._displayElement(breakpoint)), !!this._tickCount && this._tickLines), !style && isSmall && this._displayElement(breakpoint), this._noticeElement);
  }
  /**
   * Get the progress element as a circle
   * @param {string} breakpoint current view point
   * @returns {ReactElement} element
   * @private
   */


  _circle(breakpoint) {
    let circleSize;

    switch (this._size(breakpoint)) {
      case 'xsmall':
      case 'xs':
        circleSize = CIRCLE_SIZES.XS;
        break;

      case 'small':
      case 'sm':
        circleSize = CIRCLE_SIZES.SM;
        break;

      case 'large':
      case 'lg':
        circleSize = CIRCLE_SIZES.LG;
        break;

      default:
        circleSize = CIRCLE_SIZES.MD;
    }

    const {
      size,
      strokeWidth
    } = circleSize;
    const percent = this._percent;
    const center = size / 2;
    const radius = center - strokeWidth;
    const c = Math.PI * (radius * 2);
    const offset = (100 - percent) / 100 * c;
    const fillStyle = {
      strokeDashoffset: offset,
      strokeDasharray: c
    };
    const id = (0, _id2.default)('label', {
      props: this.props
    }).toLowerCase();
    return /*#__PURE__*/_react.default.createElement("div", {
      "aria-valuenow": this._percent,
      role: "progressbar",
      "aria-valuemax": this.props.max,
      "aria-valuemin": this.props.min,
      className: this._progressClasses(breakpoint),
      "aria-labelledby": id
    }, /*#__PURE__*/_react.default.createElement("svg", {
      width: size,
      height: size,
      viewBox: `0 0 ${size} ${size}`
    }, /*#__PURE__*/_react.default.createElement("circle", {
      fill: "none",
      strokeWidth: strokeWidth,
      className: "ux-progress-area",
      r: radius,
      cx: center,
      cy: center
    }), /*#__PURE__*/_react.default.createElement("circle", {
      fill: "none",
      strokeWidth: strokeWidth,
      className: "ux-progress-fill",
      r: radius,
      cx: center,
      cy: center,
      style: fillStyle,
      strokeLinecap: "butt",
      transform: `rotate(-90 ${center} ${center})`
    })), this._displayElement(breakpoint), this._labelElement, this._noticeElement);
  }
  /**
   * Renders the component.
   *
   * @returns {ReactElement} Rendered ProgressBar element.
   * @private
   */


  render() {
    return /*#__PURE__*/_react.default.createElement(_breakpointsHoc.default, {
      breakpoints: BREAKPOINTS
    }, _ref => {
      let {
        breakpoint
      } = _ref;
      return this.props.shape === 'circle' ? this._circle(breakpoint) : this._bar(breakpoint);
    }) // this.props.shape === 'circle' ? this._circle() : this._bar()
    ;
  }

}

ProgressBar.Status = STATUS;
ProgressBar.propTypes = {
  /** The title text above the bar */
  label: _propTypes.default.node,

  /** The number that the progress bar starts at, this is mainly for aria-valuemin accessibility */
  min: _propTypes.default.number,

  /** The maximum number of increments */
  max: _propTypes.default.number,

  /** The current increment */
  value: _propTypes.default.number,

  /** Sets the status color/style (active | complete | warning | error) */
  status: _propTypes.default.string,

  /** Sets the small text label below the bar */
  notice: _propTypes.default.node,

  /** Whether or not to show the percentage text */
  showPercent: _propTypes.default.bool,

  /** The start percent value to shift text to right on bar */
  startShiftPercent: _propTypes.default.number,

  /**
   * Set the size (xs | xsmall | sm | small | md | medium | lg | large).
   * Object can be used to specify sizes at different breakpoints.
   * Object can also be used to specify a custom height.
   */
  size: _propTypes.default.oneOfType([_propTypes.default.oneOf(['xsmall', 'xs', 'sm', 'small', 'md', 'medium', 'lg', 'large', 'xl', 'xlarge']), _propTypes.default.object]),

  /** Set the shape (bar | circle)  */
  shape: _propTypes.default.oneOf(['bar', 'circle']),

  /** Can be used to customize the value to display; overrides showPercent */
  children: _propTypes.default.node,

  /**  Whether or not to have a striped progress bar. Won't work with the circle version */
  striped: _propTypes.default.bool,

  /** An array of custom tick labels to be used only when tickCount is too generic */
  ticks: _propTypes.default.array,

  /** Number of ticks (if any) to show. Won't work with the circle version */
  tickCount: _propTypes.default.number,

  /** Width of ticks (in px) */
  tickWidth: _propTypes.default.number,

  /** Whether or not to hide the tick mark labels */
  hideTickLabels: _propTypes.default.bool
};
ProgressBar.defaultProps = {
  min: 0,
  value: 0,
  max: 100,
  size: 'md',
  shape: 'bar',
  startShiftPercent: 10,
  label: '',
  ticks: [],
  tickCount: 0,
  tickWidth: 2
};
var _default = ProgressBar;
exports.default = _default;