"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _fieldFrame = _interopRequireDefault(require("@ux/field-frame"));

var _button = _interopRequireDefault(require("@ux/button"));

var _textEntry = _interopRequireDefault(require("@ux/text-entry"));

var _flyout = _interopRequireDefault(require("@ux/flyout"));

var _listbox = _interopRequireDefault(require("@ux/listbox"));

var _delete = _interopRequireDefault(require("@ux/icon/delete"));

var _mergeRefs = _interopRequireDefault(require("merge-refs"));

const _excluded = ["id", "ariaLabels", "button", "className", "clearable", "children", "onConfirm", "onSelect", "open", "role", "type", "placement", "items", "onClose", "portalElem", "strategy"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

const UX_SEARCH_CLASSNAME = 'ux-search';
const DEFAULT_ARIA_LABELS = {
  clear: 'Clear search field'
};
/**
 * "Sluggifies" an individual item to ensure uniqueness as an ID
 *
 * @param {String} parentId parent ID to be used in namespacing
 * @param {String} value item value
 * @returns {String} sluggified value
 */

function generateItemId(parentId, value) {
  const valueSlug = String(value).toLowerCase().replace(/[^a-z0-9-]+/g, '');
  return [parentId, 'option', valueSlug].join('--');
}
/**
 * Converts an array of string items into an array of item objects for use in Listbox
 *
 * @param {Array<String>} items Array of string items
 * @param {String} parentId The parent ID to use for namespacing
 * @returns {Array<Object>} array of item objects
 */


function generateItemsArray(items, parentId) {
  return [].concat(items).map(item => ({
    id: generateItemId(parentId, item),
    children: item,
    value: item
  }));
}
/**
 * Creates a search component
 *
 * @param {Object} props - Component properties
 *
 * Search specific params
 * @param {Object} [props.ariaLabels] - Sets aria labels for the internals
 * @param {String} [props.ariaLabels.close] - Label for the clear button
 * @param {Element} [props.button] - Sets a button within the input
 * @param {String} [props.className] - Provides an optional class name to be set on the root
 * @param {Boolean} [props.clearable] - Determines if a clear button should be included
 * @param {Node} [props.children] - Content to show within the flyout
 * @param {Boolean} [props.divider] - Adds an optional divider between the button and input
 * @param {Array<String>} [props.items] - List of possible results to show in flyout
 * @param {Boolean} [props.open] - If content is set within the list, this controls visibility
 * @param {Element} [props.portalElem] - Element for flyout attachment
 * @param {String} [props.strategy] - Flyout positioning
 *
 * @returns {Component} - Search component
 */


const Search = /*#__PURE__*/_react.default.forwardRef(function Search(props, ref) {
  const _ref = props || {},
        {
    id,
    ariaLabels,
    button,
    className,
    clearable = true,
    children,
    onConfirm,
    onSelect,
    open = true,

    /* Props above are specific for Search, textEntryProps are for TextEntry */
    role = 'searchbox',
    type = 'text',
    placement: initPlacement = 'bottom-start',
    items: _items = [],
    onClose,
    portalElem,
    strategy
  } = _ref,
        textEntryProps = (0, _objectWithoutProperties2.default)(_ref, _excluded);

  const {
    invalid,
    disabled,
    onChange,
    value
  } = textEntryProps || {};

  const {
    clear
  } = _objectSpread(_objectSpread({}, DEFAULT_ARIA_LABELS), ariaLabels);

  const LISTBOX_ID = `${id}-listbox`;
  const items = (0, _react.useMemo)(() => generateItemsArray(_items, id), [_items, id]);
  const textEntryRef = (0, _mergeRefs.default)((0, _react.useRef)(null), ref);
  const anchorRef = (0, _react.useRef)(null);
  const listboxRef = (0, _react.useRef)(null);
  const [placement, setPlacement] = (0, _react.useState)(initPlacement);
  const hasItems = items.length > 0;
  const show = open && Boolean(hasItems || children);
  const handleOnClear = (0, _react.useCallback)(ev => {
    var _textEntryRef$current, _textEntryRef$current2;

    onChange('', {
      event: ev
    }); // Move focus back to the text element!

    (_textEntryRef$current = textEntryRef.current) === null || _textEntryRef$current === void 0 ? void 0 : (_textEntryRef$current2 = _textEntryRef$current.focus) === null || _textEntryRef$current2 === void 0 ? void 0 : _textEntryRef$current2.call(_textEntryRef$current);
  }, [onChange, textEntryRef]);
  const handleTextEntryConfirm = (0, _react.useCallback)(meta => {
    if (meta.key === 'Enter') {
      onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(meta.target.value, meta);
    }
  }, [onConfirm]);
  const handleListboxConfirm = (0, _react.useCallback)((itemId, meta) => {
    // Need to return what the author gave in the props
    const index = items.findIndex(item => item.id === itemId);
    const item = ~index ? _items[index] : null;
    onChange(item, meta);
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(item, meta);
    onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(item, meta);
  }, [onChange, onSelect, onConfirm, _items, items]);
  const content = hasItems ? /*#__PURE__*/_react.default.createElement(_listbox.default, {
    ref: listboxRef,
    anchorRef: textEntryRef,
    id: LISTBOX_ID,
    items: items,
    stretch: true,
    loop: true,
    onConfirm: handleListboxConfirm
  }) : children;
  return /*#__PURE__*/_react.default.createElement("div", {
    className: (0, _classnames.default)(UX_SEARCH_CLASSNAME, className, {
      [`${UX_SEARCH_CLASSNAME}--composed`]: button
    })
  }, /*#__PURE__*/_react.default.createElement(_fieldFrame.default, {
    className,
    disabled,
    invalid,
    ref: anchorRef,
    flyoutPlacement: show ? placement : null
  }, /*#__PURE__*/_react.default.createElement(_textEntry.default, (0, _extends2.default)({
    autoComplete: "off"
  }, textEntryProps, {
    id: id,
    role: role,
    type: type,
    onKeyDown: handleTextEntryConfirm,
    ref: textEntryRef,
    "aria-multiline": false,
    "aria-autocomplete": hasItems ? 'list' : null,
    "aria-controls": hasItems ? LISTBOX_ID : null
    /* @TODO provide id for arbitrary component children? */
    ,
    "aria-expanded": show
  })), show && /*#__PURE__*/_react.default.createElement(_flyout.default, {
    anchorRef: anchorRef,
    placement: initPlacement,
    onPlacement: setPlacement,
    portalElem: portalElem,
    strategy: strategy,
    stretch: true,
    onClose: onClose
  }, content), clearable && /*#__PURE__*/_react.default.createElement(_button.default, {
    "aria-label": clear,
    design: "stateless",
    hidden: !value,
    icon: /*#__PURE__*/_react.default.createElement(_delete.default, null),
    onClick: handleOnClear,
    value: ""
  })), button);
});

Search.propTypes = _objectSpread(_objectSpread(_objectSpread({}, _fieldFrame.default.propTypes), _textEntry.default.propTypes), {}, {
  /** Sets aria labels for the internals */
  ariaLabels: _propTypes.default.shape({
    /** Label for the clear button */
    clear: _propTypes.default.string
  }),

  /** Sets a button within the input */
  button: _propTypes.default.element,

  /** Provides an optional class name to be set on the root */
  className: _propTypes.default.string,

  /** Determines if a clear button should be included */
  clearable: _propTypes.default.bool,

  /** Content to show within the flyout */
  children: _propTypes.default.node,

  /** List of possible results to show in flyout */
  items: _propTypes.default.arrayOf(_propTypes.default.string),

  /** Callback when an item is selected within the results flyout or enter key press in the search box. The first argument is the id of the item. */
  onConfirm: _propTypes.default.func,

  /** Callback when an item is selected within the results flyout. The first argument is the id of the item. */
  onSelect: _propTypes.default.func,

  /** If content is set within the list, this controls visibility */
  open: _propTypes.default.bool,

  /** Element for flyout attachment */
  portalElem: _propTypes.default.object,

  /** Flyout positioing */
  strategy: _propTypes.default.oneOf(['absolute', 'fixed'])
});
var _default = Search;
exports.default = _default;