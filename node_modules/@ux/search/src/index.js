/* eslint-disable max-statements, complexity */
import React, { useCallback, useRef, useState, useMemo } from 'react';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import FieldFrame from '@ux/field-frame';
import Button from '@ux/button';
import TextEntry from '@ux/text-entry';
import Flyout from '@ux/flyout';
import Listbox from '@ux/listbox';
import ClearIcon from '@ux/icon/delete';
import mergeRefs from 'merge-refs';

const UX_SEARCH_CLASSNAME = 'ux-search';

const DEFAULT_ARIA_LABELS = {
  clear: 'Clear search field'
};

/**
 * "Sluggifies" an individual item to ensure uniqueness as an ID
 *
 * @param {String} parentId parent ID to be used in namespacing
 * @param {String} value item value
 * @returns {String} sluggified value
 */
function generateItemId(parentId, value) {
  const valueSlug = String(value).toLowerCase().replace(/[^a-z0-9-]+/g, '');
  return [parentId, 'option', valueSlug].join('--');
}

/**
 * Converts an array of string items into an array of item objects for use in Listbox
 *
 * @param {Array<String>} items Array of string items
 * @param {String} parentId The parent ID to use for namespacing
 * @returns {Array<Object>} array of item objects
 */
function generateItemsArray(items, parentId) {
  return [].concat(items).map((item) => ({
    id: generateItemId(parentId, item),
    children: item,
    value: item
  }));
}

/**
 * Creates a search component
 *
 * @param {Object} props - Component properties
 *
 * Search specific params
 * @param {Object} [props.ariaLabels] - Sets aria labels for the internals
 * @param {String} [props.ariaLabels.close] - Label for the clear button
 * @param {Element} [props.button] - Sets a button within the input
 * @param {String} [props.className] - Provides an optional class name to be set on the root
 * @param {Boolean} [props.clearable] - Determines if a clear button should be included
 * @param {Node} [props.children] - Content to show within the flyout
 * @param {Boolean} [props.divider] - Adds an optional divider between the button and input
 * @param {Array<String>} [props.items] - List of possible results to show in flyout
 * @param {Boolean} [props.open] - If content is set within the list, this controls visibility
 * @param {Element} [props.portalElem] - Element for flyout attachment
 * @param {String} [props.strategy] - Flyout positioning
 *
 * @returns {Component} - Search component
 */
const Search = React.forwardRef(function Search(props, ref) {

  const {
    id,
    ariaLabels,
    button,
    className,
    clearable = true,
    children,
    onConfirm,
    onSelect,
    open = true,
    /* Props above are specific for Search, textEntryProps are for TextEntry */
    role = 'searchbox',
    type = 'text',
    placement: initPlacement = 'bottom-start',
    items: _items = [],
    onClose,
    portalElem,
    strategy,
    ...textEntryProps
  } = props || {};

  const {
    invalid,
    disabled,
    onChange,
    value
  } = textEntryProps || {};

  const { clear } = { ...DEFAULT_ARIA_LABELS, ...ariaLabels };
  const LISTBOX_ID = `${id}-listbox`;

  const items = useMemo(() => generateItemsArray(_items, id), [_items, id]);

  const textEntryRef = mergeRefs(useRef(null), ref);
  const anchorRef = useRef(null);
  const listboxRef = useRef(null);

  const [placement, setPlacement] = useState(initPlacement);

  const hasItems = items.length > 0;
  const show = open && Boolean(hasItems || children);

  const handleOnClear = useCallback((ev) => {
    onChange('', { event: ev });
    // Move focus back to the text element!
    textEntryRef.current?.focus?.();
  }, [onChange, textEntryRef]);

  const handleTextEntryConfirm = useCallback((meta) => {
    if (meta.key === 'Enter') {
      onConfirm?.(meta.target.value, meta);
    }
  }, [onConfirm]);

  const handleListboxConfirm = useCallback((itemId, meta) => {
    // Need to return what the author gave in the props
    const index = items.findIndex((item) => item.id === itemId);
    const item = ~index ? _items[index] : null;
    onChange(item, meta);
    onSelect?.(item, meta);
    onConfirm?.(item, meta);
  }, [onChange, onSelect, onConfirm, _items, items]);

  const content = hasItems
    ? <Listbox
        ref={ listboxRef }
        anchorRef={ textEntryRef }
        id={ LISTBOX_ID }
        items={ items }
        stretch={ true }
        loop={ true }
        onConfirm={ handleListboxConfirm }/>
    : children;

  return (
    <div className={ classnames(UX_SEARCH_CLASSNAME, className, {
      [`${UX_SEARCH_CLASSNAME}--composed`]: button
    }) }>
    <FieldFrame { ...{ className, disabled, invalid } } ref={ anchorRef } flyoutPlacement={ show ? placement : null }>

      {/* TextEntry component, handles the typing */}
      <TextEntry
        autoComplete='off'
        { ...textEntryProps }
        id={ id }
        role={ role }
        type={ type }
        onKeyDown={ handleTextEntryConfirm }
        ref={ textEntryRef }
        aria-multiline={ false }
        aria-autocomplete={ hasItems ? 'list' : null }
        aria-controls={ hasItems ? LISTBOX_ID : null /* @TODO provide id for arbitrary component children? */ }
        aria-expanded={ show } />

      {/* Flyout for results */}
      { show && <Flyout
          anchorRef={ anchorRef }
          placement={ initPlacement }
          onPlacement={ setPlacement }
          portalElem={ portalElem }
          strategy={ strategy }
          stretch={ true }
          onClose={ onClose }>
          { content }
        </Flyout>
      }

      {/* Button to clear the input, only visible when filled */}
      { clearable && <Button
        aria-label={ clear }
        design='stateless'
        hidden={ !value }
        icon={ <ClearIcon/> }
        onClick={ handleOnClear }
        value=''/> }
      </FieldFrame>

      {/* Button provided from props rendered outside of frame, user determines what to do with events */}
      { button }
    </div>
  );

});

Search.propTypes = {
  /** Inherited props from FieldFrame */
  ...FieldFrame.propTypes,
  /** Inherited props from TextEntry */
  ...TextEntry.propTypes,
  /** Sets aria labels for the internals */
  ariaLabels: PropTypes.shape({
    /** Label for the clear button */
    clear: PropTypes.string
  }),
  /** Sets a button within the input */
  button: PropTypes.element,
  /** Provides an optional class name to be set on the root */
  className: PropTypes.string,
  /** Determines if a clear button should be included */
  clearable: PropTypes.bool,
  /** Content to show within the flyout */
  children: PropTypes.node,
  /** List of possible results to show in flyout */
  items: PropTypes.arrayOf(PropTypes.string),
  /** Callback when an item is selected within the results flyout or enter key press in the search box. The first argument is the id of the item. */
  onConfirm: PropTypes.func,
  /** Callback when an item is selected within the results flyout. The first argument is the id of the item. */
  onSelect: PropTypes.func,
  /** If content is set within the list, this controls visibility */
  open: PropTypes.bool,
  /** Element for flyout attachment */
  portalElem: PropTypes.object,
  /** Flyout positioing */
  strategy: PropTypes.oneOf(['absolute', 'fixed'])
};

export default Search;
