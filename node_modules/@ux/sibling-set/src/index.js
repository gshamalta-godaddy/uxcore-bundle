/* eslint-disable complexity */
import React from 'react';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import Label from '@ux/label';
import text from '@ux/text';
import textClasses from '@ux/text/classes';

const UX_SIBLINGSET_CLASSNAME = 'ux-sibling-set';

/**
 * Creates a SiblingSet component
 *
 * @param {Object} props - Properties to inform the component
 * @param {Elements} props.children - Given children as siblings
 * @param {String} [props.className] - Optional class name
 * @param {Boolean} [props.divider] - Optional divider
 * @param {String} [props.gap] - Optional amount of space between siblings, sm md lg
 * @param {String} [props.id] - Used to inform a11y internals
 * @param {Boolean|String} [props.invalid] - Sets invalid within the component
 * @param {Object} [props.label] - Label configuration object
 * @param {Element} [props.label.content] - Content for the label
 * @param {String} [props.label.id] - `id` for the label
 * @param {String} [props.helpMessage] - Help message
 * @param {String} [props.errorMessage] - Error message
 * @param {String} [props.orientation] - Directions for layout, horizontal or vertical
 * @param {Boolean} [props.stretch] - Determines if the siblings should stretch the full width of the container
 * @param {Boolean} [props.wrap] - Wrap children to the next line
 * @returns {Component} - The SiblingSet component
 */
const SiblingSet = React.forwardRef(function SiblingSet(props, ref) {
  const {
    children,
    className,
    divider,
    gap,
    id,
    invalid,
    label,
    helpMessage,
    errorMessage,
    required,
    orientation = 'horizontal',
    stretch,
    wrap,
    ...rest
  } = props || {};

  delete rest.style;

  if (!children) {
    return null;
  }

  const ariaLabelledBy = label && id && `${id}-label`;
  const helpMessageId = helpMessage && id && `${id}-help`;
  const errorMessageId = errorMessage && id && `${id}-error`;

  return (
    <div
      className={ classnames(UX_SIBLINGSET_CLASSNAME, className, `${UX_SIBLINGSET_CLASSNAME}-${orientation}`, {
        [`${UX_SIBLINGSET_CLASSNAME}-gap-${gap}`]: gap,
        [`${UX_SIBLINGSET_CLASSNAME}--stretch`]: stretch,
        [`${UX_SIBLINGSET_CLASSNAME}--wrap`]: wrap
      }) }
      role='group'
      aria-labelledby={ ariaLabelledBy }
      aria-describedby={ [helpMessageId, errorMessageId].filter(Boolean).join(' ') }>

      {/* Optional label, requires id */}
      {ariaLabelledBy && <Label
        className={ `${UX_SIBLINGSET_CLASSNAME}-label` }
        id={ ariaLabelledBy }
        htmlFor={ id }
        required={ required }>{label}</Label>}

      {/* Optional divider */}
      {divider && <hr />}

      {/* Siblings component */}
      <div
        id={ id }
        ref={ ref }
        aria-invalid={ invalid }
        className={ textClasses({
          className: `${UX_SIBLINGSET_CLASSNAME}-children`,
          emphasis: invalid ? 'critical' : null
        }) }
        style={{ '--ux-siblingset-amount': children.length }}
        { ...rest }>
        {children}
      </div>

      {/** Optional message */}
      {helpMessage && <text.p text={ helpMessage } as='caption' id={ helpMessageId } emphasis='passive' />}

      {/** Optional error */}
      {errorMessage && <text.p text={ errorMessage } as='caption' id={ errorMessageId } emphasis='critical' role='alert' />}

    </div>
  );
});

/**
 * Determine if given collection of props are valid
 *
 * @param {Object} props - List of given props
 * @param {String} propName - Name of current prop
 * @param {String} componentName - Name of the component
 * @returns {PropTypeValidation} - Property configuration validity
 */
function oneOfRequiredProps(props, propName, componentName) {
  const labelNoId = props.label && !props.id;
  const helpNoId = props.helpMessage && !props.id;
  const errorNoId = props.errorMessage && !props.id;

  if (labelNoId || helpNoId || errorNoId) {
    return new Error(`When using a label, helpMessage or errorMessage, the 'id' prop is required`);
  }

  return PropTypes.checkPropTypes({
    [propName]: PropTypes.node
  }, props, propName, componentName);
}

SiblingSet.propTypes = {
  /** Children to render as siblings */
  children: PropTypes.node,
  /** Optional class name used to help position the component */
  className: PropTypes.string,
  /** Sets a divider between the label and siblings, helpful for segregating the label from the siblings */
  divider: PropTypes.bool,
  /** Gap between the siblings, no gap by default */
  gap: PropTypes.oneOf(['sm', 'md', 'lg']),
  /** Used to inform a11y internals */
  id: oneOfRequiredProps,
  /** Sets the component as invalid */
  invalid: PropTypes.oneOfType([
    PropTypes.bool,
    PropTypes.oneOf(['grammar', 'spelling'])
  ]),
  /** Optional label for the siblings */
  label: oneOfRequiredProps,
  /** Optional message for the siblings */
  helpMessage: oneOfRequiredProps,
  /** Optional error message for the siblings */
  errorMessage: oneOfRequiredProps,
  /** The direction of the siblings, either horizontal or vertical */
  orientation: PropTypes.oneOf(['horizontal', 'vertical']),
  /** Optionally shows group as required */
  required: Label.propTypes.required,
  /** Stretch the width of the container, helps for larger siblings */
  stretch: PropTypes.bool,
  /** Wrap children when appropriate */
  wrap: PropTypes.bool
};

SiblingSet.displayName = 'SiblingSet';

export default SiblingSet;
