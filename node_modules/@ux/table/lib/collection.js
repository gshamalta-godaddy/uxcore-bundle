"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _sortable = _interopRequireDefault(require("./sortable"));

var _react = _interopRequireDefault(require("react"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

//
// Set of mixins that handle rendering of childs. This allows mixing
// regular HTML children with React Elements.
//
class Collection extends _sortable.default {
  /**
   * Determine if the element is allowed to pass sortable properties.
   *
   * @param {ReactElement} element ReactElement.
   * @param {Object} options Predefined set of properties.
   * @returns {Object} extended properties.
   * @private
   */
  sortableChild(element) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      props = {},
      state = {}
    } = this;
    const sort = props.sortable;
    const elementType = element.type;
    options.direction = state.direction || props.direction;
    options.active = state.active || props.active;
    this.setSortableOptionsForChild(options, sort, elementType);
    return options;
  }
  /**
   * Sets options.sortable if appropriate for the instance & child-type
   *
   * @param {Object} options The options object to set sortable on
   * @param {Boolean|Function} sort The sort value from props
   * @param {string} childElementType The child element type that is being considered
   * @private
   */


  setSortableOptionsForChild(options, sort, childElementType) {
    if (childElementType === 'th') {
      options.sortable = sort;
    }
  }
  /**
   * Add additional properties to child elements by checking if proxy methods are available.
   *
   * @param {ReactElement} element React Table or any of its children.
   * @param {Object} properties Non frozen object to receive sortable properties.
   * @returns {ReactElement} enhanced ReactElement.
   * @private
   */


  getProperties(element) {
    let properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const props = this.props || {};

    if (props.sortable) {
      this.sortableChild(element, properties);
    }

    return properties;
  }
  /**
   * Render Element, either the provided HTML or a replacement React Element.
   *
   * @param {ReactElement} element ReactElement.
   * @returns {ReactElement} rendered child element.
   * @public
   */


  renderChildren(element) {
    const Component = this.components && this.components[element.type];

    if (!Component) {
      return element;
    }

    return /*#__PURE__*/_react.default.createElement(Component, _objectSpread(_objectSpread({}, this.getProperties(element)), element.props || {}));
  }

}

exports.default = Collection;