"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = require("react");

//
// Set of functions required for sorting Table rows.
//
class Sortable extends _react.Component {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(...arguments);
    this.sort = this.sort.bind(this);
    this.state = {
      data: (props.data || []).slice()
    };
  }
  /**
   * Immutably assign `data` into our `state` if it exists in `this.props`.
   * @param  {Object} prevProps Previous properties to be set on this instance.
   */


  componentDidUpdate(prevProps) {
    if (this.props && Array.isArray(this.props.data) && prevProps.data !== this.props.data) {
      const newData = this.props.data.slice();

      if (this.state.comparator) {
        newData.sort(this.state.comparator);
      }

      this.setState({
        data: newData
      });
    }
  }
  /**
   * Simple helper to spread the required stateful sortable properties to child
   * Components, data is not provided to allow more developer control.
   *
   * @returns {Object} Sortable properties
   * @public
   */


  getSortableProps() {
    const {
      state: {
        active,
        direction
      },
      sort: sortable
    } = this;
    return {
      direction,
      sortable,
      active
    };
  }
  /**
   * Set the sort order for the provided column. Ascending `asc` is the default
   * and will be initially set. Descending `desc` will invert the sort order.
   * The column will be compared to the active sorting column to determine the
   * order state.
   *
   * @param {String} column Name of the current sorting column.
   * @returns {Number} Sort order, either ascending (1) or descending (-1).
   * @private
   */


  flip(column) {
    const state = this.state || {};
    let dir = state.direction || 1;
    if (typeof dir === 'string') dir = dir === 'asc' ? 1 : -1;
    return state.active !== column ? 1 : -1 * dir;
  }
  /**
   * Sort by the provided column.
   *
   * @param {String} column Name of the current sorting column.
   * @public
   */


  sort(column) {
    const direction = this.flip(column);
    const {
      state,
      props
    } = this;

    if (props.onSort) {
      this.setState({
        active: column,
        direction
      }, () => props.onSort(this.state.active, this.state.direction));
      return;
    }

    const defaultComparator = function defaultComparator(a, b) {
      if (a[column] > b[column]) return direction;
      if (a[column] < b[column]) return direction * -1;
      return 0;
    };

    const comparator = typeof props.sortable === 'function' ? props.sortable(direction, column) : defaultComparator;
    this.setState({
      active: column,
      direction,
      comparator,
      data: state.data.slice().sort(comparator)
    });
  }

}
/**
 * Allowed properties for Sortable.
 *
 * @enum {Object} Properties.
 * @public
 */


exports.default = Sortable;
Sortable.propTypes = {
  data: _propTypes.default.array,
  sortable: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.func]),
  onSort: _propTypes.default.func
};