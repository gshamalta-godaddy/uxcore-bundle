"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _enu = _interopRequireDefault(require("enu"));

var _tr = _interopRequireDefault(require("./tr"));

var _td = _interopRequireDefault(require("./td"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

//
// Set of allowed child Components for the Table Body.
//
const COMPONENTS = {
  tr: _tr.default
};
/**
 * A table body component
 *
 * @displayName Tbody
 * @class Tbody
 * @extends {React.Component}
 */

class Tbody extends _react.default.Component {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(...arguments, props); //
    // Define a counter for tabIndexes on each cell.
    //

    this.tabIndex = 0;
  }
  /**
   * Getter that returns the allowed children.
   *
   * @returns {Object} Components
   * @private
   */


  get components() {
    return COMPONENTS;
  }
  /**
   * Iterate over each data row while using the iterator. A predefined ordered
   * list of property references is used by default if it is available, otherwise
   * columns are rendered in the order of properties on the object.
   *
   * @param {Function} iterator Function that generates the content.
   * @param {Object} data Reference to the dataset.
   * @returns {Array} Collection of ReactDOM elements.
   * @private
   */


  compose(iterator, data) {
    let collection = data;

    if (!Array.isArray(data)) {
      collection = this.props.order || Object.keys(data);
    }

    return collection.map(this[iterator](), data);
  }
  /**
   * Return a row iterator.
   *
   * @returns {Function} Iterator that maps children into Tr elements.
   * @private
   */


  row() {
    const self = this;
    const {
      click,
      enableKeyboard
    } = self.props;
    /**
     * Row iterator that expects to be called with the data as scope. Return
     * elements that are already valid ReactElements.
     *
     * @param {String} item Property reference.
     * @param {Number} i Index.
     * @returns {ReactElement} Table row.
     * @private
     */

    return function iterate(item, i) {
      if ( /*#__PURE__*/_react.default.isValidElement(item)) return item; //
      // Extract the enumerable and non enumerable keys from the object so we
      // which properties should be used for the cells and which for the actual
      // properties.
      //

      const props = (0, _enu.default)(item);
      props.non.key = props.non._key || i; //
      // Assign an optional row click listener, pre-bind it to `item` so we get
      // a reference to the clicked item.
      //

      if (click) {
        props.non.click = function clack(evt) {
          click(item, evt);
        };
      }

      let rowProps = _objectSpread({}, props.non);

      if (enableKeyboard) {
        rowProps = _objectSpread(_objectSpread({}, rowProps), {}, {
          tabIndex: 0,
          enableKeyboard
        });
      }

      return /*#__PURE__*/_react.default.createElement(_tr.default, rowProps, self.renderCells(props.enu));
    };
  }
  /**
   * Return a cell iterator.
   *
   * @returns {Function} Iterator that maps children into Td elements.
   * @private
   */


  cell() {
    const self = this;
    /**
     * Cell iterator that expects to be called with the data as scope. Return
     * elements that are already valid ReactElements.
     *
     * @param {String} key Property reference.
     * @param {Number} i Iterator index.
     * @returns {ReactElement} Table cell.
     * @private
     */

    return function iterate(key, i) {
      if ( /*#__PURE__*/_react.default.isValidElement(this[key])) return this[key]; // eslint-disable-line no-invalid-this

      let tabIndex;
      if (!self.props.enableKeyboard) tabIndex = 0;
      return /*#__PURE__*/_react.default.createElement(_td.default, {
        tabIndex,
        className: key,
        key: i
      }, this[key]); // eslint-disable-line no-invalid-this
    };
  }
  /**
   * Render rows from a data collection.
   *
   * @param {Object} data Optional collection of rows that can be rendered.
   * @returns {Array} Collection of ReactDOM elements.
   * @public
   */


  renderRows(data) {
    return this.compose('row', data || this.props.data || {});
  }
  /**
   * Render a set of cells in a single row.
   *
   * @param {Object} data Single object where each property will become a cell.
   * @returns {Array} Collection of ReactDOM elements.
   * @private
   */


  renderCells(data) {
    return this.compose('cell', data);
  }
  /**
   * Render the table body. Allows passing both regular HTML/Components as
   * children or datasets through properties to dynamically generate content.
   *
   * @returns {ReactDOM} Generated table body and respective rows.
   * @public
   */


  render() {
    const {
      style,
      className,
      children
    } = this.props;
    return /*#__PURE__*/_react.default.createElement("tbody", {
      style: style,
      className: className
    }, children, this.renderRows());
  }

}
/**
 * Allowed properties for Tbody.
 *
 * @enum {Object} Properties.
 * @public
 */


exports.default = Tbody;
Tbody.propTypes = {
  /** The child rows */
  children: _propTypes.default.node,

  /** Called when a row is clicked */
  click: _propTypes.default.func,

  /** The data to fill the table */
  data: _propTypes.default.array,

  /** When false, tabbing is disabled between rows, and enabled between individual table cells,
   * though there is no handler for Enter */
  enableKeyboard: _propTypes.default.bool,

  /** The column order for the rows */
  order: _propTypes.default.array,

  /** Styles to apply to the element */
  style: _propTypes.default.object,

  /** ClassName to apply to the element */
  className: _propTypes.default.string
};