import React from 'react';
import PropTypes from 'prop-types';

import Collection from './collection';
import Sortable from './sortable';
import Thead from './thead';
import Tbody from './tbody';
import Tfoot from './tfoot';
import Th from './th';
import Tr from './tr';
import Td from './td';

//
// Set of allowed child Components for the Table.
//
const COMPONENTS = {
  thead: Thead,
  tbody: Tbody,
  tfoot: Tfoot,
  tr: Tr
};

/**
 * Enhanced Table.
 *
 * @displayName Table
 * @class Table
 * @public
 */
class Table extends Collection {
  constructor() {
    super(...arguments);
    this.index = this.index.bind(this);
  }

  /**
   * Getter that returns the allowed children.
   *
   * @returns {Object} Components
   * @private
   */
  get components() {
    return COMPONENTS;
  }

  /**
   * Sets options.sortable if appropriate for the instance & child-type
   *
   * @param {Object} options The options object to set sortable on
   * @private
   */
  setSortableOptionsForChild(options) {
    options.sortable = this.sort;
  }

  /**
   * Add unique hidden and readonly private key, used by each Table Row and
   * React for rendering optimalization. Skip rows that are already a valid
   * ReactElement.
   *
   * @param {Object} row Single object from the collection of data.
   * @param {Number} i Iterator
   * @returns {Object} Extended row.
   */
  index(row, i) {
    if (React.isValidElement(row)) return row;

    Object.defineProperty(row, '_key', {
      enumerable: false,
      writable: true,
      value: i
    });

    Object.defineProperty(row, '_active', {
      enumerable: false,
      writable: true,
      value: i === this.state.activeRow
    });

    return row;
  }

  /**
   * Sorts the data by the given column
   *
   * @private
   */
  sort() {
    super.sort(...arguments);
    this.setState({ activeRow: 0 });
  }

  /**
   * Render a table.
   *
   * TODO merge table body element if data is received with actual tbody child.
   *
   * @returns {ReactDOM} Rendered table.
   * @public
   */
  render() {
    const { className, children, enableKeyboard, row } = this.props;
    let { order } = this.props;
    const { data } = this.state;

    //
    // Convert the order property from a comma separated string to array.
    //
    order = typeof order === 'string' ? order.split(',') : order;

    const tableClassName = className ? `ux-table ${className}` : 'ux-table';

    return (
      <table className={ tableClassName }>
        { React.Children.map(children, this.renderChildren, this) }
        <Tbody data={ data.map(this.index) } order={ order } click={ row } enableKeyboard={ enableKeyboard } />
      </table>
    );
  }
}

/**
 * The default properties of the component.
 *
 * @type {Object}
 * @private
 */
Table.defaultProps = {
  data: [],
  enableKeyboard: true,
  row: () => {}
};

/**
 * Allowed properties for Table.
 *
 * @enum {Object} Properties.
 * @public
 */
Table.propTypes = {
  /** Css class name to apply to the table */
  className: PropTypes.string,
  /** The data used to populate the table */
  data: PropTypes.array,
  /** When false, tabbing is disabled between rows, and enabled between individual table cells,
   * though there is no handler for Enter */
  enableKeyboard: PropTypes.bool,
  /** Specifies the column order */
  order: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]),
  /** Function called when a row is clicked on */
  row: PropTypes.func
};

// Attach auxiliary components to Table so they're accessible from @ux/uxcore2
Table.Thead = Thead;
Table.Tbody = Tbody;
Table.Tfoot = Tfoot;
Table.Tr = Tr;
Table.Td = Td;
Table.Th = Th;
Table.Collection = Collection;
Table.Sortable = Sortable;

// Also do named exports for those importing from @ux/table directly
export {
  Table as default,
  Thead,
  Tbody,
  Tfoot,
  Tr,
  Td,
  Th,

  Collection,
  Sortable
};

