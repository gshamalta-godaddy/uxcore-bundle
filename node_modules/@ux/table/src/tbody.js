import React from 'react';
import PropTypes from 'prop-types';
import enu from 'enu';
import Tr from './tr';
import Td from './td';

//
// Set of allowed child Components for the Table Body.
//
const COMPONENTS = {
  tr: Tr
};

/**
 * A table body component
 *
 * @displayName Tbody
 * @class Tbody
 * @extends {React.Component}
 */
export default class Tbody extends React.Component {
  constructor(props = {}) {
    super(...arguments, props);

    //
    // Define a counter for tabIndexes on each cell.
    //
    this.tabIndex = 0;
  }

  /**
   * Getter that returns the allowed children.
   *
   * @returns {Object} Components
   * @private
   */
  get components() {
    return COMPONENTS;
  }

  /**
   * Iterate over each data row while using the iterator. A predefined ordered
   * list of property references is used by default if it is available, otherwise
   * columns are rendered in the order of properties on the object.
   *
   * @param {Function} iterator Function that generates the content.
   * @param {Object} data Reference to the dataset.
   * @returns {Array} Collection of ReactDOM elements.
   * @private
   */
  compose(iterator, data) {
    let collection = data;

    if (!Array.isArray(data)) {
      collection = this.props.order || Object.keys(data);
    }

    return collection.map(this[iterator](), data);
  }

  /**
   * Return a row iterator.
   *
   * @returns {Function} Iterator that maps children into Tr elements.
   * @private
   */
  row() {
    const self = this;
    const { click, enableKeyboard } = self.props;

    /**
     * Row iterator that expects to be called with the data as scope. Return
     * elements that are already valid ReactElements.
     *
     * @param {String} item Property reference.
     * @param {Number} i Index.
     * @returns {ReactElement} Table row.
     * @private
     */
    return function iterate(item, i) {
      if (React.isValidElement(item)) return item;

      //
      // Extract the enumerable and non enumerable keys from the object so we
      // which properties should be used for the cells and which for the actual
      // properties.
      //
      const props = enu(item);
      props.non.key = props.non._key || i;

      //
      // Assign an optional row click listener, pre-bind it to `item` so we get
      // a reference to the clicked item.
      //
      if (click) {
        props.non.click = function clack(evt) {
          click(item, evt);
        };
      }
      let rowProps = { ...props.non };

      if (enableKeyboard) {
        rowProps = { ...rowProps, tabIndex: 0, enableKeyboard };
      }

      return React.createElement(Tr, rowProps, self.renderCells(props.enu));
    };
  }

  /**
   * Return a cell iterator.
   *
   * @returns {Function} Iterator that maps children into Td elements.
   * @private
   */
  cell() {
    const self = this;

    /**
     * Cell iterator that expects to be called with the data as scope. Return
     * elements that are already valid ReactElements.
     *
     * @param {String} key Property reference.
     * @param {Number} i Iterator index.
     * @returns {ReactElement} Table cell.
     * @private
     */
    return function iterate(key, i) {
      if (React.isValidElement(this[key])) return this[key]; // eslint-disable-line no-invalid-this

      let tabIndex;
      if (!self.props.enableKeyboard) tabIndex = 0;

      return React.createElement(Td, {
        tabIndex,
        className: key,
        key: i
      }, this[key]); // eslint-disable-line no-invalid-this
    };
  }

  /**
   * Render rows from a data collection.
   *
   * @param {Object} data Optional collection of rows that can be rendered.
   * @returns {Array} Collection of ReactDOM elements.
   * @public
   */
  renderRows(data) {
    return this.compose('row', data || this.props.data || {});
  }

  /**
   * Render a set of cells in a single row.
   *
   * @param {Object} data Single object where each property will become a cell.
   * @returns {Array} Collection of ReactDOM elements.
   * @private
   */
  renderCells(data) {
    return this.compose('cell', data);
  }

  /**
   * Render the table body. Allows passing both regular HTML/Components as
   * children or datasets through properties to dynamically generate content.
   *
   * @returns {ReactDOM} Generated table body and respective rows.
   * @public
   */
  render() {
    const { style, className, children } = this.props;
    return (
      <tbody style={ style } className={ className }>
        { children }
        { this.renderRows() }
      </tbody>
    );
  }
}

/**
 * Allowed properties for Tbody.
 *
 * @enum {Object} Properties.
 * @public
 */
Tbody.propTypes = {
  /** The child rows */
  children: PropTypes.node,
  /** Called when a row is clicked */
  click: PropTypes.func,
  /** The data to fill the table */
  data: PropTypes.array,
  /** When false, tabbing is disabled between rows, and enabled between individual table cells,
   * though there is no handler for Enter */
  enableKeyboard: PropTypes.bool,
  /** The column order for the rows */
  order: PropTypes.array,
  /** Styles to apply to the element */
  style: PropTypes.object,
  /** ClassName to apply to the element */
  className: PropTypes.string
};
