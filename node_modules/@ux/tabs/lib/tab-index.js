"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _reactComponentValidator = _interopRequireDefault(require("react-component-validator"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _ripOut = _interopRequireDefault(require("rip-out"));

var _tab = _interopRequireDefault(require("./tab"));

var _chevronLeft = _interopRequireDefault(require("@ux/icon/chevron-left"));

var _chevronRight = _interopRequireDefault(require("@ux/icon/chevron-right"));

var _breakpointsHoc = _interopRequireDefault(require("@ux/component-utilities/lib/breakpoints-hoc"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

//
// Control attributes.
//
const directions = {
  prev: {
    side: 'left',
    step: -1
  },
  next: {
    side: 'right',
    step: 1
  }
};
const breakpoints = ['tablet', 'desktop', 'large', 'xlarge'];
/**
 * Render a default set of tabs used with each Component.
 *
 * @class TabIndex
 * @displayName Tab Index
 * @public
 */

class TabIndex extends _react.Component {
  constructor() {
    super(...arguments); //
    // Move the conveyor through margin left styling.
    //

    this.state = {
      conveyorMarginLeft: 0
    };
    this.defaultStepSize = 200;
  }
  /**
   * Step size used to in- or decrement the conveyor position. Can also be provided
   * through properties on TabIndex.
   *
   * @returns {number} Step size
   * @public
   */


  get stepSize() {
    if (!this.props || !this.props.stepSize) return this.defaultStepSize;
    return this.props.stepSize;
  }
  /**
   * Increment or decrement the conveyor steps within bounds.
   * Bounds are: [0, this.tabsExceededWidth].
   *
   * @param {string} direction Previous or next control
   * @returns {Function} Event handler
   * @private
   */


  moveConveyor(direction) {
    return event => {
      event.preventDefault();
      const margin = this.state.conveyorMarginLeft;
      const absMargin = Math.abs(margin);
      let step = this.stepSize;

      if (direction === 'prev' && absMargin < step) {
        step = absMargin;
      } else if (direction === 'next' && this.tabsExceededWidth - absMargin < step) {
        step = this.tabsExceededWidth - absMargin;
      }

      this.setState({
        conveyorMarginLeft: margin + -directions[direction].step * step
      });
    };
  }
  /**
   * Calculate the amount of by which the tabs exceed the width of the conveyor.
   *
   * @returns {number} Exceeded width in pixels
   * @private
   */


  get tabsExceededWidth() {
    const tabindex = this.conveyor;
    let tabs = this.tabs;
    let sum = 0;
    let n;

    if (!tabindex || !tabs) {
      return sum;
    }

    tabs = Array.prototype.map.call(tabs.childNodes, tab => {
      var tabStyles = window.getComputedStyle(tab);
      return parseFloat(tabStyles.width) + parseFloat(tabStyles.marginLeft) + parseFloat(tabStyles.marginRight);
    });
    n = tabs.length;

    while (n--) {
      sum += tabs[n];
    }

    return sum - parseFloat(window.getComputedStyle(tabindex).width);
  }
  /**
   * Check if controls should be visible or hidden.
   *
   * @param {string} side Previous or next control
   * @param {string} breakpoint current view point
   * @returns {Object} Display style
   */


  conveyorArrowStyle(side, breakpoint) {
    const {
      conveyorMarginLeft
    } = this.state;
    const width = this.tabsExceededWidth;

    if (!['large', 'desktop', 'xlarge'].includes(breakpoint)) {
      return {
        display: 'none'
      };
    } else if (side === 'prev' && conveyorMarginLeft || side === 'next' && width !== Math.abs(conveyorMarginLeft) && width > 0) {
      return {
        display: 'flex'
      };
    }

    return {
      display: 'none'
    };
  }
  /**
   * Get attributes that are required for conveyor controls.
   *
   * @param {string} direction Previous or next control
   * @param {string} breakpoint current viewpoint
   * @returns {Object} Control attributes
   * @private
   */


  controlAttributes(direction, breakpoint) {
    return {
      'className': [`ux-conveyor-control-${directions[direction].side}`, 'ux-conveyor-control'].join(' '),
      'style': this.conveyorArrowStyle(direction, breakpoint),
      'onClick': this.moveConveyor(direction),
      'data-slide': direction,
      'role': 'button'
    };
  }
  /**
   * Render the TabIndex Component.
   *
   * @returns {React.DOM} conveyor clipping div element with children
   * @private
   */


  render() {
    const props = this.props;
    const {
      conveyorMarginLeft
    } = this.state;
    const other = (0, _ripOut.default)(props, 'stepSize', 'selected', 'change', 'contentIds');
    return /*#__PURE__*/_react.default.createElement(_breakpointsHoc.default, {
      breakpoints: breakpoints
    }, _ref => {
      let {
        breakpoint
      } = _ref;
      // Only add the marginLeft if we're on large/desktop breakpoints (prevents scrolling from breaking on small devices)
      const marginLeftStyle = {};

      if (['large', 'desktop', 'xlarge'].includes(breakpoint)) {
        marginLeftStyle.marginLeft = conveyorMarginLeft;
      }

      return /*#__PURE__*/_react.default.createElement("div", {
        className: "ux-conveyor-clip"
      }, /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({}, other, {
        ref: ref => {
          this.conveyor = ref;
        },
        className: "ux-conveyor"
      }), /*#__PURE__*/_react.default.createElement("ul", {
        className: "ux-tabs",
        ref: ref => {
          this.tabs = ref;
        },
        style: marginLeftStyle,
        role: "tablist"
      }, _react.default.Children.map(props.children, (child, i) => /*#__PURE__*/_react.default.cloneElement(child, {
        onClick: props.change.bind(null, i),
        selected: props.selected === i,
        ariaControls: props.contentIds[i]
      })))), /*#__PURE__*/_react.default.createElement("button", this.controlAttributes('prev', breakpoint), /*#__PURE__*/_react.default.createElement(_chevronLeft.default, {
        "aria-hidden": "true"
      }), /*#__PURE__*/_react.default.createElement("span", {
        className: "sr-only"
      }, "Previous")), /*#__PURE__*/_react.default.createElement("button", this.controlAttributes('next', breakpoint), /*#__PURE__*/_react.default.createElement(_chevronRight.default, {
        "aria-hidden": "true"
      }), /*#__PURE__*/_react.default.createElement("span", {
        className: "sr-only"
      }, "Next")));
    });
  }

}
/**
 * Validate that the passed children are of type Tab.
 *
 * @enum {Object} expected types of properties.
 * @api public
 */


exports.default = TabIndex;
TabIndex.propTypes = {
  /** Increments or decrements the conveyor position */
  stepSize: _propTypes.default.number,

  /** Function called when selection changes */
  change: _propTypes.default.func,

  /** Index of selected tab */
  selected: _propTypes.default.number,

  /** Child tab */
  children: (0, _reactComponentValidator.default)([_tab.default]),

  /** IDs of linked tab contents */
  contentIds: _propTypes.default.array
};