import validateComponents from 'react-component-validator';
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import rip from 'rip-out';
import Tab from './tab';
import ChevronLeft from '@ux/icon/chevron-left';
import ChevronRight from '@ux/icon/chevron-right';
import Breakpoints from '@ux/component-utilities/lib/breakpoints-hoc';

//
// Control attributes.
//
const directions = {
  prev: {
    side: 'left',
    step: -1
  },
  next: {
    side: 'right',
    step: 1
  }
};

const breakpoints = ['tablet', 'desktop', 'large', 'xlarge'];

/**
 * Render a default set of tabs used with each Component.
 *
 * @class TabIndex
 * @displayName Tab Index
 * @public
 */
export default class TabIndex extends Component {
  constructor() {
    super(...arguments);

    //
    // Move the conveyor through margin left styling.
    //
    this.state = {
      conveyorMarginLeft: 0
    };

    this.defaultStepSize = 200;
  }

  /**
   * Step size used to in- or decrement the conveyor position. Can also be provided
   * through properties on TabIndex.
   *
   * @returns {number} Step size
   * @public
   */
  get stepSize() {
    if (!this.props || !this.props.stepSize) return this.defaultStepSize;

    return this.props.stepSize;
  }

  /**
   * Increment or decrement the conveyor steps within bounds.
   * Bounds are: [0, this.tabsExceededWidth].
   *
   * @param {string} direction Previous or next control
   * @returns {Function} Event handler
   * @private
   */
  moveConveyor(direction) {
    return event => {
      event.preventDefault();

      const margin = this.state.conveyorMarginLeft;
      const absMargin = Math.abs(margin);
      let step = this.stepSize;

      if (direction === 'prev' && absMargin < step) {
        step = absMargin;
      } else if (direction === 'next' && this.tabsExceededWidth - absMargin < step) {
        step = this.tabsExceededWidth - absMargin;
      }

      this.setState({
        conveyorMarginLeft: margin + -directions[direction].step * step
      });
    };
  }

  /**
   * Calculate the amount of by which the tabs exceed the width of the conveyor.
   *
   * @returns {number} Exceeded width in pixels
   * @private
   */
  get tabsExceededWidth() {
    const tabindex = this.conveyor;
    let tabs = this.tabs;
    let sum = 0;
    let n;

    if (!tabindex || !tabs) {
      return sum;
    }

    tabs = Array.prototype.map.call(tabs.childNodes, tab => {
      var tabStyles = window.getComputedStyle(tab);

      return parseFloat(tabStyles.width)
        + parseFloat(tabStyles.marginLeft)
        + parseFloat(tabStyles.marginRight);

    });
    n = tabs.length;

    while (n--) {
      sum += tabs[n];
    }

    return sum - parseFloat(window.getComputedStyle(tabindex).width);
  }

  /**
   * Check if controls should be visible or hidden.
   *
   * @param {string} side Previous or next control
   * @param {string} breakpoint current view point
   * @returns {Object} Display style
   */
  conveyorArrowStyle(side, breakpoint) {
    const { conveyorMarginLeft } = this.state;
    const width = this.tabsExceededWidth;
    if (!['large', 'desktop', 'xlarge'].includes(breakpoint)) {
      return { display: 'none' };
    } else if ((side === 'prev' && conveyorMarginLeft) || (side === 'next' && width !== Math.abs(conveyorMarginLeft) && width > 0)) {
      return { display: 'flex' };
    }
    return { display: 'none' };
  }

  /**
   * Get attributes that are required for conveyor controls.
   *
   * @param {string} direction Previous or next control
   * @param {string} breakpoint current viewpoint
   * @returns {Object} Control attributes
   * @private
   */
  controlAttributes(direction, breakpoint) {
    return {
      'className': [`ux-conveyor-control-${directions[direction].side}`, 'ux-conveyor-control'].join(' '),
      'style': this.conveyorArrowStyle(direction, breakpoint),
      'onClick': this.moveConveyor(direction),
      'data-slide': direction,
      'role': 'button'
    };
  }

  /**
   * Render the TabIndex Component.
   *
   * @returns {React.DOM} conveyor clipping div element with children
   * @private
   */
  render() {
    const props = this.props;
    const { conveyorMarginLeft } = this.state;
    const other = rip(props, 'stepSize', 'selected', 'change', 'contentIds');

    return (
      <Breakpoints breakpoints={ breakpoints }>{

        ({ breakpoint }) => {
          // Only add the marginLeft if we're on large/desktop breakpoints (prevents scrolling from breaking on small devices)
          const marginLeftStyle = {};
          if (['large', 'desktop', 'xlarge'].includes(breakpoint)) {
            marginLeftStyle.marginLeft = conveyorMarginLeft;
          }
          return (<div className='ux-conveyor-clip'>

            <div { ...other } ref={ ref => { this.conveyor = ref; } } className='ux-conveyor'>
              <ul className='ux-tabs' ref={ ref => { this.tabs = ref; } } style={ marginLeftStyle } role='tablist'>
                { React.Children.map(props.children, (child, i) => React.cloneElement(child, {
                  onClick: props.change.bind(null, i),
                  selected: props.selected === i,
                  ariaControls: props.contentIds[i]
                }))}
              </ul>
            </div>

            <button { ...this.controlAttributes('prev', breakpoint) }>
              <ChevronLeft aria-hidden='true' />
              <span className='sr-only'>Previous</span>
            </button>

            <button { ...this.controlAttributes('next', breakpoint) }>
              <ChevronRight aria-hidden='true' />
              <span className='sr-only'>Next</span>
            </button>
          </div>
          );
        }
      }</Breakpoints>
    );
  }
}

/**
 * Validate that the passed children are of type Tab.
 *
 * @enum {Object} expected types of properties.
 * @api public
 */
TabIndex.propTypes = {
  /** Increments or decrements the conveyor position */
  stepSize: PropTypes.number,
  /** Function called when selection changes */
  change: PropTypes.func,
  /** Index of selected tab */
  selected: PropTypes.number,
  /** Child tab */
  children: validateComponents([Tab]),
  /** IDs of linked tab contents */
  contentIds: PropTypes.array
};
