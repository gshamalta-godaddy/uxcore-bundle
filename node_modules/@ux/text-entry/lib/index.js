"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _label = _interopRequireWildcard(require("@ux/label"));

var _classes = _interopRequireDefault(require("@ux/text/classes"));

const _excluded = ["className", "disabled", "id", "invalid", "label", "multiline", "onBlur", "onChange", "onFocus", "placeholder", "resize", "required", "size", "suggestion", "type", "value"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const inputTypes = ['text', 'email', 'password', 'url', 'tel', 'number', 'search'];
const UX_TEXT_ENTRY_CLASSNAME = 'ux-text-entry';
const UX_TEXT_ENTRY_SIZE_CHAR = '#';
/**
 * Create props to be added to the shell of the component
 *
 * @param {Object} props - Props from the TextEntry component below
 * @param {String|React.Element} [props.label] - Label for the component
 * @param {Boolean} [props.multiline] - Renders input as textarea
 * @param {Boolean|String} [props.resize] - Allows a multiline input to be resized
 * @param {String} [props.size] - Sets the size of the input
 * @param {String|Number} [props.value] - Value for the input
 * @returns {Object} - Props to be applied to the shell
 */

function getShellProps(props) {
  const {
    multiline,
    label,
    size,
    resize
  } = props; // Newline character is expected to size vertically

  const sizingCharacter = !multiline ? UX_TEXT_ENTRY_SIZE_CHAR : `
  `; // If there's a label, it counts as the first sizing character

  const firstCharacter = !label ? UX_TEXT_ENTRY_SIZE_CHAR : ''; // This logic handles how large the input should be. .padEnd() doesn't seem to work with newline characters

  let dataSize = Array(size || 1).fill(sizingCharacter).map((v, i) => i === 0 ? firstCharacter : v).join(''); // Single line with label cannot be horizontally sized

  if (label && !multiline) {
    dataSize = null;
  } // This logic determines how the resizing should be applied


  let style;

  if (multiline) {
    style = typeof resize === 'string' ? {
      resize
    } : {
      resize: resize ? 'both' : 'none'
    };
  }

  return {
    'data-size': dataSize,
    style
  };
}
/**
 * Text entry functional component
 * @param {Object} props - Information for the props can be found in the PropTypes below and in TextEntry propTypes
 * @param {String} [props.className] - Optional classname
 * @param {Boolean} [props.disabled] - Sets component as disabled
 * @param {String} props.id - Sets the id of the input
 * @param {Boolean} [props.invalid] - Sets component as invalid
 * @param {String|React.Element} [props.label] - Label for the component
 * @param {Boolean} [props.multiline] - Renders input as textarea
 * @param {String} [props.placeholder] - Sets placeholder text
 * @param {Boolean|String} [props.resize] - Allows a multiline input to be resized
 * @param {Boolean} [props.required] - Sets component as required, only visual
 * @param {String} [props.size] - Sets the size of the input
 * @param {String} [props.suggestion] - Allows for autosuggest functionality
 * @param {String} [props.type] - Attribute for the input type, default is text
 * @param {String|Number} [props.value] - Value for the input
 * @param {Object} ref - Forwarded ref to TextEntry
 * @returns {React.Component} TextEntry component
 */


const TextEntry = /*#__PURE__*/_react.default.forwardRef(function (props, ref) {
  const {
    className,
    disabled,
    id,
    invalid,
    label,
    multiline,
    onBlur,
    onChange = Function.prototype,
    onFocus,
    placeholder,
    resize,
    required,
    size,
    suggestion,
    type = 'text',
    value
  } = props,
        rest = (0, _objectWithoutProperties2.default)(props, _excluded); // style is explicitly omitted, do not override.

  delete rest.style;
  const [isFocused, setFocused] = (0, _react.useState)(false); // Determine if the label should move

  const _onFocus = (0, _react.useCallback)(ev => {
    setFocused(true);
    typeof onFocus === 'function' && onFocus(ev);
  }, [setFocused, onFocus]);

  const _onBlur = (0, _react.useCallback)(ev => {
    setFocused(false);
    typeof onBlur === 'function' && onBlur(ev);
  }, [setFocused, onBlur]);

  const _onChange = (0, _react.useCallback)(ev => {
    onChange(ev.target.value, {
      event: ev
    });
  }, [onChange]);

  const TagName = multiline ? 'textarea' : 'input';
  return /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({
    className: (0, _classnames.default)(`${UX_TEXT_ENTRY_CLASSNAME}-shell`, className, (0, _classes.default)({
      as: 'input',
      emphasis: invalid && 'critical'
    }))
  }, getShellProps({
    multiline,
    label,
    size,
    resize
  })), suggestion && /*#__PURE__*/_react.default.createElement("span", {
    className: `${UX_TEXT_ENTRY_CLASSNAME}-suggestion`
  }, suggestion), !placeholder && (0, _label.ensureLabelComponent)(label, {
    float: Boolean(value) || isFocused,
    internal: true,
    required,
    htmlFor: id
  }), /*#__PURE__*/_react.default.createElement(TagName, (0, _extends2.default)({
    ref: ref,
    className: `${UX_TEXT_ENTRY_CLASSNAME}-field`,
    disabled: disabled,
    id: id,
    placeholder: placeholder,
    "aria-invalid": invalid,
    "aria-required": Boolean(required),
    type: type,
    value: value,
    onChange: _onChange,
    onFocus: _onFocus,
    onBlur: _onBlur,
    size: size
  }, rest)));
});

TextEntry.propTypes = {
  /** Classes applied to the shell for positioning purposes */
  className: _propTypes.default.string,

  /** Sets the disabled state of the input */
  disabled: _propTypes.default.bool,

  /** Id applied to the input, used for the for attribute on the label */
  id: _propTypes.default.string.isRequired,

  /** Set component when input is invalid */
  invalid: _propTypes.default.bool,

  /** Optional label to float above input, placeholder will not show when using this */
  label: _propTypes.default.node,

  /** Uses a <textarea/> instead */
  multiline: _propTypes.default.bool,

  /** Blur handler for a input */
  onBlur: _propTypes.default.func,

  /** Change handler for a input */
  onChange: _propTypes.default.func,

  /** Focus handler for a input */
  onFocus: _propTypes.default.func,

  /** Placeholder for the input, do not supply with a floating label */
  placeholder: _propTypes.default.string,

  /** Allows a multiline input to be resized */
  resize: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.oneOf(['horizontal', 'vertical'])]),

  /** Add asterik to supplied label, aria-required */
  required: _label.default.propTypes.required,

  /** Set the size of the input */
  size: _propTypes.default.number,

  /** Text to suggest as completion of the input */
  suggestion: _propTypes.default.string,

  /** Input type */
  type: _propTypes.default.oneOf(inputTypes),

  /** Value for the input */
  value: _propTypes.default.node
};
TextEntry.displayName = 'TextEntry';
var _default = TextEntry;
exports.default = _default;