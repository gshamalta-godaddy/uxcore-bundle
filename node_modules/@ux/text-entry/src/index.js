import React, { useState, useCallback } from 'react';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import Label, { ensureLabelComponent } from '@ux/label';
import textClasses from '@ux/text/classes';

const inputTypes = [
  'text',
  'email',
  'password',
  'url',
  'tel',
  'number',
  'search'
];

const UX_TEXT_ENTRY_CLASSNAME = 'ux-text-entry';
const UX_TEXT_ENTRY_SIZE_CHAR = '#';

/**
 * Create props to be added to the shell of the component
 *
 * @param {Object} props - Props from the TextEntry component below
 * @param {String|React.Element} [props.label] - Label for the component
 * @param {Boolean} [props.multiline] - Renders input as textarea
 * @param {Boolean|String} [props.resize] - Allows a multiline input to be resized
 * @param {String} [props.size] - Sets the size of the input
 * @param {String|Number} [props.value] - Value for the input
 * @returns {Object} - Props to be applied to the shell
 */
function getShellProps(props) {
  const { multiline, label, size, resize } = props;

  // Newline character is expected to size vertically
  const sizingCharacter = !multiline ? UX_TEXT_ENTRY_SIZE_CHAR : `
  `;
  // If there's a label, it counts as the first sizing character
  const firstCharacter = !label ? UX_TEXT_ENTRY_SIZE_CHAR : '';

  // This logic handles how large the input should be. .padEnd() doesn't seem to work with newline characters
  let dataSize = Array(size || 1)
    .fill(sizingCharacter)
    .map((v, i) => i === 0 ? firstCharacter : v)
    .join('');

  // Single line with label cannot be horizontally sized
  if (label && !multiline) {
    dataSize = null;
  }

  // This logic determines how the resizing should be applied
  let style;
  if (multiline) {
    style = typeof resize === 'string'
      ? { resize }
      : { resize: resize ? 'both' : 'none' };
  }

  return { 'data-size': dataSize, style };
}

/**
 * Text entry functional component
 * @param {Object} props - Information for the props can be found in the PropTypes below and in TextEntry propTypes
 * @param {String} [props.className] - Optional classname
 * @param {Boolean} [props.disabled] - Sets component as disabled
 * @param {String} props.id - Sets the id of the input
 * @param {Boolean} [props.invalid] - Sets component as invalid
 * @param {String|React.Element} [props.label] - Label for the component
 * @param {Boolean} [props.multiline] - Renders input as textarea
 * @param {String} [props.placeholder] - Sets placeholder text
 * @param {Boolean|String} [props.resize] - Allows a multiline input to be resized
 * @param {Boolean} [props.required] - Sets component as required, only visual
 * @param {String} [props.size] - Sets the size of the input
 * @param {String} [props.suggestion] - Allows for autosuggest functionality
 * @param {String} [props.type] - Attribute for the input type, default is text
 * @param {String|Number} [props.value] - Value for the input
 * @param {Object} ref - Forwarded ref to TextEntry
 * @returns {React.Component} TextEntry component
 */
const TextEntry = React.forwardRef(function (props, ref) {

  const {
    className,
    disabled,
    id,
    invalid,
    label,
    multiline,
    onBlur,
    onChange = Function.prototype,
    onFocus,
    placeholder,
    resize,
    required,
    size,
    suggestion,
    type = 'text',
    value,
    ...rest
  } = props;

  // style is explicitly omitted, do not override.
  delete rest.style;

  const [isFocused, setFocused] = useState(false);

  // Determine if the label should move
  const _onFocus = useCallback((ev) => { setFocused(true); typeof onFocus === 'function' && onFocus(ev); }, [setFocused, onFocus]);
  const _onBlur = useCallback((ev) => { setFocused(false); typeof onBlur === 'function' && onBlur(ev); }, [setFocused, onBlur]);
  const _onChange = useCallback((ev) => { onChange(ev.target.value, { event: ev }); }, [onChange]);

  const TagName = multiline ? 'textarea' : 'input';

  return (
    <div
      className={ classnames(`${UX_TEXT_ENTRY_CLASSNAME}-shell`, className, textClasses({
        as: 'input',
        emphasis: invalid && 'critical'
      })) }
      { ...getShellProps({ multiline, label, size, resize }) }>

      {/** Suggestion text */}
      { suggestion && <span
        className={ `${UX_TEXT_ENTRY_CLASSNAME}-suggestion` }>
        { suggestion }
      </span> }

      {/** Floating label, must be placed BEFORE the input (CSS sibling selector usage) */}
      { !placeholder && ensureLabelComponent(label, {
        float: Boolean(value) || isFocused,
        internal: true,
        required,
        htmlFor: id
      }) }

      {/** The HTML element */}
      <TagName
        ref={ ref }
        className={ `${UX_TEXT_ENTRY_CLASSNAME}-field` }
        disabled={ disabled }
        id={ id }
        placeholder={ placeholder }
        aria-invalid={ invalid }
        aria-required={ Boolean(required) }
        type={ type }
        value={ value }
        onChange={ _onChange }
        onFocus={ _onFocus }
        onBlur={ _onBlur }
        size={ size }
        { ...rest }
      />
    </div>
  );
});

TextEntry.propTypes = {
  /** Classes applied to the shell for positioning purposes */
  className: PropTypes.string,
  /** Sets the disabled state of the input */
  disabled: PropTypes.bool,
  /** Id applied to the input, used for the for attribute on the label */
  id: PropTypes.string.isRequired,
  /** Set component when input is invalid */
  invalid: PropTypes.bool,
  /** Optional label to float above input, placeholder will not show when using this */
  label: PropTypes.node,
  /** Uses a <textarea/> instead */
  multiline: PropTypes.bool,
  /** Blur handler for a input */
  onBlur: PropTypes.func,
  /** Change handler for a input */
  onChange: PropTypes.func,
  /** Focus handler for a input */
  onFocus: PropTypes.func,
  /** Placeholder for the input, do not supply with a floating label */
  placeholder: PropTypes.string,
  /** Allows a multiline input to be resized */
  resize: PropTypes.oneOfType([
    PropTypes.bool,
    PropTypes.oneOf(['horizontal', 'vertical'])
  ]),
  /** Add asterik to supplied label, aria-required */
  required: Label.propTypes.required,
  /** Set the size of the input */
  size: PropTypes.number,
  /** Text to suggest as completion of the input */
  suggestion: PropTypes.string,
  /** Input type */
  type: PropTypes.oneOf(inputTypes),
  /** Value for the input */
  value: PropTypes.node
};

TextEntry.displayName = 'TextEntry';

export default TextEntry;
