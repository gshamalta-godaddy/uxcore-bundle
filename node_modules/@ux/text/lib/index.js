"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.text = exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classes = _interopRequireWildcard(require("./classes"));

const _excluded = ["as", "className", "children", "emphasis", "size", "text"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Creates a function which represents a dynamic React component
 *
 * @param {String} TagName - The tag name of the element to use for text
 * @returns {Function} - A function to create a component
 */
function create(TagName) {
  /**
   * Creates a React component using the given tag name
   *
   * @param {Object} props - A props configuration object
   * @param {String} [props.as] - A category of text
   * @param {String} [props.className] - A class name to include
   * @param {Node} [props.children] - Deprecated, use text prop instead
   * @param {String} [props.emphasis] - Includes styles to represent feedback
   * @param {Number} [props.size] - A number representing the font size
   * @param {String} [props.text] - The text content
   * @returns {React.Component} - A functional React component
   */
  function Text(props) {
    const _ref = props || {},
          {
      as,
      className,
      children,
      emphasis,
      size,
      text
    } = _ref,
          rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);

    if (process.env.NODE_ENV !== 'production' && children) {
      console.warn(`Warning: The use of children elements within @ux/text is deprecated.
          Please use the 'text' prop instead.`);
    }

    return /*#__PURE__*/_react.default.createElement(TagName, (0, _extends2.default)({
      className: (0, _classes.default)({
        as,
        className,
        emphasis,
        size
      })
    }, rest), text || children);
  }
  /**
   *
   * @enum {Object} expected types of properties.
   * @public
   */


  Text.propTypes = {
    /** The type of text expected in the component */
    as: _propTypes.default.oneOf(_classes.asOptions),

    /** Deprecated, children for the component, please use text prop instead */
    children: _propTypes.default.node,

    /** Classes to apply to component */
    className: _propTypes.default.string,

    /** The emphasis of text expected in the component */
    emphasis: _propTypes.default.oneOf(_classes.emphasisOptions),

    /** The size of the text, affected by the 'as' prop */
    size: _propTypes.default.number,

    /** Text to be displayed */
    text: _propTypes.default.string
  };
  return Text;
}

const text = new Proxy(function () {}, {
  get: function get(target, prop) {
    // Deliberately not using hasOwnProperty to catch things like __proto__
    if (!String(prop).startsWith('_') && typeof target[prop] === 'undefined') {
      // Cache access by creating a key with value
      target[prop] = create(prop);
    } // Always return thing at that key, either undefined or thing set


    return Reflect.get(...arguments);
  }
});
exports.text = text;
var _default = text;
exports.default = _default;