"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Tooltip = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classNames = _interopRequireDefault(require("@ux/component-utilities/lib/classNames"));

var _useClickOutsideHoc = _interopRequireDefault(require("@ux/component-utilities/lib/use-click-outside-hoc"));

var _tooltipClose = _interopRequireDefault(require("./tooltip-close"));

var _tooltipContent = _interopRequireDefault(require("./tooltip-content"));

var _tooltipTitle = _interopRequireDefault(require("./tooltip-title"));

var _tooltipPortal = _interopRequireDefault(require("./tooltip-portal"));

var _help = _interopRequireDefault(require("@ux/icon/help"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Display a Tooltip.
 *
 * @displayName Tooltip (Web)
 * @class Tooltip
 * @public
 */
class Tooltip extends _react.Component {
  constructor() {
    super(...arguments);
    this.state = {
      isOpen: false
    };
    this.anchorRef = /*#__PURE__*/_react.default.createRef();
    this.contentRef = /*#__PURE__*/_react.default.createRef();
    this.close = this.close.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.anchorMouseEnter = this.anchorMouseEnter.bind(this);
    this.anchorMouseLeave = this.anchorMouseLeave.bind(this);
    this.startAutoHideTimer = this.startAutoHideTimer.bind(this);
    this.stopAutoHideTimer = this.stopAutoHideTimer.bind(this);
    this.autoHideTime = 0;
    this.autoHideTimerHandle = null;
  }
  /**
   * Getter to return a handler to toggle the tooltip. If no tooltip instance
   * is available, it will be opened. Otherwise it will be closed.
   *
   * Propagation cannot be stopped here as other tooltips need to be closed with
   * the same click event.
   *
   * @param {React.SyntheticEvent} event React SyntheticClick event.
   * @public
   */


  get toggle() {
    return event => {
      event.preventDefault();
      this[this.state.isOpen ? 'close' : 'open'](event);
    };
  }
  /**
   * Getter to return a handler that closes the tooltip and calls the `onDismiss`
   * property.
   *
   * This function is supposed to be called only when the user clicks the
   * `close` button, representing that the user had a clear intent to close
   * the tooltip.
   *
   * @private
   */


  get dismiss() {
    return event => {
      event.preventDefault();
      this.close();
      this.props.onDismiss && this.props.onDismiss();
    };
  }
  /**
   * Check if the component needs to be re-rendered.
   * If `props.open` has changed, it will open or close the tooltip as needed.
   *
   * @param {Object} prevProps values before the component update.
   * @private
   */


  componentDidUpdate(prevProps) {
    const {
      open
    } = this.props;

    if (open !== prevProps.open) {
      if (open) {
        this.open();
      } else {
        this.close();
      }
    }
  }
  /**
   * Open the tooltip if `props.open` is true.
   *
   * @private
   */


  componentDidMount() {
    if (this.props.open) {
      this.open();
    }
  }
  /**
   * Remove the attached click event listener and close any remaining tooltips.
   *
   * @private
   */


  componentWillUnmount() {
    this.stopAutoHideTimer();
    this.close();
  }
  /**
   * Handles mouse enter event for the anchor element
   *
   * @param {Event} event React SyntheticMouseEnter event.
   * @private
   */


  anchorMouseEnter(event) {
    if (!this.props.openOnHover) {
      return;
    }

    this.open(event);
    this.stopAutoHideTimer();
  }
  /**
   * Handles mouse leave event for the anchor element
   *
   * @private
   */


  anchorMouseLeave() {
    this.startAutoHideTimer();
  }
  /**
   * Starts or restarts auto hide timer using `autoHideTimeout` prop
   *
   * @private
   */


  startAutoHideTimer() {
    if (!this.props.autoHideTimeout) {
      return;
    }

    this.stopAutoHideTimer();
    this.autoHideTimerHandle = window.setTimeout(this.close, this.props.autoHideTimeout);
  }
  /**
   * Stops (clears) auto hide timer
   *
   * @private
   */


  stopAutoHideTimer() {
    if (this.autoHideTimerHandle) {
      window.clearTimeout(this.autoHideTimerHandle);
    }
  }
  /**
   * Handle keyboard events for escape key on the tooltip, this can be
   * used to augment the default behavior if you want to have manual control
   * over closing of the tooltip.
   *
   * @param {Event} event Browser event.
   * @private
   */


  onKeyDown(event) {
    const key = event.key;

    if (key && key === ' ' || key === 'Enter' || key === 'Return') {
      event.preventDefault();
      this.toggle(event);
    }

    if (event.type === 'keydown' && key === 'Escape') {
      event.preventDefault();
      this.close(event);
    }
  }
  /**
   * Unmount and remove the Content Component. This methods is used as
   * event handler and therefore follows the getter pattern.
   *
   * @public
   */


  close() {
    if (!this.state.isOpen) return;
    this.setState({
      isOpen: false
    }, this.props.onClose);
  }
  /**
   * Close event handler specifically for when a close was triggered by clicking
   * outside of the tooltip
   *
   * @param {Event} event React SyntheticMouseEnter event.
   * @private
   */


  closeFromClickOutside(event) {
    // If the event that triggered the outside close was hitting the anchor, "ignore" the event
    // We ignore it because we're deferring the process of closing the tooltip to the anchor's
    // click handler chain.
    const composedPath = typeof event.composedPath === 'function' && !Array.from(event.composedPath()).includes(this.anchorRef.current);

    if (!composedPath || !this.anchorRef.current || this.anchorRef.current.contains(event.target)) {
      return;
    }

    this.close();
  }
  /**
   * This method is called from `toggle` to open the tooltip.
   *
   * @public
   */


  open() {
    if (this.state.isOpen) return;
    this.setState({
      isOpen: true
    }, this.props.onOpen);
  }
  /**
   * Render Tooltip component.
   *
   * @returns {ReactElement} div element with Tooltip.
   * @private
   */


  render() {
    const pointer = {
      cursor: 'pointer'
    };
    const props = this.props;
    const dataEid = props['data-eid'];
    const className = (0, _classNames.default)(props.text ? 'tooltip-over-text' : 'tooltip-help-icon');
    const onClick = !props.persistent ? this.toggle : null;
    const onKeyDown = !props.persistent ? this.onKeyDown : null;
    const onMouseEnter = props.openOnHover ? this.anchorMouseEnter : null;
    const onMouseLeave = props.autoHideTimeout ? this.anchorMouseLeave : null;

    if ( /*#__PURE__*/_react.default.isValidElement(props.children)) {
      const child = _react.default.Children.only(props.children);

      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, this.state.isOpen && /*#__PURE__*/_react.default.createElement(_useClickOutsideHoc.default, {
        onClick: e => {
          if (props.persistent) return;
          this.closeFromClickOutside(e);
        },
        targetRef: this.contentRef
      }, /*#__PURE__*/_react.default.createElement(_tooltipPortal.default, (0, _extends2.default)({}, props, {
        contentRef: this.contentRef,
        anchor: this.anchorRef.current,
        root: props.root,
        hideClose: props.hideClose,
        openOnHover: props.openOnHover,
        close: this.close,
        open: this.open,
        dismiss: this.dismiss,
        onMouseEnter: this.stopAutoHideTimer,
        onMouseLeave: this.startAutoHideTimer
      })), " "), /*#__PURE__*/_react.default.cloneElement(child, {
        'style': Object.assign({}, child.props.style || {}, pointer),
        onClick,
        onMouseEnter,
        onMouseLeave,
        onKeyDown,
        'id': props.id,
        'ref': this.anchorRef,
        'tabIndex': props.tabIndex,
        'data-eid': dataEid,
        'aria-label': props.ariaLabels.tooltipClick
      }));
    }

    return /*#__PURE__*/_react.default.createElement("span", {
      id: props.id,
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave
    }, this.state.isOpen && /*#__PURE__*/_react.default.createElement(_useClickOutsideHoc.default, {
      onClick: e => {
        if (props.persistent) return;
        this.closeFromClickOutside(e);
      },
      targetRef: this.contentRef
    }, /*#__PURE__*/_react.default.createElement(_tooltipPortal.default, (0, _extends2.default)({}, props, {
      contentRef: this.contentRef,
      anchor: this.anchorRef.current,
      hideClose: props.hideClose,
      openOnHover: props.openOnHover,
      close: this.close,
      dismiss: this.dismiss,
      onMouseEnter: this.stopAutoHideTimer,
      onMouseLeave: this.startAutoHideTimer
    }))), props.children, /*#__PURE__*/_react.default.createElement("span", {
      role: "button",
      "aria-haspopup": "true",
      "aria-label": props.ariaLabels.tooltipClick,
      tabIndex: props.tabIndex,
      className: className,
      onClick: onClick,
      onKeyDown: onKeyDown,
      style: pointer,
      ref: this.anchorRef,
      "data-eid": dataEid
    }, props.text || /*#__PURE__*/_react.default.createElement(_help.default, {
      height: 16,
      width: 16,
      role: "presentation"
    })));
  }

}
/**
 * Default prop values.
 *
 * @enum {Object} defaultProps
 * @public
 */


exports.Tooltip = Tooltip;
Tooltip.defaultProps = {
  persistent: false,
  openOnHover: false,
  hideClose: false,
  open: false,
  tabIndex: 0,
  ariaLabels: {
    close: 'Close Tooltip',
    tooltipClick: 'Click here for more information'
  }
};
/**
 * Property types definition.
 *
 * @enum {Object} propTypes
 * @public
 */

Tooltip.propTypes = {
  /** HTML element id to use for the anchor element */
  'id': _propTypes.default.string,

  /** Flag for whether a tooltip is persistent */
  'persistent': _propTypes.default.bool,

  /** (Desktop/Mouse use only) Flag for whether the tooltip should open when the anchor is hovered */
  'openOnHover': _propTypes.default.bool,

  /** The number of milliseconds before a tooltip auto-hides */
  'autoHideTimeout': _propTypes.default.number,

  /** (Desktop/Mouse use only) Hides the close button for use as a hover only tooltip **/
  'hideClose': _propTypes.default.bool,

  /** className for styling */
  'className': _propTypes.default.string,

  /** Children to use as the tooltip anchor */
  'children': _propTypes.default.node,

  /** Tooltip message content */
  'message': _propTypes.default.node,

  /** The root document to attach the tooltip, defaults to document.documentElement. Used to support Shadow DOM */
  'root': _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.shape({
    current: _propTypes.default.object
  })]),

  /** Content for the tooltip title */
  'title': _propTypes.default.node,

  /** Text content for the tooltip anchor */
  'text': _propTypes.default.node,

  /** Flag for if the tooltip should open at start */
  'open': _propTypes.default.bool,

  /** Handler for when a tooltip is closed */
  'onClose': _propTypes.default.func,

  /** Handler for when a tooltip is opened */
  'onOpen': _propTypes.default.func,

  /** Handler for when a tooltip is closed explicitly by the user */
  'onDismiss': _propTypes.default.func,

  /** The accessibility tab index value */
  'tabIndex': _propTypes.default.number,

  /** The eid to identify click origin */
  'data-eid': _propTypes.default.string,

  /** The aria-label to identify the button */
  'ariaLabels': _propTypes.default.shape({
    /** Screen reader label for close button */
    close: _propTypes.default.string,

    /** Screen reader label for icon button */
    tooltipClick: _propTypes.default.string
  })
}; //
// Make importing easier by exposing the individual components to the Tooltip
// class.
//

Tooltip.Close = _tooltipClose.default;
Tooltip.Content = _tooltipContent.default;
Tooltip.Title = _tooltipTitle.default;
var _default = Tooltip;
exports.default = _default;