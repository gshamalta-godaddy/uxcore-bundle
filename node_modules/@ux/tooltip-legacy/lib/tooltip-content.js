"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TooltipContent = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classNames = _interopRequireDefault(require("@ux/component-utilities/lib/classNames"));

var _offset = _interopRequireDefault(require("@ux/component-utilities/lib/offset"));

var _offsetRelative = _interopRequireDefault(require("@ux/component-utilities/lib/offset-relative"));

var _tooltipClose = _interopRequireDefault(require("./tooltip-close"));

var _tooltipTitle = _interopRequireDefault(require("./tooltip-title"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Render and position the tooltip content.
 *
 * @class TooltipContent
 * @private
 */
class TooltipContent extends _react.Component {
  constructor() {
    super(...arguments);
    this.state = {
      anchor: {
        height: 0,
        width: 0,
        top: 0,
        y: 0,
        x: 0
      }
    };
    this.element = /*#__PURE__*/_react.default.createRef();
  }
  /**
   * After the initial render the tooltip will need to be re-rendered for
   * correct positioning in the DOM.
   *
   * @private
   */


  componentDidMount() {
    document.addEventListener('resize', this.update);
    this.recalculateAnchor();
  }
  /**
   * Remove the attached click event listener.
   *
   * @private
   */


  componentWillUnmount() {
    document.removeEventListener('resize', this.update);
  }
  /**
   * Provide the position and dimensions of the anchor element each time the
   * component is about to update the DOM.
   *
   * @private
   */


  componentDidUpdate() {
    this.recalculateAnchor();
  }
  /**
   * Force an update of the component, usually required to update the position.
   *
   * @private
   */


  update() {
    this.forceUpdate();
  }

  anchorsDiffer(prevAnchor, newAnchor) {
    return JSON.stringify(prevAnchor) !== JSON.stringify(newAnchor);
  }

  recalculateAnchor() {
    const {
      anchor,
      root
    } = this.props;
    const {
      top: y,
      left: x
    } = (0, _offset.default)(anchor);
    const bounding = anchor.getBoundingClientRect();
    const recalculatedAnchor = {
      x,
      y,
      height: bounding.height,
      top: bounding.top,
      width: bounding.width
    };

    if (root) {
      const {
        left,
        top
      } = (0, _offsetRelative.default)(anchor, root);
      recalculatedAnchor.y = top;
      recalculatedAnchor.x = left;
    }

    const prevAnchor = this.state.anchor;

    if (this.anchorsDiffer(prevAnchor, recalculatedAnchor)) {
      this.setState({
        anchor: recalculatedAnchor
      });
    }
  }
  /**
   * Get top and left distances of the tooltip. Also return if the tooltip needs
   * to be rendered above or below the anchor.
   *
   * @returns {Array} positional values.
   * @private
   */
  // eslint-disable-next-line max-statements


  get position() {
    let left; //
    // Deliberately return to top left corner here so the tooltip will get the
    // maximum space to render. Having it elsewhere on the page might cause
    // the message to render with a different width causing errors in the
    // calculation afterwards.
    //

    if (!this.element.current) {
      return [{
        visibility: 'hidden'
      }];
    }

    const {
      anchor
    } = this.state;
    const viewportWidth = window.innerWidth;
    const tooltip = this.element.current.getBoundingClientRect();
    const height = tooltip.height;
    const width = tooltip.width;
    const above = height < anchor.top; //
    // Determine x position on the tooltip, attempt to place it centered above
    // the anchor at first.
    //

    left = Math.floor(anchor.x + anchor.width / 2 - width / 2);
    const delta = above ? height : -anchor.height;
    const overflow = left + width - viewportWidth;
    const arrowMargin = {
      marginLeft: this.arrowMarginLeft
    }; //
    // Move the tooltip further to the left if there is not enough space in
    // the viewport to the right side of the anchor. Also move the arrow the
    //

    if (overflow > 0) {
      arrowMargin.marginLeft += overflow;
      left -= overflow;
    } //
    // Do not allow for positioning left < 0, respect boundaries of the viewport.
    // Instead move the arrow with margin-left above the anchor.
    //


    if (left < 0) {
      arrowMargin.marginLeft += left;
      left = 0;
    }

    return [{
      top: Math.floor(anchor.y - delta),
      left: left
    }, arrowMargin, above];
  }
  /**
   * Render Tooltip content and store references to the wrapping div and the arrow.
   * Both are required for positional calculations and updates.
   *
   * @returns {ReactElement} div element with Tooltip content.
   * @private
   */


  render() {
    const props = this.props;
    const [style, arrowMargin, above] = this.position;
    const clsx = (0, _classNames.default)([props.className, 'tooltip', 'show', {
      'bs-tooltip-bottom': above,
      'bs-tooltip-top': !above
    }]); //
    // Get and store the arrow's original margin-left
    //

    const arrowMarginRef = r => {
      if (!this.arrowMarginLeft && r) {
        this.arrowMarginLeft = parseInt(window.getComputedStyle(r).getPropertyValue('margin-left'), 10) || 0;
      }
    };

    return /*#__PURE__*/_react.default.createElement("div", {
      className: 'spaced-group',
      ref: this.props.contentRef
    }, /*#__PURE__*/_react.default.createElement("div", {
      role: "tooltip",
      ref: this.element,
      className: clsx,
      style: style,
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: 'tooltip-arrow',
      ref: arrowMarginRef,
      style: arrowMargin
    }), /*#__PURE__*/_react.default.createElement("div", {
      className: 'tooltip-inner'
    }, props.hideClose || /*#__PURE__*/_react.default.createElement(_tooltipClose.default, {
      close: props.dismiss,
      ariaLabels: props.ariaLabels,
      className: 'tooltip-close'
    }), /*#__PURE__*/_react.default.createElement("span", {
      role: "status",
      "aria-live": "assertive"
    }, props.title && /*#__PURE__*/_react.default.createElement(_tooltipTitle.default, {
      className: 'tooltip-title'
    }, props.title), props.message))));
  }

}
/**
 * Define required and types of properties.
 *
 * @enum {Object} propTypes
 * @private
 */


exports.TooltipContent = TooltipContent;
TooltipContent.propTypes = {
  // @see https://stackoverflow.com/a/51127130
  contentRef: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.shape({
    current: _propTypes.default.any
  })]),
  anchor: _propTypes.default.object,
  root: _propTypes.default.object,
  message: _propTypes.default.node,
  title: _propTypes.default.node,
  close: _propTypes.default.func.isRequired,
  onMouseEnter: _propTypes.default.func,
  onMouseLeave: _propTypes.default.func,
  hideClose: _propTypes.default.bool,
  persistent: _propTypes.default.bool,
  dismiss: _propTypes.default.func,
  className: _propTypes.default.string,
  ariaLabels: _propTypes.default.shape({
    close: _propTypes.default.string
  })
};
var _default = TooltipContent;
exports.default = _default;