import React, { Component } from 'react';
import PropTypes from 'prop-types';
import classNames from '@ux/component-utilities/lib/classNames';
import ClickOutside from '@ux/component-utilities/lib/use-click-outside-hoc';
import Close from './tooltip-close';
import Content from './tooltip-content';
import Title from './tooltip-title';
import TooltipPortal from './tooltip-portal';
import Help from '@ux/icon/help';

/**
 * Display a Tooltip.
 *
 * @displayName Tooltip (Web)
 * @class Tooltip
 * @public
 */
export class Tooltip extends Component {
  constructor() {
    super(...arguments);
    this.state = {
      isOpen: false
    };
    this.anchorRef = React.createRef();
    this.contentRef = React.createRef();
    this.close = this.close.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.anchorMouseEnter = this.anchorMouseEnter.bind(this);
    this.anchorMouseLeave = this.anchorMouseLeave.bind(this);
    this.startAutoHideTimer = this.startAutoHideTimer.bind(this);
    this.stopAutoHideTimer = this.stopAutoHideTimer.bind(this);
    this.autoHideTime = 0;
    this.autoHideTimerHandle = null;
  }

  /**
   * Getter to return a handler to toggle the tooltip. If no tooltip instance
   * is available, it will be opened. Otherwise it will be closed.
   *
   * Propagation cannot be stopped here as other tooltips need to be closed with
   * the same click event.
   *
   * @param {React.SyntheticEvent} event React SyntheticClick event.
   * @public
   */
  get toggle() {
    return event => {
      event.preventDefault();
      this[this.state.isOpen ? 'close' : 'open'](event);
    };
  }

  /**
   * Getter to return a handler that closes the tooltip and calls the `onDismiss`
   * property.
   *
   * This function is supposed to be called only when the user clicks the
   * `close` button, representing that the user had a clear intent to close
   * the tooltip.
   *
   * @private
   */
  get dismiss() {
    return event => {
      event.preventDefault();

      this.close();
      this.props.onDismiss && this.props.onDismiss();
    };
  }

  /**
   * Check if the component needs to be re-rendered.
   * If `props.open` has changed, it will open or close the tooltip as needed.
   *
   * @param {Object} prevProps values before the component update.
   * @private
   */
  componentDidUpdate(prevProps) {
    const { open } = this.props;

    if (open !== prevProps.open) {
      if (open) {
        this.open();
      } else {
        this.close();
      }
    }
  }

  /**
   * Open the tooltip if `props.open` is true.
   *
   * @private
   */
  componentDidMount() {
    if (this.props.open) {
      this.open();
    }
  }

  /**
   * Remove the attached click event listener and close any remaining tooltips.
   *
   * @private
   */
  componentWillUnmount() {
    this.stopAutoHideTimer();
    this.close();
  }

  /**
   * Handles mouse enter event for the anchor element
   *
   * @param {Event} event React SyntheticMouseEnter event.
   * @private
   */
  anchorMouseEnter(event) {
    if (!this.props.openOnHover) {
      return;
    }

    this.open(event);
    this.stopAutoHideTimer();
  }

  /**
   * Handles mouse leave event for the anchor element
   *
   * @private
   */
  anchorMouseLeave() {
    this.startAutoHideTimer();
  }

  /**
   * Starts or restarts auto hide timer using `autoHideTimeout` prop
   *
   * @private
   */
  startAutoHideTimer() {
    if (!this.props.autoHideTimeout) {
      return;
    }

    this.stopAutoHideTimer();
    this.autoHideTimerHandle = window.setTimeout(
      this.close,
      this.props.autoHideTimeout
    );
  }

  /**
   * Stops (clears) auto hide timer
   *
   * @private
   */
  stopAutoHideTimer() {
    if (this.autoHideTimerHandle) {
      window.clearTimeout(this.autoHideTimerHandle);
    }
  }

  /**
   * Handle keyboard events for escape key on the tooltip, this can be
   * used to augment the default behavior if you want to have manual control
   * over closing of the tooltip.
   *
   * @param {Event} event Browser event.
   * @private
   */
  onKeyDown(event) {
    const key = event.key;

    if (key && key === ' ' || key === 'Enter' || key === 'Return') {
      event.preventDefault();
      this.toggle(event);
    }

    if (event.type === 'keydown' && key === 'Escape') {
      event.preventDefault();
      this.close(event);
    }
  }

  /**
   * Unmount and remove the Content Component. This methods is used as
   * event handler and therefore follows the getter pattern.
   *
   * @public
   */
  close() {
    if (!this.state.isOpen) return;

    this.setState({
      isOpen: false
    }, this.props.onClose);
  }

  /**
   * Close event handler specifically for when a close was triggered by clicking
   * outside of the tooltip
   *
   * @param {Event} event React SyntheticMouseEnter event.
   * @private
   */
  closeFromClickOutside(event) {
    // If the event that triggered the outside close was hitting the anchor, "ignore" the event
    // We ignore it because we're deferring the process of closing the tooltip to the anchor's
    // click handler chain.
    const composedPath = typeof event.composedPath === 'function' && !Array.from(event.composedPath()).includes(this.anchorRef.current);
    if (!composedPath || !this.anchorRef.current || this.anchorRef.current.contains(event.target)) {
      return;
    }

    this.close();
  }

  /**
   * This method is called from `toggle` to open the tooltip.
   *
   * @public
   */
  open() {
    if (this.state.isOpen) return;

    this.setState({
      isOpen: true
    }, this.props.onOpen);
  }

  /**
   * Render Tooltip component.
   *
   * @returns {ReactElement} div element with Tooltip.
   * @private
   */
  render() {
    const pointer = {
      cursor: 'pointer'
    };
    const props = this.props;
    const dataEid = props['data-eid'];
    const className = classNames(
      props.text ? 'tooltip-over-text' : 'tooltip-help-icon'
    );
    const onClick = !props.persistent ? this.toggle : null;
    const onKeyDown = !props.persistent ? this.onKeyDown : null;
    const onMouseEnter = props.openOnHover ? this.anchorMouseEnter : null;
    const onMouseLeave = props.autoHideTimeout ? this.anchorMouseLeave : null;

    if (React.isValidElement(props.children)) {
      const child = React.Children.only(props.children);

      return (
        <React.Fragment>
          { this.state.isOpen &&
              <ClickOutside
                onClick={ (e) => {
                  if (props.persistent) return;
                  this.closeFromClickOutside(e);
                } }
                targetRef={ this.contentRef }>
                <TooltipPortal
                  { ...props }
                  contentRef={ this.contentRef }
                  anchor={ this.anchorRef.current }
                  root={ props.root }
                  hideClose={ props.hideClose }
                  openOnHover={ props.openOnHover }
                  close={ this.close }
                  open={ this.open }
                  dismiss={ this.dismiss }
                  onMouseEnter={ this.stopAutoHideTimer }
                  onMouseLeave={ this.startAutoHideTimer }
                /> </ClickOutside>
          }
          {React.cloneElement(child, {
            'style': Object.assign({}, child.props.style || {}, pointer),
            onClick,
            onMouseEnter,
            onMouseLeave,
            onKeyDown,
            'id': props.id,
            'ref': this.anchorRef,
            'tabIndex': props.tabIndex,
            'data-eid': dataEid,
            'aria-label': props.ariaLabels.tooltipClick
          })}
        </React.Fragment>
      );
    }

    return (
      <span
        id={ props.id }
        onMouseEnter={ onMouseEnter }
        onMouseLeave={ onMouseLeave }>
        {this.state.isOpen &&
                <ClickOutside
                  onClick={ (e) => {
                    if (props.persistent) return;
                    this.closeFromClickOutside(e);
                  } }
                  targetRef={ this.contentRef }>
                  <TooltipPortal
                    { ...props }
                    contentRef={ this.contentRef }
                    anchor={ this.anchorRef.current }
                    hideClose={ props.hideClose }
                    openOnHover={ props.openOnHover }
                    close={ this.close }
                    dismiss={ this.dismiss }
                    onMouseEnter={ this.stopAutoHideTimer }
                    onMouseLeave={ this.startAutoHideTimer }
                  />
                </ClickOutside>
        }
        {props.children}
        <span
          role='button'
          aria-haspopup='true'
          aria-label={ props.ariaLabels.tooltipClick }
          tabIndex={ props.tabIndex }
          className={ className }
          onClick={ onClick }
          onKeyDown={ onKeyDown }
          style={ pointer }
          ref={ this.anchorRef }
          data-eid={ dataEid }>
          { props.text || <Help height={ 16 } width={ 16 } role='presentation' /> }
        </span>
      </span>
    );
  }
}

/**
 * Default prop values.
 *
 * @enum {Object} defaultProps
 * @public
 */
Tooltip.defaultProps = {
  persistent: false,
  openOnHover: false,
  hideClose: false,
  open: false,
  tabIndex: 0,
  ariaLabels: ({
    close: 'Close Tooltip',
    tooltipClick: 'Click here for more information'
  })
};

/**
 * Property types definition.
 *
 * @enum {Object} propTypes
 * @public
 */
Tooltip.propTypes = {
  /** HTML element id to use for the anchor element */
  'id': PropTypes.string,
  /** Flag for whether a tooltip is persistent */
  'persistent': PropTypes.bool,
  /** (Desktop/Mouse use only) Flag for whether the tooltip should open when the anchor is hovered */
  'openOnHover': PropTypes.bool,
  /** The number of milliseconds before a tooltip auto-hides */
  'autoHideTimeout': PropTypes.number,
  /** (Desktop/Mouse use only) Hides the close button for use as a hover only tooltip **/
  'hideClose': PropTypes.bool,
  /** className for styling */
  'className': PropTypes.string,
  /** Children to use as the tooltip anchor */
  'children': PropTypes.node,
  /** Tooltip message content */
  'message': PropTypes.node,
  /** The root document to attach the tooltip, defaults to document.documentElement. Used to support Shadow DOM */
  'root': PropTypes.oneOfType([PropTypes.node, PropTypes.shape({ current: PropTypes.object })]),
  /** Content for the tooltip title */
  'title': PropTypes.node,
  /** Text content for the tooltip anchor */
  'text': PropTypes.node,
  /** Flag for if the tooltip should open at start */
  'open': PropTypes.bool,
  /** Handler for when a tooltip is closed */
  'onClose': PropTypes.func,
  /** Handler for when a tooltip is opened */
  'onOpen': PropTypes.func,
  /** Handler for when a tooltip is closed explicitly by the user */
  'onDismiss': PropTypes.func,
  /** The accessibility tab index value */
  'tabIndex': PropTypes.number,
  /** The eid to identify click origin */
  'data-eid': PropTypes.string,
  /** The aria-label to identify the button */
  'ariaLabels': PropTypes.shape({
    /** Screen reader label for close button */
    close: PropTypes.string,
    /** Screen reader label for icon button */
    tooltipClick: PropTypes.string
  })
};

//
// Make importing easier by exposing the individual components to the Tooltip
// class.
//
Tooltip.Close = Close;
Tooltip.Content = Content;
Tooltip.Title = Title;

export default Tooltip;
