import React, { Component } from 'react';
import PropTypes from 'prop-types';
import classNames from '@ux/component-utilities/lib/classNames';
import offset from '@ux/component-utilities/lib/offset';
import offsetRelative from '@ux/component-utilities/lib/offset-relative';
import Close from './tooltip-close';
import Title from './tooltip-title';

/**
 * Render and position the tooltip content.
 *
 * @class TooltipContent
 * @private
 */
export class TooltipContent extends Component {
  constructor() {
    super(...arguments);
    this.state = {
      anchor: {
        height: 0,
        width: 0,
        top: 0,
        y: 0,
        x: 0
      }
    };
    this.element = React.createRef();
  }

  /**
   * After the initial render the tooltip will need to be re-rendered for
   * correct positioning in the DOM.
   *
   * @private
   */
  componentDidMount() {
    document.addEventListener('resize', this.update);
    this.recalculateAnchor();
  }

  /**
   * Remove the attached click event listener.
   *
   * @private
   */
  componentWillUnmount() {
    document.removeEventListener('resize', this.update);
  }

  /**
   * Provide the position and dimensions of the anchor element each time the
   * component is about to update the DOM.
   *
   * @private
   */
  componentDidUpdate() {
    this.recalculateAnchor();
  }

  /**
   * Force an update of the component, usually required to update the position.
   *
   * @private
   */
  update() {
    this.forceUpdate();
  }

  anchorsDiffer(prevAnchor, newAnchor) {
    return JSON.stringify(prevAnchor) !== JSON.stringify(newAnchor);
  }

  recalculateAnchor() {
    const { anchor, root } = this.props;
    const { top: y, left: x } = offset(anchor);
    const bounding = anchor.getBoundingClientRect();
    const recalculatedAnchor = {
      x,
      y,
      height: bounding.height,
      top: bounding.top,
      width: bounding.width
    };

    if (root) {
      const { left, top } = offsetRelative(anchor, root);
      recalculatedAnchor.y = top;
      recalculatedAnchor.x = left;
    }

    const prevAnchor = this.state.anchor;
    if (this.anchorsDiffer(prevAnchor, recalculatedAnchor)) {
      this.setState({
        anchor: recalculatedAnchor
      });
    }
  }

  /**
   * Get top and left distances of the tooltip. Also return if the tooltip needs
   * to be rendered above or below the anchor.
   *
   * @returns {Array} positional values.
   * @private
   */
  // eslint-disable-next-line max-statements
  get position() {
    let left;

    //
    // Deliberately return to top left corner here so the tooltip will get the
    // maximum space to render. Having it elsewhere on the page might cause
    // the message to render with a different width causing errors in the
    // calculation afterwards.
    //
    if (!this.element.current) {
      return [{
        visibility: 'hidden'
      }];
    }

    const { anchor } = this.state;
    const viewportWidth = window.innerWidth;
    const tooltip = this.element.current.getBoundingClientRect();
    const height = tooltip.height;
    const width = tooltip.width;
    const above = height < anchor.top;

    //
    // Determine x position on the tooltip, attempt to place it centered above
    // the anchor at first.
    //
    left = Math.floor(anchor.x + (anchor.width / 2) - (width / 2));

    const delta = above ? height : -anchor.height;
    const overflow = left + width - viewportWidth;

    const arrowMargin = {
      marginLeft: this.arrowMarginLeft
    };

    //
    // Move the tooltip further to the left if there is not enough space in
    // the viewport to the right side of the anchor. Also move the arrow the
    //
    if (overflow > 0) {
      arrowMargin.marginLeft += overflow;
      left -= overflow;
    }

    //
    // Do not allow for positioning left < 0, respect boundaries of the viewport.
    // Instead move the arrow with margin-left above the anchor.
    //
    if (left < 0) {
      arrowMargin.marginLeft += left;
      left = 0;
    }

    return [{
      top: Math.floor(anchor.y - delta),
      left: left
    }, arrowMargin, above];
  }

  /**
   * Render Tooltip content and store references to the wrapping div and the arrow.
   * Both are required for positional calculations and updates.
   *
   * @returns {ReactElement} div element with Tooltip content.
   * @private
   */
  render() {
    const props = this.props;
    const [style, arrowMargin, above] = this.position;
    const clsx = classNames([
      props.className,
      'tooltip',
      'show',
      {
        'bs-tooltip-bottom': above,
        'bs-tooltip-top': !above
      }
    ]);

    //
    // Get and store the arrow's original margin-left
    //
    const arrowMarginRef = r => {
      if (!this.arrowMarginLeft && r) {
        this.arrowMarginLeft =
          parseInt(
            window.getComputedStyle(r).getPropertyValue('margin-left'),
            10
          ) || 0;
      }
    };

    return (
      <div className={ 'spaced-group' } ref={ this.props.contentRef }>
        <div
          role='tooltip'
          ref={ this.element }
          className={ clsx }
          style={ style }
          onMouseEnter={ props.onMouseEnter }
          onMouseLeave={ props.onMouseLeave }>
          <div
            className={ 'tooltip-arrow' }
            ref={ arrowMarginRef }
            style={ arrowMargin }></div>
          <div className={ 'tooltip-inner' }>
            {props.hideClose ||
              <Close close={ props.dismiss } ariaLabels={ props.ariaLabels } className={ 'tooltip-close' } />
            }
            <span role='status' aria-live='assertive'>
              {props.title && (
                <Title className={ 'tooltip-title' }>{props.title}</Title>
              )}
              {props.message}
            </span>
          </div>
        </div>
      </div>
    );
  }
}

/**
 * Define required and types of properties.
 *
 * @enum {Object} propTypes
 * @private
 */
TooltipContent.propTypes = {
  // @see https://stackoverflow.com/a/51127130
  contentRef: PropTypes.oneOfType([
    PropTypes.func,
    PropTypes.shape({ current: PropTypes.any })
  ]),
  anchor: PropTypes.object,
  root: PropTypes.object,
  message: PropTypes.node,
  title: PropTypes.node,
  close: PropTypes.func.isRequired,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  hideClose: PropTypes.bool,
  persistent: PropTypes.bool,
  dismiss: PropTypes.func,
  className: PropTypes.string,
  ariaLabels: PropTypes.shape({
    close: PropTypes.string
  })
};

export default TooltipContent;
