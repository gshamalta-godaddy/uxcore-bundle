const path = require('path');
const { externals } = require('../index.js');

/**
 * Extract the dependent modules from the package.
 *
 * @param {Object} pkg Parsed contents of your `package.json` file.
 * @returns {Object} List of packages->version pairs that we depend on.
 * @private
 */
module.exports = function extract({ root, pkg }) {
  const packages = {
    ...pkg.dependencies,
    ...pkg.peerDependencies
  };

  // Webpack execution context shifts to the bundle-service folder when doing requires
  // As a result attempts to require something from the package being operated on fails
  // We must manually add the root to the module.paths to node knows how to resolve requires
  // correctly
  const rootModuleSearchPath = path.join(root, 'node_modules');
  const modulePathBackup = module.paths;
  if (!module.paths.includes(rootModuleSearchPath)) {
    // If we are operating on say /path/to/moduleA as a root, and it has a dependency
    // fooDep, require('fooDep/package.json') will fail becuases it will not search /path/to/moduleA/node_modules
    // (module.paths will start in this directory's node_modules and work its way up).
    // If we add ${root}/node_modules to the module paths it will be "as if" we required
    // from the moduleA directory.
    // THIS IS NOT A COMPLETE SOLUTION.
    // If there were ever node_modules directories in any part of the tree that is not
    // shared with this directory, it will also fail. This is unlikely to occur.
    module.paths.unshift(rootModuleSearchPath);
  }

  const results = Object.keys(packages)
    .filter((key) => key in externals)
    .reduce(function version(target, dependency) {
      target[dependency] = require(`${dependency}/package.json`).version;
      return target;
    }, {});

  // Restore paths to ensure clean behavior between runs
  module.paths = modulePathBackup;
  return results;
};
