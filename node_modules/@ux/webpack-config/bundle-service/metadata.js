const path = require('path');


/**
 * WebPack plugin that allows us to inject a metadata file in the output
 * directory that includes additional data about the build.
 *
 * @pubilc
 */
module.exports = class MetaData {
  /**
   * Constructor
   *
   * @param {String} root Root directory
   * @param {Function} dependent dependent generation
   * @public
   */
  constructor({ root, dependent } = {}) {
    this.root = root;
    this.pkg = require(path.join(root, 'package.json'));
    this.dependent = dependent;
  }

  /**
   * WebPack plugin activation.
   *
   * @param {Object} compiler WebPack compiler instance.
   * @private
   */
  apply(compiler) {
    //
    // List of dependencies that might be referenced by the externals.
    //
    const { name, version } = this.pkg;

    //
    // Generate the meta data information for the bundle service.
    //
    const contents = JSON.stringify({
      name,
      version,

      dependent: this.dependent({ root: this.root, pkg: this.pkg })
    });

    //
    // Tap in to various of hooks in order to assign an additional asset to
    // the compiler loop. This ensures that we only introduce our meta data
    // during webpack compiler time so we know 100% sure which dependencies
    // are their respective versions are used in the final bundle.
    //
    compiler.hooks.compilation.tap('BSMetaDataPlugin', (compilation) => {
      function createAsset() {
        //
        // WebPack expects a weird sources interface just to be able to read
        // the contents. Just passing it a string or buffer doesn't work, you
        // need to hold it hand. So we're mocking the interface as we don't want
        // to introduce another dependency just so it can understand a simple
        // string.
        //
        compilation.assets['bundle-service.json'] = {
          source: () => contents,
          size: () => Buffer.byteLength(contents)
        };
      }

      compilation.hooks.additionalAssets.tap('BSMetaDataPlugin', createAsset);
    });
  }
};
