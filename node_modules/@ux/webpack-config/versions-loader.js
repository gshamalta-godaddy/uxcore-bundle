const fs = require('fs');
const path = require('path');
const debug = require('diagnostics')('ux-webpack:versions-loader');
const readVersions = require('./read-versions');

/**
 * Webpack pitch loader for exposing all versions in node_modules/@ux.
 *
 * Remark (crobbins): This could be a more generic module with options:
 * - `initial`: (optional) any initial value not in `node_modules`. In
 *    our case this is the `@ux/uxcore2` version.
 * - `scopes`: (optional) set of npm scopes to expose versions for.
 * - `modules`: (optional) set of modules (scoped or unscoped) to load.
 */
const loader = module.exports = function () {
  /* Do nothing here since we are a pitch loader */
};

/**
 * We "pitch" static content to webpack ignoring any parameters to do
 * exactly one thing: load all versions stored in `node_modules/@ux/**`
 * @returns {undefined} Nothing of significance.
 */
loader.pitch = function pitch() {
  this.cacheable();
  const callback = this.async();

  //
  // 1. Find `node_modules` relative to file being imported
  // 2. Read all versions in @ux relative to that.
  // 3. Respond with static module contents.
  //
  findNodeModules(this.resourcePath, function (err, nodeModules) {
    if (err) { return callback(err); }

    const options = {
      rootDir: nodeModules,
      scopes: ['@ux'],
      includeHost: true
    };

    readVersions(options, function (error, versions) {
      if (error) { return callback(Error); }
      const code = `module.exports = ${JSON.stringify(versions, null, 2)};`;
      callback(null, code);
    });
  });
};

/**
 * Helper function that responds with the first directory that contains a
 * node_modules directory.
 * @param {string} source Current directory to check for `node_modules`.
 * @param {string} rel Original directory searched from
 * @param {function} callback Continuation to respond to when complete.
 * @returns {string} Directory within which `node_modules` can be found.
 */
function findNodeModules(source, rel, callback) {
  if (arguments.length === 2) {
    callback = rel;
    rel = source;
  }

  debug('find node_modules', source);
  if (!source || source === '/') {
    return setImmediate(callback, new Error(`Cannot find node_modules relative to ${rel}`));
  }

  fs.readdir(source, function (err, files) {
    if (err && err.code !== 'ENOTDIR') {
      return callback(err);
    }

    if (!err) {
      const modulesDir = files.filter(entry => {
        return entry === 'node_modules';
      })[0];

      if (modulesDir) {
        return callback(null, source);
      }
    }

    findNodeModules(path.dirname(source), rel, callback);
  });
}
